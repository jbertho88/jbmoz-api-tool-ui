<!DOCTYPE html>
<html lang="en"> <!-- Theme class will be added here by JS -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow">
    <meta name="description" content="Advanced Moz API Tool for SEO data analysis and link building research">
    <title>Advanced Moz API Tool</title>
    
    <!-- Preload critical resources for faster loading -->
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com">
    <link rel="preconnect" href="https://cdn.tailwindcss.com">
    
    <!-- DNS prefetch for additional performance -->
    <link rel="dns-prefetch" href="https://upload.wikimedia.org">
    <link rel="dns-prefetch" href="https://mozapi-proxy-server.vercel.app">
    
    <!-- Load Tailwind CSS synchronously to prevent FOUC -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load fonts with immediate fallback -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"></noscript>
    
    <!-- Tabulator CSS - Load synchronously to prevent FOUC -->
    <link rel="stylesheet" href="https://unpkg.com/tabulator-tables@5.5.2/dist/css/tabulator.min.css">
    <link rel="preload" href="https://unpkg.com/tabulator-tables@5.5.2/dist/css/tabulator.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://unpkg.com/tabulator-tables@5.5.2/dist/css/tabulator.min.css"></noscript>
    
    <!-- Load Tabulator JS asynchronously with error handling -->
    <script>
        // Load Tabulator asynchronously to improve initial page load
        (function() {
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/tabulator-tables@5.5.2/dist/js/tabulator.min.js';
            script.async = true;
            script.crossOrigin = 'anonymous';
            script.onerror = function() {
                console.warn('Failed to load Tabulator library. Table functionality will be limited.');
            };
            document.head.appendChild(script);
        })();
    </script>
    <!-- Load jsPDF for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* Critical CSS - Prevents FOUC */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: #f9fafb;
            color: #111827;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            opacity: 1;
            transition: opacity 0.3s ease;
        }
        
        /* Loading state - hidden until CSS loads */
        .css-loading {
            opacity: 0;
        }
        
        .css-loaded {
            opacity: 1;
        }
        
        /* Base styles */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: var(--bg-body);
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
            margin: 0;
            padding: 0;
            will-change: background-color, color;
        }

        /* Theme Variables - Light (Default) */
        :root, .light {
            /* Backgrounds */
            --bg-body: #f9fafb;
            --bg-container: #ffffff;
            --bg-container-translucent: rgba(255, 255, 255, 0.5);
            --bg-input: #f3f4f6;
            --bg-input-secondary: #e5e7eb;
            --bg-code: #fefce8;
            --bg-disabled: #d1d5db;
            
            /* Borders */
            --border-primary: #e5e7eb;
            --border-secondary: #d1d5db;
            
            /* Text Colors */
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --text-accent: #0284c7;
            --text-accent-hover: #0369a1;
            --text-heading: #0ea5e9;
            --text-error: #b91c1c;
            
            /* Button Colors */
            --btn-primary-bg: #002F50;
            --btn-primary-hover: #001d30;
            --btn-copy-bg: #f97316;
            --btn-copy-hover: #ea580c;
            --btn-export-bg: #10b981;
            --btn-export-hover: #059669;
            --btn-view-data-bg: #0ea5e9;
            --btn-view-data-hover: #0284c7;
            --btn-clear-bg: #ef4444;
            --btn-clear-hover: #b91c1c;
            
            /* Error Colors */
            --error-bg: #fee2e2;
            --error-border: #fca5a5;
            
            /* Tabulator Colors */
            --tabulator-header-bg: var(--bg-input);
            --tabulator-row-bg: var(--bg-container);
            --tabulator-row-even-bg: var(--bg-input-secondary);
            --tabulator-border: var(--border-primary);
            --tabulator-text: var(--text-primary);
            --tabulator-footer-bg: var(--bg-input);
            --tabulator-pag-button-bg: var(--bg-container);
            --tabulator-pag-button-hover: var(--bg-input-secondary);
        }

        /* Dark Theme */
        .dark {
            --bg-body: #020617;
            --bg-container: #1e293b;
            --bg-container-translucent: rgba(30, 41, 59, 0.5);
            --bg-input: #0f172a;
            --bg-input-secondary: #334155;
            --bg-code: #000000;
            --bg-disabled: #475569;
            --border-primary: #334155;
            --border-secondary: #475569;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --text-accent: #38bdf8;
            --text-accent-hover: #7dd3fc;
            --text-heading: #38bdf8;
            --text-error: #f87171;
            --btn-primary-bg: #0ea5e9;
            --btn-primary-hover: #38bdf8;
            --btn-copy-bg: #f97316;
            --btn-copy-hover: #fb923c;
            --btn-export-bg: #10b981;
            --btn-export-hover: #34d399;
            --btn-view-data-bg: #0ea5e9;
            --btn-view-data-hover: #38bdf8;
            --btn-clear-bg: #ef4444;
            --btn-clear-hover: #f87171;
            --error-bg: rgba(153, 27, 27, 0.5);
            --error-border: #ef4444;
            --tabulator-header-bg: var(--bg-input);
            --tabulator-row-bg: #1e293b;
            --tabulator-row-even-bg: #0f172a;
            --tabulator-border: var(--border-primary);
            --tabulator-text: var(--text-primary);
            --tabulator-footer-bg: var(--bg-input);
            --tabulator-pag-button-bg: var(--bg-input-secondary);
            --tabulator-pag-button-hover: #475569;
        }

        /* Retro Theme */
        .retro {
            --bg-body: #000000;
            --bg-container: #1a001a;
            --bg-container-translucent: rgba(26, 0, 26, 0.5);
            --bg-input: #2a002a;
            --bg-input-secondary: #3d003d;
            --bg-code: #000000;
            --bg-disabled: #4a148c;
            --border-primary: #4a148c;
            --border-secondary: #6a1b9a;
            --text-primary: #e0e0e0;
            --text-secondary: #ad5eda;
            --text-accent: #2de2e6;
            --text-accent-hover: #81f7f9;
            --text-heading: #9700cc;
            --text-error: #f6019d;
            --btn-primary-bg: #f6019d;
            --btn-primary-hover: #d40078;
            --btn-copy-bg: #9700cc;
            --btn-copy-hover: #7b00a3;
            --btn-export-bg: #11d18e;
            --btn-export-hover: #0da872;
            --btn-view-data-bg: #2de2e6;
            --btn-view-data-hover: #81f7f9;
            --btn-clear-bg: #f6019d;
            --btn-clear-hover: #d40078;
            --error-bg: rgba(246, 1, 157, 0.2);
            --error-border: #f6019d;
            --tabulator-header-bg: var(--bg-input);
            --tabulator-row-bg: #1a001a;
            --tabulator-row-even-bg: #2a002a;
            --tabulator-border: var(--border-primary);
            --tabulator-text: var(--text-primary);
            --tabulator-footer-bg: var(--bg-input);
            --tabulator-pag-button-bg: var(--bg-input-secondary);
            --tabulator-pag-button-hover: #6a1b9a;
        }

        /* High Contrast Theme */
        .high-contrast {
            --bg-body: #000000;
            --bg-container: #000000;
            --bg-container-translucent: rgba(0, 0, 0, 0.5);
            --bg-input: #000000;
            --bg-input-secondary: #000000;
            --bg-code: #000000;
            --bg-disabled: #333333;
            --border-primary: #ffffff;
            --border-secondary: #ffffff;
            --text-primary: #ffffff;
            --text-secondary: #e5e5e5;
            --text-accent: #ffffff;
            --text-accent-hover: #cccccc;
            --text-heading: #ffffff;
            --text-error: #ffffff;
            --btn-primary-bg: #ffffff;
            --btn-primary-hover: #e5e5e5;
            --btn-copy-bg: #ffffff;
            --btn-copy-hover: #e5e5e5;
            --btn-export-bg: #ffffff;
            --btn-export-hover: #e5e5e5;
            --btn-view-data-bg: #ffffff;
            --btn-view-data-hover: #e5e5e5;
            --btn-clear-bg: #ffffff;
            --btn-clear-hover: #e5e5e5;
            --error-bg: #000000;
            --error-border: #ff0000;
            --tabulator-header-bg: #000;
            --tabulator-row-bg: #000;
            --tabulator-row-even-bg: #000;
            --tabulator-border: #fff;
            --tabulator-text: #fff;
            --tabulator-footer-bg: #000;
            --tabulator-pag-button-bg: #333;
            --tabulator-pag-button-hover: #555;
        }
        
        /* High contrast button text override */
        .high-contrast .btn-inverted-text {
            color: #000000 !important;
        }

        /* Loading spinner */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.2);
            width: 24px; 
            height: 24px; 
            border-radius: 50%;
            border-left-color: #ffffff;
            animation: spin 1s ease infinite;
            will-change: transform;
        }
        
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }
        
        /* Form elements */
        .input-section { 
            display: none; 
            margin-top: 1.5rem; 
            padding-top: 1.5rem; 
            border-top-width: 1px; 
            border-color: var(--border-primary); 
        }
        
        option[disabled] { 
            font-weight: bold; 
            background-color: var(--bg-input-secondary); 
        }

        /* Modal content styles */
        #readme-modal-content h2 { 
            border-bottom: 1px solid var(--border-primary);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
            margin-top: 1.25rem;
            font-size: 1.25rem;
            line-height: 1.75rem;
            border-color: var(--border-primary); 
            color: var(--text-accent); 
        }
        
        #readme-modal-content h3 { 
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
            font-size: 1.125rem;
            line-height: 1.75rem;
            color: var(--text-primary); 
        }
        
        #readme-modal-content p, 
        #readme-modal-content li { 
            color: var(--text-secondary); 
        }
        
        #readme-modal-content a { 
            color: var(--text-accent); 
            text-decoration: underline;
        }
        
        #readme-modal-content a:hover { 
            text-decoration: underline;
        }
        
        #readme-modal-content ul, 
        #readme-modal-content ol { 
            margin-left: 1.25rem;
            list-style-type: disc;
        }
        
        #readme-modal-content ol { 
            list-style-type: decimal;
        }
        
        #readme-modal-content code { 
            background-color: rgba(0, 0, 0, 0.5);
            padding: 0.125rem 0.25rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            line-height: 1.25rem;
            color: var(--btn-copy-bg); 
        }
        
        .readme-method { 
            margin-bottom: 1.5rem; 
        }

        /* Tabulator table styles */
        .tabulator {
            border-color: var(--border-primary);
            background-color: var(--bg-container);
            color: var(--text-primary);
        }
        
        .tabulator .tabulator-header {
            background-color: var(--tabulator-header-bg);
            border-bottom-color: var(--border-primary);
        }
        
        .tabulator .tabulator-header .tabulator-col {
            background-color: var(--tabulator-header-bg);
            color: var(--text-primary);
        }
        
        .tabulator .tabulator-tableHolder .tabulator-table .tabulator-row {
            background-color: var(--tabulator-row-bg);
            color: var(--text-primary);
        }
        
        .tabulator .tabulator-tableHolder .tabulator-table .tabulator-row.tabulator-row-even {
            background-color: var(--tabulator-row-even-bg);
        }
        
        .tabulator .tabulator-footer {
            background-color: var(--tabulator-footer-bg);
            border-top-color: var(--border-primary);
        }
        
        .tabulator .tabulator-footer .tabulator-paginator button {
            background: var(--tabulator-pag-button-bg);
            color: var(--text-primary);
        }
        
        .tabulator .tabulator-footer .tabulator-paginator button:hover {
            background: var(--tabulator-pag-button-hover);
        }
        
        /* Tooltip styles */
        .tooltip-container {
            position: relative;
            display: inline-block;
        }
        
        .tooltip-icon {
            display: inline-block;
            width: 14px;
            height: 14px;
            margin-left: 4px;
            border-radius: 50%;
            background-color: var(--text-secondary);
            color: var(--bg-body);
            font-size: 10px;
            line-height: 14px;
            text-align: center;
            cursor: help;
            vertical-align: middle;
        }
        
        .tooltip-text {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--bg-container);
            color: var(--text-primary);
            text-align: center;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--border-primary);
            white-space: nowrap;
            z-index: 1000;
            font-size: 12px;
            max-width: 250px;
            white-space: normal;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        
        /* Sortable table headers */
        .sortable-header {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 20px;
        }
        
        .sortable-header:hover {
            background-color: var(--bg-input-secondary);
        }
        
        .sort-indicator {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: var(--text-secondary);
        }
        
        .sort-asc .sort-indicator::after { content: '▲'; }
        .sort-desc .sort-indicator::after { content: '▼'; }
        
        /* Copy button in table */
        .copy-keyword-btn {
            display: inline-block;
            margin-left: 4px;
            opacity: 0;
            transition: opacity 0.2s;
            cursor: pointer;
            font-size: 12px;
        }
        
        tr:hover .copy-keyword-btn {
            opacity: 1;
        }
        
        /* Competitive Analysis Dashboard Grid Constraints */
        .metrics-grid-container {
            display: grid;
            width: 100%;
            gap: 1rem;
            grid-template-columns: repeat(1, minmax(0, 1fr));
        }
        
        .metrics-grid-container > * {
            min-width: 0;
            max-width: 100%;
            width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        @media (min-width: 768px) {
            .metrics-grid-container {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }
        
        @media (min-width: 1280px) {
            .metrics-grid-container {
                grid-template-columns: repeat(4, minmax(0, 1fr));
            }
        }
    </style>
</head>
<body data-proxy="https://mozapi-proxy-server.vercel.app/api/getMozData" class="transition-colors duration-300 css-loading">

    <div class="w-full max-w-4xl mx-auto bg-[var(--bg-container-translucent)] backdrop-blur-sm rounded-2xl shadow-2xl p-6 md:p-8 border border-[var(--border-primary)] my-8">
        
        <header class="relative text-center mb-6">
            <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Moz_logo.svg/177px-Moz_logo.svg.png" alt="Moz Logo" class="mx-auto h-12 mb-4" id="moz-logo" loading="lazy" decoding="async" width="177" height="48">
            <h1 class="text-3xl font-bold text-[var(--text-heading)]">Advanced Moz API Tool</h1>
            <p class="text-[var(--text-primary)] mt-2">Add your key and select an API method to get started.</p>
        </header>
        
        <section class="mb-6 bg-[var(--bg-input)] p-4 rounded-lg border border-[var(--border-secondary)]" aria-labelledby="api-key-heading">
            <h2 id="api-key-heading" class="block text-sm font-medium text-[var(--text-secondary)] mb-2">Moz API Key</h2>
            <div id="apiKeyDisplay" class="hidden items-center justify-between" role="status" aria-live="polite">
                <span id="apiKeyText" class="text-[var(--text-secondary)] font-mono"></span>
                <button id="editApiKeyBtn" class="text-sm text-[var(--text-accent)] hover:text-[var(--text-accent-hover)] font-semibold" aria-label="Edit API key">Edit</button>
            </div>
            <div id="apiKeyInputArea" class="flex items-center gap-2">
                <label for="apiKeyInput" class="sr-only">Enter your Moz API key</label>
                <input type="password" id="apiKeyInput" class="w-full bg-[var(--bg-body)] border border-[var(--border-secondary)] rounded-md px-3 py-2 text-[var(--text-primary)] placeholder-[var(--text-secondary)] focus:outline-none focus:ring-2 ring-[var(--text-accent)]" placeholder="mozscape-1234abcd..." autocomplete="off" aria-describedby="api-key-help">
                <button id="saveApiKeyBtn" class="bg-[var(--btn-primary-bg)] hover:bg-[var(--btn-primary-hover)] text-white font-semibold px-4 py-2 text-sm rounded-md transition btn-inverted-text" aria-label="Save API key">Save</button>
            </div>
            <div id="api-key-help" class="sr-only">Enter your Moz API key to access the API services</div>
            <!-- Quota Display Area -->
            <div id="quota-display" class="hidden mt-3 text-sm text-[var(--text-secondary)]" role="status" aria-live="polite">
                <span id="quota-text"></span>
            </div>
        </section>

        <section aria-labelledby="method-heading">
            <label for="methodSelector" id="method-heading" class="block text-sm font-medium text-[var(--text-secondary)] mb-2">API Method</label>
            <select id="methodSelector" class="w-full bg-[var(--bg-input)] border border-[var(--border-secondary)] rounded-md px-3 py-2 focus:outline-none focus:ring-2 ring-[var(--text-accent)]" aria-describedby="method-help">
                <option value="" disabled selected>-- Select a Method --</option>
                <optgroup label="Keyword Research">
                    <option value="searchIntent">Fetch Search Intent</option>
                    <option value="keywordMetrics">Fetch Keyword Metrics</option>
                    <option value="relatedKeywords">List Related Keywords</option>
                </optgroup>
                <optgroup label="Competitive Research">
                    <option value="competitiveAnalysis">Competitive Analysis</option>
                    <option value="rankingKeywords">List Ranking Keywords</option>
                    <option value="keywordCount">Count Ranking Keywords</option>
                    <option value="topPages">List Top Pages</option>
                </optgroup>
                <optgroup label="Website Research">
                    <option value="siteMetrics">Fetch Site Metrics</option>
                    <option value="brandAuthority">Fetch Brand Authority</option>
                </optgroup>
                <optgroup label="Link Building Research">
                    <option value="anchorText">Get Anchor Texts Lists</option>
                    <option value="linkingDomains">List Linking Domains</option>
                    <option value="recentlyGainedLinks">List Recently Gained Links</option>
                    <option value="recentlyLostLinks">List Recently Lost Links</option>
                    <option value="linkIntersect">Fetch Link Intersects</option>
                    <option value="listLinks">List Links</option>
                    <option value="filterLinksByAnchor">Filter Links by Anchor Text</option>
                    <option value="filterLinksByDomain">Filter Links by Domain</option>
                </optgroup>
                <optgroup label="Link Checks">
                    <option value="finalRedirect">Get Final Redirect Target</option>
                    <option value="linkStatus">Get Link Status</option>
                </optgroup>
            </select>
            <div id="method-help" class="sr-only">Choose the Moz API method you want to use</div>
        </section>

        <form id="api-form" aria-label="API request form">
             <div id="inputsContainer" class="mt-4" role="region" aria-live="polite">
                <fieldset id="siteMetricsInputs" class="input-section space-y-4"><legend class="sr-only">Site Metrics Inputs</legend></fieldset>
                <fieldset id="keywordMetricsInputs" class="input-section space-y-4"><legend class="sr-only">Keyword Metrics Inputs</legend></fieldset>
                <fieldset id="brandAuthorityInputs" class="input-section space-y-4"><legend class="sr-only">Brand Authority Inputs</legend></fieldset>
                <fieldset id="searchIntentInputs" class="input-section space-y-4"><legend class="sr-only">Search Intent Inputs</legend></fieldset>
                <fieldset id="rankingKeywordsInputs" class="input-section space-y-4"><legend class="sr-only">Ranking Keywords Inputs</legend></fieldset>
                <fieldset id="relatedKeywordsInputs" class="input-section space-y-4"><legend class="sr-only">Related Keywords Inputs</legend></fieldset>
                <fieldset id="keywordCountInputs" class="input-section space-y-4"><legend class="sr-only">Keyword Count Inputs</legend></fieldset>
                <fieldset id="anchorTextInputs" class="input-section space-y-4"><legend class="sr-only">Anchor Text Inputs</legend></fieldset>
                <fieldset id="recentlyGainedLinksInputs" class="input-section space-y-4"><legend class="sr-only">Recently Gained Links Inputs</legend></fieldset>
                <fieldset id="recentlyLostLinksInputs" class="input-section space-y-4"><legend class="sr-only">Recently Lost Links Inputs</legend></fieldset>
                <fieldset id="linkingDomainsInputs" class="input-section space-y-4"><legend class="sr-only">Linking Domains Inputs</legend></fieldset>
                <fieldset id="finalRedirectInputs" class="input-section space-y-4"><legend class="sr-only">Final Redirect Inputs</legend></fieldset>
                <fieldset id="topPagesInputs" class="input-section space-y-4"><legend class="sr-only">Top Pages Inputs</legend></fieldset>
                <fieldset id="linkIntersectInputs" class="input-section space-y-4"><legend class="sr-only">Link Intersect Inputs</legend></fieldset>
                <fieldset id="listLinksInputs" class="input-section space-y-4"><legend class="sr-only">List Links Inputs</legend></fieldset>
                <fieldset id="linkStatusInputs" class="input-section space-y-4"><legend class="sr-only">Link Status Inputs</legend></fieldset>
                <fieldset id="filterLinksByAnchorInputs" class="input-section space-y-4"><legend class="sr-only">Filter Links by Anchor Inputs</legend></fieldset>
                <fieldset id="filterLinksByDomainInputs" class="input-section space-y-4"><legend class="sr-only">Filter Links by Domain Inputs</legend></fieldset>
                <fieldset id="competitiveAnalysisInputs" class="input-section space-y-4"><legend class="sr-only">Competitive Analysis Inputs</legend></fieldset>
            </div>
            <div class="mt-8 text-center">
                <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
                    <button type="submit" id="submit-btn" class="bg-[var(--btn-primary-bg)] hover:bg-[var(--btn-primary-hover)] text-white font-bold px-8 py-3 rounded-lg transition duration-300 flex items-center justify-center w-full md:w-auto md:min-w-[200px] disabled:bg-[var(--bg-disabled)] disabled:cursor-not-allowed btn-inverted-text" aria-describedby="submit-help">
                        Run Request
                    </button>
                    <button id="history-btn" type="button" class="bg-[var(--btn-copy-bg)] hover:bg-[var(--btn-copy-hover)] text-white font-bold px-8 py-3 rounded-lg transition duration-300 btn-inverted-text" aria-label="View recent API calls">
                        📋 Recent API Calls
                    </button>
                </div>
                <div id="submit-help" class="sr-only">Submit your API request with the selected method and parameters</div>
            </div>
        </form>

        <section id="status-container" class="mt-8" aria-live="polite">
            <div id="error-message" role="alert" class="hidden bg-[var(--error-bg)] border border-[var(--error-border)] text-[var(--text-error)] px-4 py-3 rounded-lg text-center"></div>
            <div id="results-container" class="hidden bg-[var(--bg-input)] p-4 md:p-6 rounded-xl border border-[var(--border-primary)]" role="region" aria-labelledby="results-heading">
                <div class="flex flex-col sm:flex-row justify-between items-start mb-4 gap-4">
                    <h2 id="results-heading" class="text-xl font-bold text-[var(--text-heading)]">API Results</h2>
                    <div class="flex items-center gap-2 flex-wrap justify-end" role="toolbar" aria-label="Results actions">
                        <button id="view-data-btn" class="bg-[var(--btn-view-data-bg)] hover:bg-[var(--btn-view-data-hover)] text-white font-semibold px-4 py-2 text-sm rounded-md transition duration-300 btn-inverted-text" aria-label="Toggle between table and JSON view">View Table</button>
                        <button id="filter-btn" class="bg-[var(--btn-view-data-bg)] hover:bg-[var(--btn-view-data-hover)] text-white font-semibold px-4 py-2 text-sm rounded-md transition duration-300 btn-inverted-text hidden" aria-label="Filter table data">Filter</button>
                        <button id="copy-json-btn" class="bg-[var(--btn-copy-bg)] hover:bg-[var(--btn-copy-hover)] text-white font-semibold px-4 py-2 text-sm rounded-md transition duration-300 btn-inverted-text" aria-label="Copy JSON data to clipboard">Copy JSON</button>
                        <button id="export-btn" class="bg-[var(--btn-export-bg)] hover:bg-[var(--btn-export-hover)] text-white font-semibold px-4 py-2 text-sm rounded-md transition duration-300 btn-inverted-text" aria-label="Export data as CSV file">Export to CSV</button>
                        <button id="export-pdf-btn" class="bg-[var(--btn-export-bg)] hover:bg-[var(--btn-export-hover)] text-white font-semibold px-4 py-2 text-sm rounded-md transition duration-300 btn-inverted-text hidden" aria-label="Export dashboard as PDF">Export to PDF</button>
                        <button id="clear-data-btn" class="bg-[var(--btn-clear-bg)] hover:bg-[var(--btn-clear-hover)] text-white font-semibold px-4 py-2 text-sm rounded-md transition duration-300 btn-inverted-text" aria-label="Clear results data">Clear Data</button>
                    </div>
                </div>
                <div id="active-filters-container" class="hidden mb-4 space-x-2" role="status" aria-live="polite"></div>
                <div id="raw-wrapper">
                    <pre class="whitespace-pre-wrap break-all text-sm bg-[var(--bg-code)] text-[var(--text-primary)] p-4 rounded-lg" role="region" aria-label="Raw JSON data"><code></code></pre>
                </div>
                <div id="table-wrapper" class="hidden overflow-x-auto" role="region" aria-label="Data table">
                    <div id="results-table"></div>
                </div>
            </div>
        </section>

        <footer class="text-center text-[var(--text-secondary)] text-sm mt-8 border-t border-[var(--border-primary)] pt-6">
            <div class="mb-4 flex justify-center items-center gap-2" role="toolbar" aria-label="Theme selection">
                <button data-theme="light" class="theme-btn p-2 rounded-lg" aria-label="Switch to light theme">Light</button>
                <button data-theme="dark" class="theme-btn p-2 rounded-lg" aria-label="Switch to dark theme">Dark</button>
                <button data-theme="retro" class="theme-btn p-2 rounded-lg" aria-label="Switch to retro theme">Retro</button>
                <button data-theme="high-contrast" class="theme-btn p-2 rounded-lg" aria-label="Switch to high contrast theme">High Contrast</button>
            </div>
            <p>&copy; Jonathan Berthold 2025</p>
            <nav class="mt-2 space-x-4" aria-label="External links">
                <a href="https://moz.com/api/dashboard" target="_blank" rel="noopener" class="hover:text-[var(--text-accent-hover)] transition text-[var(--text-accent)]">API Dashboard</a>
                <span class="text-[var(--text-secondary)]" aria-hidden="true">|</span>
                <a href="https://moz.com/products/api/keys" target="_blank" rel="noopener" class="hover:text-[var(--text-accent-hover)] transition text-[var(--text-accent)]">Get Moz API Key</a>
                <span class="text-[var(--text-secondary)]" aria-hidden="true">|</span>
                 <a href="https://moz.com/api/docs/welcome" target="_blank" rel="noopener" class="hover:text-[var(--text-accent-hover)] transition text-[var(--text-accent)]">API Docs</a>
                <span class="text-[var(--text-secondary)]" aria-hidden="true">|</span>
                <button id="readme-btn" class="hover:text-[var(--text-accent-hover)] transition text-[var(--text-accent)]" aria-label="Open help documentation">Read Me</button>
            </nav>
        </footer>

    </div>

    <!-- Modals -->
    <div id="readme-modal" class="hidden fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4" role="dialog" aria-labelledby="readme-modal-title" aria-modal="true">
        <div class="bg-[var(--bg-container)] border border-[var(--border-primary)] w-full max-w-3xl max-h-[90vh] rounded-2xl shadow-2xl flex flex-col">
            <div class="flex justify-between items-center p-4 border-b border-[var(--border-primary)]">
                <h2 id="readme-modal-title" class="text-lg font-semibold text-[var(--text-primary)]">Read Me / Help</h2>
                <button id="close-readme-btn" class="text-[var(--text-secondary)] hover:text-[var(--text-primary)]" aria-label="Close help dialog">&times;</button>
            </div>
            <div id="readme-modal-content" class="p-6 overflow-y-auto"></div>
        </div>
    </div>
     <div id="filter-modal" class="hidden fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4" role="dialog" aria-labelledby="filter-modal-title" aria-modal="true">
        <div class="bg-[var(--bg-container)] border border-[var(--border-primary)] w-full max-w-4xl rounded-2xl shadow-2xl flex flex-col max-h-[90vh]">
            <div class="flex justify-between items-center p-4 border-b border-[var(--border-primary)]">
                <h2 id="filter-modal-title" class="text-lg font-semibold text-[var(--text-primary)]">Filter Data</h2>
                <button id="close-filter-btn" class="text-[var(--text-secondary)] hover:text-[var(--text-primary)]" aria-label="Close filter dialog">&times;</button>
            </div>
            <div id="filter-fields-container" class="p-6 overflow-y-auto space-y-4"></div>
            <div class="p-4 border-t border-[var(--border-primary)] flex justify-end gap-2">
                <button id="cancel-filter-btn" class="bg-[var(--bg-input-secondary)] hover:bg-[var(--bg-disabled)] text-[var(--text-primary)] font-semibold px-4 py-2 text-sm rounded-md transition">Cancel</button>
                <button id="apply-filter-btn" class="bg-[var(--btn-primary-bg)] hover:bg-[var(--btn-primary-hover)] text-white font-semibold px-4 py-2 text-sm rounded-md transition btn-inverted-text">Apply</button>
            </div>
        </div>
    </div>

    <!-- History Modal -->
    <div id="history-modal" class="hidden fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4" role="dialog" aria-labelledby="history-modal-title" aria-modal="true">
        <div class="bg-[var(--bg-container)] border border-[var(--border-primary)] w-full max-w-4xl max-h-[90vh] rounded-2xl shadow-2xl flex flex-col">
            <div class="flex justify-between items-center p-4 border-b border-[var(--border-primary)]">
                    <h2 id="history-modal-title" class="text-lg font-semibold text-[var(--text-primary)]">Recent API Calls</h2>
                <div class="flex items-center gap-2">
                    <button id="export-history-btn" class="bg-[var(--btn-export-bg)] hover:bg-[var(--btn-export-hover)] text-white font-semibold px-3 py-1 text-sm rounded-md transition btn-inverted-text" aria-label="Export history">Export</button>
                    <button id="clear-history-btn" class="bg-[var(--btn-clear-bg)] hover:bg-[var(--btn-clear-hover)] text-white font-semibold px-3 py-1 text-sm rounded-md transition btn-inverted-text" aria-label="Clear all history">Clear All</button>
                    <button id="close-history-btn" class="text-[var(--text-secondary)] hover:text-[var(--text-primary)]" aria-label="Close history dialog">&times;</button>
                </div>
            </div>
            <div class="p-4 border-b border-[var(--border-primary)]">
                <input type="text" id="history-search" placeholder="Search history by method, parameters, or date..." class="w-full bg-[var(--bg-input)] border border-[var(--border-secondary)] rounded-md px-3 py-2 text-[var(--text-primary)] placeholder-[var(--text-secondary)]">
            </div>
            <div id="history-list" class="p-4 overflow-y-auto flex-1">
                <div id="history-empty" class="text-center text-[var(--text-secondary)] py-8">
                    <p>No search history yet.</p>
                    <p class="text-sm mt-2">Your searches will be automatically saved here.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Performance optimization: Use requestAnimationFrame for DOM updates
        const raf = window.requestAnimationFrame || window.setTimeout;
        
        // Debounce function for better performance
        const debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };
        
        // Data processing utilities - centralized to eliminate duplication
        const DataProcessor = {
            na: 'N/A',
            
            snakeToTitleCase: (s) => s.replace(/^_*(.)|_+(.)/g, (s, c, d) => c ? c.toUpperCase() : ' ' + d.toUpperCase()),
            
            processLinkMetrics: (linkItem, query, originalParams) => {
                const baseInfo = { 'Query': query, 'Scope': originalParams.scope };
                const metrics = linkItem.site_metrics || {};
                const otherData = { ...linkItem };
                delete otherData.site_metrics;
                const combined = { ...baseInfo, ...metrics, ...otherData };
                const titleCased = {};
                for (const key in combined) {
                    titleCased[DataProcessor.snakeToTitleCase(key)] = combined[key];
                }
                return titleCased;
            },
            
            processResults: (results, method, originalParams) => {
                const rows = [];
                
                results.forEach((res, i) => {
                    let query;
                    if (['linkIntersect', 'linkStatus', 'filterLinksByDomain'].includes(method)) {
                        query = 'N/A';
                    } else {
                        query = (originalParams.targets || originalParams.keywords)[i] || DataProcessor.na;
                    }
                    
                    if (res.status !== 'success') {
                        rows.push({ Query: query, Status: `Error: ${res.reason || 'Unknown'}` });
                        return;
                    }
                    
                    // Process each method type
                    const methodProcessors = {
                        siteMetrics: () => {
                            const metrics = res.data.site_metrics || {};
                            const orderedMetrics = {'Page Authority': metrics.page_authority, 'Domain Authority': metrics.domain_authority, 'Spam Score': metrics.spam_score };
                            for(const key in metrics){
                                if(!['page_authority', 'domain_authority', 'spam_score'].includes(key)) {
                                    orderedMetrics[DataProcessor.snakeToTitleCase(key)] = metrics[key];
                                }
                            }
                            return {'Query': res.data.site_query?.query || query, 'Scope': res.data.site_query?.scope || DataProcessor.na, 'Original Query': res.data.site_query?.original_site_query?.query || query, ...orderedMetrics };
                        },
                        
                        brandAuthority: () => ({'Site Query': res.data.site_query?.query || DataProcessor.na, 'Scope': res.data.site_query?.scope || DataProcessor.na, 'Brand Authority Score': res.data.site_metrics?.brand_authority_score ?? DataProcessor.na, 'Original Query': res.data.site_query?.original_site_query?.query || query }),
                        
                        topPages: () => {
                            const pages = [];
                            (res.data.top_pages || []).forEach(page => {
                                const pageData = { 'Query': query, 'Scope': originalParams.scope, ...page };
                                const titleCased = {};
                                for(const key in pageData) { titleCased[DataProcessor.snakeToTitleCase(key)] = pageData[key]; }
                                pages.push(titleCased);
                            });
                            if (!res.data.top_pages || res.data.top_pages.length === 0) pages.push({ Query: query, Status: 'No top pages found' });
                            return pages;
                        },
                        
                        keywordMetrics: () => {
                            const metricTypeMap = { 'all': 'All Keyword Metrics', 'volume': 'Search Volume', 'difficulty': 'Difficulty', 'opportunity': 'Organic CTR', 'priority': 'Priority' };
                            return {'Keyword': res.data.serp_query?.keyword || query, 'API Call': metricTypeMap[originalParams.metricType] || originalParams.metricType, 'Locale': res.data.serp_query?.locale || DataProcessor.na, 'Device': res.data.serp_query?.device || DataProcessor.na, 'Engine': res.data.serp_query?.engine || DataProcessor.na, 'Volume': res.data.keyword_metrics?.volume ?? DataProcessor.na, 'Difficulty': res.data.keyword_metrics?.difficulty ?? DataProcessor.na, 'Opportunity CTR': res.data.keyword_metrics?.organic_ctr ?? DataProcessor.na, 'Priority': res.data.keyword_metrics?.priority ?? DataProcessor.na };
                        },
                        
                        searchIntent: () => {
                            const intentData = {};
                            (res.data.keyword_intent?.all_intents || []).forEach(intent => {
                                intentData[`${DataProcessor.snakeToTitleCase(intent.label)} Score`] = intent.score ?? DataProcessor.na;
                            });
                            return {'Keyword': res.data.serp_query?.keyword || query, 'Locale': res.data.serp_query?.locale || DataProcessor.na, 'Device': res.data.serp_query?.device || DataProcessor.na, 'Engine': res.data.serp_query?.engine || DataProcessor.na, 'Primary Intent': (res.data.keyword_intent?.primary_intents || []).join(', ') || DataProcessor.na, ...intentData };
                        },
                        
                        rankingKeywords: () => {
                            const keywords = [];
                            const baseInfo = { 'Query': query, 'Scope': originalParams.scope, 'Locale': originalParams.locale };
                            if(res.data.ranking_keywords?.length > 0){
                                res.data.ranking_keywords.forEach(kw => { keywords.push({ ...baseInfo, 'Keyword': kw.keyword, 'Ranking Page': kw.ranking_page, 'Rank Position': kw.rank_position, 'Difficulty': kw.difficulty, 'Volume': kw.volume }); });
                            } else { keywords.push({ ...baseInfo, Status: 'No ranking keywords found' }); }
                            return keywords;
                        },
                        
                        relatedKeywords: () => {
                            const suggestions = [];
                            const baseInfo = { 'Keyword': query, 'Locale': res.data.serp_query?.locale, 'Device': res.data.serp_query?.device, 'Engine': res.data.serp_query?.engine };
                            if(res.data.suggestions?.length > 0){
                                res.data.suggestions.forEach(sug => { suggestions.push({ ...baseInfo, 'Suggested Keyword': sug.keyword, 'Relevance': sug.relevance }); });
                            } else { suggestions.push({ ...baseInfo, Status: 'No suggestions found' }); }
                            return suggestions;
                        },
                        
                        keywordCount: () => {
                            const positions = res.data.ranking_keyword_count?.position || {};
                            const rankCounts = {};
                            for (let i = 1; i <= 50; i++) {
                                rankCounts[`Rank ${i} Count`] = positions[`rank_${i}`] ?? 0;
                            }
                            return {'Query': query, 'Scope': originalParams.scope, 'Locale': originalParams.locale, 'Total Ranking Count': res.data.ranking_keyword_count?.total ?? DataProcessor.na, ...rankCounts };
                        },
                        
                        anchorText: () => {
                            const anchorTexts = [];
                            const baseInfo = { 'Query': query, 'Scope': originalParams.scope };
                            if(res.data.anchor_texts?.length > 0){
                                res.data.anchor_texts.forEach(at => { anchorTexts.push({ ...baseInfo, 'Anchor Text': at.text, 'External Root Domains': at.external_root_domains, 'External Pages': at.external_pages }); });
                            } else { anchorTexts.push({ ...baseInfo, Status: 'No anchor texts found' }); }
                            return anchorTexts;
                        },
                        
                        recentlyGainedLinks: () => {
                            const links = [];
                            (res.data.gained_linking_domains || []).forEach(link => links.push(DataProcessor.processLinkMetrics(link, query, originalParams)));
                            if (!res.data.gained_linking_domains || res.data.gained_linking_domains.length === 0) links.push({ Query: query, Status: 'No recently gained links found' });
                            return links;
                        },
                        
                        recentlyLostLinks: () => {
                            const links = [];
                            (res.data.lost_linking_domains || []).forEach(link => links.push(DataProcessor.processLinkMetrics(link, query, originalParams)));
                            if (!res.data.lost_linking_domains || res.data.lost_linking_domains.length === 0) links.push({ Query: query, Status: 'No recently lost links found' });
                            return links;
                        },
                        
                        linkingDomains: () => {
                            const links = [];
                            (res.data.linking_domains || []).forEach(link => links.push(DataProcessor.processLinkMetrics(link, query, originalParams)));
                            if (!res.data.linking_domains || res.data.linking_domains.length === 0) links.push({ Query: query, Status: 'No linking domains found' });
                            return links;
                        },
                        
                        finalRedirect: () => ({ 'Query': query, 'Scope': originalParams.scope, 'Original Query': res.data.site_query?.original_site_query?.query || query, 'Destination': res.data.destination || 'No redirect found' }),
                        
                        linkIntersect: () => {
                            const intersectData = res.data.link_intersects || [];
                            if (intersectData.length === 0) {
                                return [{ Status: 'No intersecting links found' }];
                            } else {
                                const intersects = [];
                                const baseInfo = {
                                    'Linking To': (res.data.is_linking_to || []).map(t => t.query).join(', '),
                                    'Not Linking To': (res.data.not_linking_to || []).map(t => t.query).join(', '),
                                    'Minimum Matching Targets': res.data.options?.minimum_matching_targets || DataProcessor.na,
                                    'Scope': res.data.options?.scope || DataProcessor.na,
                                    'Sort': res.data.options?.sort || DataProcessor.na
                                };
                                intersectData.forEach(intersect => {
                                    (intersect.matching_source_pages || [{page: 'N/A', page_authority: 'N/A'}]).forEach(sourcePage => {
                                        intersects.push({
                                            ...baseInfo,
                                            'Intersecting Domain': intersect.page,
                                            'Intersecting Title': intersect.title,
                                            'Intersecting DA': intersect.domain_authority,
                                            'Intersecting Spam Score': intersect.spam_score,
                                            'Matching Target Indexes': (intersect.matching_target_indexes || []).join(', '),
                                            'Source Page': sourcePage.page,
                                            'Source PA': sourcePage.page_authority
                                        });
                                    });
                                });
                                return intersects;
                            }
                        },
                        
                        listLinks: () => {
                            const links = [];
                            (res.data.links || []).forEach(link => {
                                const sourceMetrics = link.source_site_metrics || {};
                                const targetMetrics = link.target_site_metrics || {};
                                const linkInfo = { ...link };
                                delete linkInfo.source_site_metrics;
                                delete linkInfo.target_site_metrics;

                                const row = {};
                                for (const key in sourceMetrics) row[`Source ${DataProcessor.snakeToTitleCase(key)}`] = sourceMetrics[key];
                                for (const key in targetMetrics) row[`Target ${DataProcessor.snakeToTitleCase(key)}`] = targetMetrics[key];
                                for (const key in linkInfo) row[DataProcessor.snakeToTitleCase(key)] = linkInfo[key];
                                links.push(row);
                            });
                            if (!res.data.links || res.data.links.length === 0) links.push({ Query: query, Status: 'No links found' });
                            return links;
                        },
                        
                        filterLinksByAnchor: () => {
                            const links = [];
                            (res.data.links || []).forEach(link => {
                                const sourceMetrics = link.source_site_metrics || {};
                                const targetMetrics = link.target_site_metrics || {};
                                const linkInfo = { ...link };
                                delete linkInfo.source_site_metrics;
                                delete linkInfo.target_site_metrics;

                                const row = {};
                                for (const key in sourceMetrics) row[`Source ${DataProcessor.snakeToTitleCase(key)}`] = sourceMetrics[key];
                                for (const key in targetMetrics) row[`Target ${DataProcessor.snakeToTitleCase(key)}`] = targetMetrics[key];
                                for (const key in linkInfo) row[DataProcessor.snakeToTitleCase(key)] = linkInfo[key];
                                links.push(row);
                            });
                            if (!res.data.links || res.data.links.length === 0) links.push({ Query: query, Status: 'No links found' });
                            return links;
                        },
                        filterLinksByDomain: () => {
                            const links = [];
                            (res.data.links || []).forEach(link => {
                                const sourceMetrics = link.source_site_metrics || {};
                                const targetMetrics = link.target_site_metrics || {};
                                const linkInfo = { ...link };
                                delete linkInfo.source_site_metrics;
                                delete linkInfo.target_site_metrics;

                                const row = {};
                                for (const key in sourceMetrics) row[`Source ${DataProcessor.snakeToTitleCase(key)}`] = sourceMetrics[key];
                                for (const key in targetMetrics) row[`Target ${DataProcessor.snakeToTitleCase(key)}`] = targetMetrics[key];
                                for (const key in linkInfo) row[DataProcessor.snakeToTitleCase(key)] = linkInfo[key];
                                links.push(row);
                            });
                            if (!res.data.links || res.data.links.length === 0) links.push({ Query: query, Status: 'No links found' });
                            return links;
                        },
                        
                        linkStatus: () => ({ 'Target Query': res.data.target_site_query?.query, 'Source Query': res.data.source_site_query?.query, 'Exists': res.data.exists })
                    };
                    
                    const processor = methodProcessors[method];
                    if (processor) {
                        const result = processor();
                        if (Array.isArray(result)) {
                            rows.push(...result);
                        } else {
                            rows.push(result);
                        }
                    }
                });
                
                return rows;
            }
        };
        
        // Performance monitoring
        const performanceMonitor = {
            startTime: performance.now(),
            mark: (name) => performance.mark(name),
            measure: (name, start, end) => performance.measure(name, start, end),
            logMetrics: () => {
                const loadTime = performance.now() - performanceMonitor.startTime;
                console.log(`Page load time: ${loadTime.toFixed(2)}ms`);
            }
        };
        
        // Service Worker registration for caching
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').catch(() => {
                    // Service worker registration failed, continue without caching
                });
            });
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            performanceMonitor.mark('dom-ready');
            
            // Handle CSS loading state to prevent FOUC
            const handleCSSLoad = () => {
                document.body.classList.remove('css-loading');
                document.body.classList.add('css-loaded');
            };
            
            // Ensure CSS is loaded before showing content
            if (document.readyState === 'loading') {
                document.addEventListener('readystatechange', () => {
                    if (document.readyState === 'interactive' || document.readyState === 'complete') {
                        handleCSSLoad();
                    }
                });
            } else {
                // CSS already loaded
                handleCSSLoad();
            }
            
            // Fallback: Show content after a short delay if CSS hasn't loaded
            setTimeout(handleCSSLoad, 100);
            
            let currentResultsData = null;
            let currentOriginalParams = null;
            let currentMethod = null;
            let inFlightRequest = null;
            let table = null;
            let currentFilters = [];

            const allDOMElements = {
                apiKeyDisplay: document.getElementById('apiKeyDisplay'), 
                apiKeyText: document.getElementById('apiKeyText'), 
                editApiKeyBtn: document.getElementById('editApiKeyBtn'), 
                apiKeyInputArea: document.getElementById('apiKeyInputArea'), 
                apiKeyInput: document.getElementById('apiKeyInput'), 
                saveApiKeyBtn: document.getElementById('saveApiKeyBtn'),
                readmeBtn: document.getElementById('readme-btn'), 
                readmeModal: document.getElementById('readme-modal'),
                readmeModalContent: document.getElementById('readme-modal-content'), 
                closeReadmeBtn: document.getElementById('close-readme-btn'), 
                themeBtns: document.querySelectorAll('.theme-btn'), 
                methodSelector: document.getElementById('methodSelector'), 
                form: document.getElementById('api-form'), 
                submitBtn: document.getElementById('submit-btn'),
                errorMessage: document.getElementById('error-message'), 
                resultsContainer: document.getElementById('results-container'), 
                rawWrapper: document.getElementById('raw-wrapper'),
                tableWrapper: document.getElementById('table-wrapper'),
                rawCode: document.querySelector('#raw-wrapper code'), 
                exportBtn: document.getElementById('export-btn'), 
                copyJsonBtn: document.getElementById('copy-json-btn'),
                viewDataBtn: document.getElementById('view-data-btn'),
                historyBtn: document.getElementById('history-btn'),
                clearDataBtn: document.getElementById('clear-data-btn'),
                filterBtn: document.getElementById('filter-btn'),
                filterModal: document.getElementById('filter-modal'),
                closeFilterBtn: document.getElementById('close-filter-btn'),
                cancelFilterBtn: document.getElementById('cancel-filter-btn'),
                filterFieldsContainer: document.getElementById('filter-fields-container'),
                applyFilterBtn: document.getElementById('apply-filter-btn'),
                activeFiltersContainer: document.getElementById('active-filters-container'),
                mozLogo: document.getElementById('moz-logo'),
                quotaDisplay: document.getElementById('quota-display'), 
                quotaText: document.getElementById('quota-text'),
                historyModal: document.getElementById('history-modal'),
                closeHistoryBtn: document.getElementById('close-history-btn'),
                historySearch: document.getElementById('history-search'),
                historyList: document.getElementById('history-list'),
                historyEmpty: document.getElementById('history-empty'),
                exportHistoryBtn: document.getElementById('export-history-btn'),
                clearHistoryBtn: document.getElementById('clear-history-btn'),
                exportPdfBtn: document.getElementById('export-pdf-btn')
            };

            const populateInputs = () => {
                const createLabel = (text) => `<label class="block text-sm font-medium text-[var(--text-secondary)]">${text}</label>`;
                const createSelect = (id, options) => `<select id="${id}" class="w-full bg-[var(--bg-input-secondary)] border-[var(--border-secondary)] rounded-md p-2 mt-1 text-[var(--text-primary)]">${options}</select>`;
                const createTextarea = (id, placeholder) => `<textarea id="${id}" rows="4" class="w-full bg-[var(--bg-input)] border border-[var(--border-secondary)] rounded-md p-2 mt-1 text-[var(--text-primary)] placeholder-[var(--text-secondary)]" placeholder="${placeholder}"></textarea>`;
                const createDescription = text => `<p class="text-sm text-[var(--text-secondary)]">${text}</p>`;
                const createNumberInput = (id, value, min, max, label) => createLabel(label) + `<input type="number" id="${id}" value="${value}" min="${min}" max="${max}" class="w-full bg-[var(--bg-input-secondary)] border-[var(--border-secondary)] rounded-md p-2 mt-1 text-[var(--text-primary)]">`;
                const createDateInput = (id) => `<input type="date" id="${id}" class="w-full bg-[var(--bg-input-secondary)] border-[var(--border-secondary)] rounded-md p-2 mt-1 text-[var(--text-primary)]">`;
                const createMultiSelect = (id, options) => `<select id="${id}" multiple class="w-full h-32 bg-[var(--bg-input-secondary)] border-[var(--border-secondary)] rounded-md p-2 mt-1 text-[var(--text-primary)]">${options}</select>`;
                
                const scopeOptions = `<option value="domain" selected>Domain</option><option value="subdomain">Subdomain</option><option value="subfolder">Subfolder</option><option value="url">URL</option>`;
                const limitedScopeOptions = `<option value="domain" selected>Domain</option><option value="subdomain">Subdomain</option><option value="url">URL</option>`;
                const localeOptions = `<option value="en-US" selected>en-US</option><option value="en-CA">en-CA</option><option value="en-GB">en-GB</option><option value="en-AU">en-AU</option>`;
                const keywordMetricOptions = `<option value="all" selected>All Metrics</option><option value="volume">Search Volume</option><option value="difficulty">Difficulty</option><option value="opportunity">Organic CTR</option><option value="priority">Priority</option>`;
                const deviceOptions = `<option value="desktop" selected>Desktop</option><option value="mobile_android">Mobile Android</option><option value="mobile_ios">Mobile iOS</option>`;
                const engineOptions = `<option value="google" selected>Google</option><option value="bing">Bing</option><option value="yahoo">Yahoo</option>`;
                const topPagesFilterOptions = `<option value="all" selected>All</option><option value="status_200">Status 200</option><option value="status_301">Status 301</option><option value="status_302">Status 302</option><option value="status_4xx">Status 4xx</option><option value="status_5xx">Status 5xx</option>`;
                const topPagesSortOptions = `<option value="page_authority" selected>Page Authority</option><option value="root_domains_to_page">Linking Root Domains</option><option value="external_pages_to_page">External Linking Pages</option>`;
                const listLinksFilterOptions = `<option value="external">external</option><option value="follow">follow</option><option value="nofollow">nofollow</option><option value="deleted">deleted</option><option value="not_deleted">not_deleted</option><option value="redirect">redirect</option><option value="not_redirect">not_redirect</option><option value="rel_canonical">rel_canonical</option><option value="not_rel_canonical">not_rel_canonical</option><option value="via_redirect">via_redirect</option><option value="not_via_redirect">not_via_redirect</option><option value="via_rel_canonical">via_rel_canonical</option><option value="not_via_rel_canonical">not_via_rel_canonical</option>`;
                const linkIntersectSortOptions = `<option value="matching_target_count" selected>Matching Target Count</option><option value="source_spam_score">Source Spam Score</option><option value="source_domain_authority">Source Domain Authority</option>`;
                const linkingDomainsSortOptions = `<option value="source_domain_authority" selected>Source Domain Authority</option><option value="source_link_propensity">Source Link Propensity</option><option value="source_spam_score">Source Spam Score</option>`;
                const linkingDomainsFilterOptions = `<option value="external">external</option><option value="follow">follow</option><option value="nofollow">nofollow</option><option value="deleted">deleted</option>`;
                const listLinksSortOptions = `<option value="source_page_authority" selected>Source Page Authority</option><option value="source_domain_authority">Source Domain Authority</option><option value="source_link_propensity">Source Link Propensity</option><option value="source_spam_score">Source Spam Score</option>`;
                const filterAnchorSortOptions = `<option value="source_page_authority" selected>Source Page Authority</option><option value="source_domain_authority">Source Domain Authority</option><option value="source_link_propensity">Source Link Propensity</option><option value="source_spam_score">Source Spam Score</option>`;
                const filterAnchorFilterOptions = `<option value="external">external</option><option value="follow">follow</option><option value="nofollow">nofollow</option><option value="deleted">deleted</option><option value="not_deleted">not_deleted</option><option value="redirect">redirect</option><option value="not_redirect">not_redirect</option><option value="rel_canonical">rel_canonical</option><option value="not_rel_canonical">not_rel_canonical</option><option value="via_redirect">via_redirect</option><option value="not_via_redirect">not_via_redirect</option><option value="via_rel_canonical">via_rel_canonical</option><option value="not_via_rel_canonical">not_via_rel_canonical</option>`;
                const filterDomainFilterOptions = `<option value="external">external</option><option value="follow">follow</option><option value="nofollow">nofollow</option><option value="deleted">deleted</option>`;

                const limitLabel = 'Number of Results (Default 25; Choose from 1 to 50)';
                const limitLabelLarge = 'Number of Results (Default 25; Choose from 1 to 500)';

                document.getElementById('siteMetricsInputs').innerHTML = createDescription('Get metrics like DA, PA, Spam Score, and link counts for URLs.') + createLabel('Scope') + createSelect('smScopeSelect', scopeOptions) + createLabel('Domains / URLs') + createTextarea('smUrlsInput', 'One per line or comma-separated (must include http/https)');
                document.getElementById('keywordMetricsInputs').innerHTML = createDescription('Get volume, difficulty, CTR, and priority for keywords.') + createLabel('Metric Type') + createSelect('kmMetricTypeSelect', keywordMetricOptions) + createLabel('Device') + createSelect('kmDeviceSelect', deviceOptions) + createLabel('Engine') + createSelect('kmEngineSelect', engineOptions) + createLabel('Locale') + createSelect('kmLocaleSelect', localeOptions) + createLabel('Keywords') + createTextarea('kmKeywordsInput', 'One per line or comma-separated');
                document.getElementById('brandAuthorityInputs').innerHTML = createDescription('Get the Brand Authority™ score for a given site.') + createLabel('Domains / URLs') + createTextarea('baUrlsInput', 'One per line or comma-separated.');
                document.getElementById('searchIntentInputs').innerHTML = createDescription('Retrieve search intent scores for any keyword.') + createLabel('Locale') + createSelect('siLocaleSelect', localeOptions) + createLabel('Keywords') + createTextarea('siKeywordsInput', 'One per line or comma-separated.');
                document.getElementById('rankingKeywordsInputs').innerHTML = createDescription('List keywords for which a site ranks.') + createLabel('Scope') + createSelect('rkScopeSelect', scopeOptions) + createLabel('Locale') + createSelect('rkLocaleSelect', localeOptions) + createNumberInput('rkLimit', 25, 1, 500, limitLabelLarge) + createLabel('Domains / URLs') + createTextarea('rkUrlsInput', 'One per line or comma-separated.');
                document.getElementById('relatedKeywordsInputs').innerHTML = createDescription('Get a list of related keyword suggestions.') + createLabel('Locale') + createSelect('rlLocaleSelect', localeOptions) + createLabel('Keywords') + createTextarea('rlKeywordsInput', 'One per line or comma-separated.');
                document.getElementById('keywordCountInputs').innerHTML = createDescription('Count keywords for which a site ranks in the top 50.') + createLabel('Scope') + createSelect('kcScopeSelect', limitedScopeOptions) + createLabel('Locale') + createSelect('kcLocaleSelect', localeOptions) + createLabel('Domains / URLs') + createTextarea('kcUrlsInput', 'One per line or comma-separated.');
                document.getElementById('anchorTextInputs').innerHTML = createDescription('Get data about anchor text used to link to a specified site.') + createLabel('Scope') + createSelect('atScopeSelect', scopeOptions) + createNumberInput('atLimit', 25, 1, 50, limitLabel) + createLabel('Domains / URLs') + createTextarea('atUrlsInput', 'One per line or comma-separated.');
                document.getElementById('recentlyGainedLinksInputs').innerHTML = createDescription('Get external root domains that added new links to a target during the past 60 days.') + createLabel('Scope') + createSelect('rglScopeSelect', scopeOptions) + createNumberInput('rglLimit', 25, 1, 50, limitLabel) + createLabel('Begin Date (Optional)') + createDateInput('rglBeginDate') + createLabel('End Date (Optional)') + createDateInput('rglEndDate') + createLabel('Domains / URLs') + createTextarea('rglUrlsInput', 'One per line or comma-separated.');
                document.getElementById('recentlyLostLinksInputs').innerHTML = createDescription('Get root domains that removed links to a target during the past 60 days.') + createLabel('Scope') + createSelect('rllScopeSelect', scopeOptions) + createNumberInput('rllLimit', 25, 1, 50, limitLabel) + createLabel('Begin Date (Optional)') + createDateInput('rllBeginDate') + createLabel('End Date (Optional)') + createDateInput('rllEndDate') + createLabel('Domains / URLs') + createTextarea('rllUrlsInput', 'One per line or comma-separated.');
                document.getElementById('linkingDomainsInputs').innerHTML = createDescription('Get a list of linking root domains to a target.') + createLabel('Scope') + createSelect('ldScopeSelect', scopeOptions) + createLabel('Sort') + createSelect('ldSortSelect', linkingDomainsSortOptions) + createLabel('Filters') + createMultiSelect('ldFilterSelect', linkingDomainsFilterOptions) + createDescription('If providing multiple filters, "external" must be one of them.') + createNumberInput('ldLimit', 25, 1, 50, limitLabel) + createLabel('Domains / URLs') + createTextarea('ldUrlsInput', 'One per line or comma-separated.');
                document.getElementById('finalRedirectInputs').innerHTML = createDescription('See the final redirect target of a page.') + createLabel('Scope') + createSelect('frScopeSelect', scopeOptions) + createLabel('Domains / URLs') + createTextarea('frUrlsInput', 'One per line or comma-separated.');
                document.getElementById('topPagesInputs').innerHTML = createDescription('Return a list of the top pages on a target domain.') + createLabel('Scope') + createSelect('tpScopeSelect', scopeOptions) + createLabel('Filter') + createSelect('tpFilterSelect', topPagesFilterOptions) + createLabel('Sort') + createSelect('tpSortSelect', topPagesSortOptions) + createNumberInput('tpLimit', 25, 1, 50, limitLabel) + createLabel('Domains / URLs') + createTextarea('tpUrlsInput', 'One per line or comma-separated.');
                document.getElementById('linkIntersectInputs').innerHTML = createDescription('Find sites that link to some domains but not others.') + createLabel('Scope') + createSelect('liScopeSelect', scopeOptions) + createLabel('Sort') + createSelect('liSortSelect', linkIntersectSortOptions) + createNumberInput('liMinMatch', 1, 1, 6, 'Minimum Matching Targets') + createNumberInput('liLimit', 25, 1, 50, limitLabel) + createLabel('Linking To') + createTextarea('liIsLinkingTo', 'One per line...') + createLabel('NOT Linking To (Optional)') + createTextarea('liNotLinkingTo', 'One per line...');
                document.getElementById('listLinksInputs').innerHTML = createDescription('Get a list of links to a target.') + createLabel('Scope') + createSelect('llScopeSelect', scopeOptions) + createLabel('Sort') + createSelect('llSortSelect', listLinksSortOptions) + createLabel('Filters') + createMultiSelect('llFilterSelect', listLinksFilterOptions) + createDescription('If providing multiple filters, "external" must be one of them.') + createNumberInput('llLimit', 25, 1, 50, limitLabel) + createLabel('Domains / URLs') + createTextarea('llUrlsInput', 'One per line or comma-separated.');
                document.getElementById('linkStatusInputs').innerHTML = createDescription('Get the status of a link from a source to a target.') + createLabel('Target Scope') + createSelect('lsTargetScopeSelect', scopeOptions) + createLabel('Target URL') + createTextarea('lsTargetUrl', 'Target URL') + createLabel('Source Scope') + createSelect('lsSourceScopeSelect', scopeOptions) + createLabel('Source URL') + createTextarea('lsSourceUrl', 'Source URL');
                document.getElementById('filterLinksByAnchorInputs').innerHTML = createDescription('Get a list of links to a target where the anchor text exactly matches a string.') + createLabel('Scope') + createSelect('flaScopeSelect', scopeOptions) + createLabel('Anchor Text') + createTextarea('flaAnchorText', 'Enter exact anchor text...') + createLabel('Sort') + createSelect('flaSortSelect', filterAnchorSortOptions) + createLabel('Filters') + createMultiSelect('flaFilterSelect', filterAnchorFilterOptions) + createDescription('If providing multiple filters, "external" must be one of them.') + createNumberInput('flaLimit', 25, 1, 50, limitLabel) + createLabel('Domains / URLs') + createTextarea('flaUrlsInput', 'One per line or comma-separated.');
                document.getElementById('filterLinksByDomainInputs').innerHTML = createDescription('Find links pointing to a target only if they originate from a particular root domain.') + createLabel('Target Scope') + createSelect('fldTargetScopeSelect', scopeOptions) + createLabel('Target URLs') + createTextarea('fldTargetUrls', 'One per line...') + createLabel('Source Domain Scope') + createSelect('fldSourceScopeSelect', scopeOptions) + createLabel('Source Domain URLs') + createTextarea('fldSourceUrls', 'One per line...') + createLabel('Filters') + createMultiSelect('fldFilterSelect', filterDomainFilterOptions) + createDescription('If providing multiple filters, "external" must be one of them.') + createNumberInput('fldLimit', 25, 1, 50, limitLabel);
                document.getElementById('competitiveAnalysisInputs').innerHTML = createDescription('Compare your domain against up to 3 competitors. Analyzes Brand Authority, Domain Authority, Spam Score, Link Metrics HD Ranking Keywords for each domain.') + createLabel('Your Domain') + createTextarea('caYourDomain', 'Enter your domain (e.g., https://example.com)') + createLabel('Competitor Domains (up to 3)') + createTextarea('caCompetitors', 'Enter competitor domains, one per line (e.g., https://competitor1.com)') + createLabel('Locale') + createSelect('caLocaleSelect', localeOptions) + createNumberInput('caLimit', 25, 1, 500, 'Number of Ranking Keywords to Display (Default 25; Choose from 1 to 500)');
            };
            
            const readmeContent = `
                <h2>Moz API Assistant - Comprehensive Guide</h2>
                
                <h3>Overview</h3>
                <p>This tool allows you to connect directly to the Moz API (v3) using your personal API key to fetch valuable SEO data. The interface provides an intuitive way to access all major Moz API endpoints with detailed parameter configuration and results visualization.</p>
                
                <h2>🔐 API Key Security & Setup</h2>
                <div class="p-4 rounded-lg mb-4" style="background-color: var(--bg-input); border: 1px solid var(--border-secondary);">
                    <h4><strong>Security Features:</strong></h4>
                    <ul class="mt-2">
                        <li><strong>Local Storage Only:</strong> Your API key is stored securely in your browser's local storage and never transmitted to external servers</li>
                        <li><strong>No Server Storage:</strong> This tool runs entirely in your browser - no data is sent to third-party servers</li>
                        <li><strong>Encrypted Transmission:</strong> All API calls are made directly to Moz's secure HTTPS endpoints</li>
                        <li><strong>Auto-Save:</strong> Your API key is automatically saved and restored between sessions</li>
                    </ul>
                </div>
                
                <h4>Setup Steps:</h4>
                <ol>
                    <li><strong>Get API Key:</strong> You need a valid Moz API Key. You can get one or manage your existing key from the <a href="https://moz.com/products/api/keys" target="_blank" rel="noopener">Moz API Dashboard</a>.</li>
                    <li><strong>Add Key to Tool:</strong> Use the API Key input at the top of the tool. Your key is stored securely in your browser's local storage.</li>
                    <li><strong>Verify Connection:</strong> Run a simple API call to verify your key is working correctly.</li>
                </ol>
                
                <h2>📊 Recent API Calls & History</h2>
                <div class="p-4 rounded-lg mb-4" style="background-color: var(--bg-input); border: 1px solid var(--border-secondary);">
                    <h4><strong>API History Features:</strong></h4>
                    <ul class="mt-2">
                        <li><strong>Automatic Logging:</strong> Every successful API call is automatically saved to your local history</li>
                        <li><strong>Search & Filter:</strong> Use the search bar to find specific calls by method, parameters, or date</li>
                        <li><strong>Replay Functionality:</strong> Click any history entry to instantly replay that exact API call with the same parameters</li>
                        <li><strong>Export History:</strong> Download your complete API call history as a CSV file for record-keeping</li>
                        <li><strong>Individual Management:</strong> Delete specific entries or clear your entire history as needed</li>
                    </ul>
                </div>
                
                <p><strong>Accessing Your History:</strong> Click the "Recent API Calls" button in the top navigation to view your complete API call history. Each entry shows the method used, parameters, timestamp, and allows you to replay or delete the call.</p>
                
                <h2>🚀 Available API Methods</h2>
                <p>Select a method from the dropdown to get started. Methods are organized by category:</p>
                
                <hr class="my-4" style="border-color: var(--border-primary);">
                
                <h3>📍 Site Metrics</h3>
                <div class="readme-method mb-4">
                    <h4><strong><u>Fetch Site Metrics</u></strong></h4>
                    <p><strong>Description:</strong> Get comprehensive metrics like Domain Authority (DA), Page Authority (PA), Spam Score, and link counts for URLs.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose between page-level or domain-level analysis</li>
                        <li><strong>Domains/URLs:</strong> Enter one URL per line or comma-separated (must include http/https)</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Fetch Brand Authority</u></strong></h4>
                    <p><strong>Description:</strong> Get the Brand Authority™ score for a given site, measuring brand strength and recognition.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Domains/URLs:</strong> Enter one URL per line or comma-separated</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>List Top Pages</u></strong></h4>
                    <p><strong>Description:</strong> Return a list of the top-performing pages on a target domain based on various ranking factors.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Filter:</strong> Filter results by specific criteria</li>
                        <li><strong>Sort:</strong> Choose how to sort the results</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <hr class="my-4" style="border-color: var(--border-primary);">
                
                <h3>🔍 Keyword Research</h3>
                <div class="readme-method mb-4">
                    <h4><strong><u>Fetch Keyword Metrics</u></strong></h4>
                    <p><strong>Description:</strong> Get comprehensive keyword data including search volume, difficulty, CTR estimates, and priority scores.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Metric Type:</strong> Choose the type of keyword metrics to retrieve</li>
                        <li><strong>Device:</strong> Select device type (desktop, mobile, tablet)</li>
                        <li><strong>Engine:</strong> Choose search engine (Google, Bing, etc.)</li>
                        <li><strong>Locale:</strong> Select geographic region/language</li>
                        <li><strong>Keywords:</strong> Enter keywords one per line or comma-separated</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Fetch Search Intent</u></strong></h4>
                    <p><strong>Description:</strong> Retrieve search intent scores for any keyword, helping understand user motivation behind searches.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Locale:</strong> Select geographic region/language</li>
                        <li><strong>Keywords:</strong> Enter keywords one per line or comma-separated</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>List Ranking Keywords</u></strong></h4>
                    <p><strong>Description:</strong> List keywords for which a specific site currently ranks in search results.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Locale:</strong> Select geographic region/language</li>
                        <li><strong>Number of Results:</strong> Limit results (1-500, default 25)</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>List Related Keywords</u></strong></h4>
                    <p><strong>Description:</strong> Get a list of related keyword suggestions based on seed keywords.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Locale:</strong> Select geographic region/language</li>
                        <li><strong>Keywords:</strong> Enter seed keywords one per line or comma-separated</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Count Ranking Keywords</u></strong></h4>
                    <p><strong>Description:</strong> Count the total number of keywords for which a site ranks in the top 50 search results.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (limited options available)</li>
                        <li><strong>Locale:</strong> Select geographic region/language</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Competitive Analysis</u></strong></h4>
                    <p><strong>Description:</strong> Comprehensive competitive analysis comparing your domain against up to 3 competitors. Automatically fetches and displays Brand Authority, Domain Authority, Spam Score, Link Metrics, and Top Ranking Keywords side-by-side.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Your Domain:</strong> Enter your domain URL (must include http/https)</li>
                        <li><strong>Competitor Domains:</strong> Enter up to 3 competitor domains, one per line (must include http/https)</li>
                        <li><strong>Locale:</strong> Select geographic region/language for ranking keywords analysis</li>
                        <li><strong>Number of Ranking Keywords:</strong> Limit the number of keywords to display (1-500, default 25)</li>
                    </ul>
                    <p><strong>Features:</strong></p>
                    <ul>
                        <li>Side-by-side comparison dashboard showing all metrics at a glance</li>
                        <li>Interactive domain selector to view detailed ranking keywords for each domain</li>
                        <li>Comprehensive metrics including Brand Authority Score, DA, Total Links, Linking Domains, and Spam Score</li>
                        <li>Toggles between dashboard and JSON view</li>
                    </ul>
                </div>
                
                <hr class="my-4" style="border-color: var(--border-primary);">
                
                <h3>🔗 Link Building</h3>
                <div class="readme-method mb-4">
                    <h4><strong><u>Get Anchor Texts Lists</u></strong></h4>
                    <p><strong>Description:</strong> Get comprehensive data about anchor text used to link to a specified site.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>List Linking Domains</u></strong></h4>
                    <p><strong>Description:</strong> Get a comprehensive list of linking root domains to a target site.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Sort:</strong> Choose how to sort the results</li>
                        <li><strong>Filters:</strong> Apply filters (if multiple filters, "external" must be one)</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>List Recently Gained Links</u></strong></h4>
                    <p><strong>Description:</strong> Get external root domains that added new links to a target during a specified time period.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Begin Date (Optional):</strong> Start date for the analysis period</li>
                        <li><strong>End Date (Optional):</strong> End date for the analysis period</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>List Recently Lost Links</u></strong></h4>
                    <p><strong>Description:</strong> Get root domains that removed links to a target during a specified time period.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Begin Date (Optional):</strong> Start date for the analysis period</li>
                        <li><strong>End Date (Optional):</strong> End date for the analysis period</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Fetch Link Intersects</u></strong></h4>
                    <p><strong>Description:</strong> Find sites that link to some domains but not others, useful for competitive analysis.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Sort:</strong> Choose how to sort the results</li>
                        <li><strong>Minimum Matching Targets:</strong> Minimum number of targets that must match (1-6)</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Linking To:</strong> Domains that should be linked to</li>
                        <li><strong>NOT Linking To (Optional):</strong> Domains that should NOT be linked to</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>List Links</u></strong></h4>
                    <p><strong>Description:</strong> Get a comprehensive list of all links pointing to a target site.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Sort:</strong> Choose how to sort the results</li>
                        <li><strong>Filters:</strong> Apply filters (if multiple filters, "external" must be one)</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Filter Links by Anchor Text</u></strong></h4>
                    <p><strong>Description:</strong> Get a list of links to a target where the anchor text exactly matches a specified string.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Anchor Text:</strong> Enter exact anchor text to search for</li>
                        <li><strong>Sort:</strong> Choose how to sort the results</li>
                        <li><strong>Filters:</strong> Apply filters (if multiple filters, "external" must be one)</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Filter Links by Domain</u></strong></h4>
                    <p><strong>Description:</strong> Find links pointing to a target only if they originate from a particular root domain.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Target Scope:</strong> Choose target analysis scope</li>
                        <li><strong>Target URLs:</strong> Enter target URLs</li>
                        <li><strong>Source Scope:</strong> Choose source analysis scope</li>
                        <li><strong>Source URLs:</strong> Enter source domain URLs</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Filters:</strong> Apply additional filters</li>
                    </ul>
                </div>
                
                <hr class="my-4" style="border-color: var(--border-primary);">
                
                <h3>⚙️ Technical SEO</h3>
                <div class="readme-method mb-4">
                    <h4><strong><u>Get Final Redirect Target</u></strong></h4>
                    <p><strong>Description:</strong> See the final redirect target of a page, following the complete redirect chain.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Domains/URLs:</strong> Enter URLs to analyze for redirects</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Get Link Status</u></strong></h4>
                    <p><strong>Description:</strong> Get the current status of a specific link from a source to a target URL.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Target Scope:</strong> Choose target analysis scope</li>
                        <li><strong>Target URL:</strong> Enter the target URL</li>
                        <li><strong>Source Scope:</strong> Choose source analysis scope</li>
                        <li><strong>Source URL:</strong> Enter the source URL</li>
                    </ul>
                </div>
                
                <hr class="my-4" style="border-color: var(--border-primary);">
                
                <h2>📋 General Usage Notes</h2>
                <div class="p-4 rounded-lg" style="background-color: var(--bg-input); border: 1px solid var(--border-secondary);">
                    <h4><strong>Important Information:</strong></h4>
                    <ul class="mt-2">
                        <li><strong>API Usage:</strong> Each API call consumes rows from your Moz API subscription quota. Monitor your usage in the Moz API Dashboard.</li>
                        <li><strong>Rate Limits:</strong> Be mindful of API rate limits to avoid temporary blocks on your requests.</li>
                        <li><strong>Data Freshness:</strong> Moz data is updated regularly, but some metrics may have different refresh schedules.</li>
                        <li><strong>Error Handling:</strong> If an API call fails, detailed error messages will be displayed with the JSON response containing specific error details.</li>
                        <li><strong>Results Export:</strong> All results can be exported as CSV files for further analysis in spreadsheet applications.</li>
                        <li><strong>URL Format:</strong> Always include the full URL with http:// or https:// when entering URLs for analysis.</li>
                    </ul>
                </div>
                
                <h2>🛠️ Tips for Best Results</h2>
                <ul>
                    <li><strong>Batch Processing:</strong> Use comma-separated or line-separated lists to analyze multiple URLs or keywords in a single call</li>
                    <li><strong>Scope Selection:</strong> Choose the appropriate scope (page vs domain) based on your analysis needs</li>
                    <li><strong>Filter Usage:</strong> Use filters to narrow down results and focus on the most relevant data</li>
                    <li><strong>History Management:</strong> Regularly review your API call history to track usage patterns and identify frequently used queries</li>
                    <li><strong>Export Regularly:</strong> Export important results as CSV files for backup and further analysis</li>
                </ul>
            `;
            
            const setupEventListeners = () => {
                allDOMElements.readmeBtn.addEventListener('click', () => allDOMElements.readmeModal.classList.remove('hidden'));
                allDOMElements.closeReadmeBtn.addEventListener('click', () => allDOMElements.readmeModal.classList.add('hidden'));
                allDOMElements.readmeModal.addEventListener('click', (e) => {
                    if (e.target === allDOMElements.readmeModal) allDOMElements.readmeModal.classList.add('hidden');
                });
                allDOMElements.themeBtns.forEach(btn => {
                    btn.addEventListener('click', () => applyTheme(btn.dataset.theme));
                });
                allDOMElements.saveApiKeyBtn.addEventListener('click', () => {
                    const key = allDOMElements.apiKeyInput.value.trim();
                    if (key) {
                        try {
                            localStorage.setItem('mozApiKey', key);
                            loadApiKey();
                        } catch (e) {
                            console.warn('Could not save API key to localStorage:', e);
                            displayError('Could not save API key. Please try again.');
                        }
                    }
                });
                allDOMElements.editApiKeyBtn.addEventListener('click', () => {
                    allDOMElements.apiKeyDisplay.classList.add('hidden');
                    allDOMElements.apiKeyInputArea.classList.remove('hidden');
                    allDOMElements.apiKeyInput.focus();
                });
                allDOMElements.methodSelector.addEventListener('change', () => {
                    document.querySelectorAll('.input-section').forEach(section => section.style.display = 'none');
                    const selectedMethod = allDOMElements.methodSelector.value;
                    if (selectedMethod) {
                        const sectionToShow = document.getElementById(selectedMethod + 'Inputs');
                        if (sectionToShow) sectionToShow.style.display = 'block';
                        allDOMElements.submitBtn.disabled = false;
                    } else {
                        allDOMElements.submitBtn.disabled = true;
                    }
                });
                allDOMElements.form.addEventListener('submit', handleFormSubmit);
                allDOMElements.copyJsonBtn.addEventListener('click', handleCopyJson);
                allDOMElements.exportBtn.addEventListener('click', handleExportCsv);
                allDOMElements.viewDataBtn.addEventListener('click', toggleDataView);
                allDOMElements.historyBtn.addEventListener('click', () => {
                    allDOMElements.historyModal.classList.remove('hidden');
                    renderHistoryList();
                });
                allDOMElements.clearDataBtn.addEventListener('click', clearResultsData);
                allDOMElements.exportPdfBtn.addEventListener('click', handleExportPdf);
                allDOMElements.filterBtn.addEventListener('click', () => allDOMElements.filterModal.classList.remove('hidden'));
                allDOMElements.closeFilterBtn.addEventListener('click', () => allDOMElements.filterModal.classList.add('hidden'));
                allDOMElements.cancelFilterBtn.addEventListener('click', () => allDOMElements.filterModal.classList.add('hidden'));
                allDOMElements.filterModal.addEventListener('click', (e) => {
                    if (e.target === allDOMElements.filterModal) allDOMElements.filterModal.classList.add('hidden');
                });
                allDOMElements.applyFilterBtn.addEventListener('click', applyTableFilters);
                
                // History modal event listeners
                allDOMElements.closeHistoryBtn.addEventListener('click', () => allDOMElements.historyModal.classList.add('hidden'));
                allDOMElements.historyModal.addEventListener('click', (e) => {
                    if (e.target === allDOMElements.historyModal) allDOMElements.historyModal.classList.add('hidden');
                });
                allDOMElements.historySearch.addEventListener('input', debounce(filterHistory, 300));
                allDOMElements.exportHistoryBtn.addEventListener('click', exportHistory);
                allDOMElements.clearHistoryBtn.addEventListener('click', clearAllHistory);
                
                // Event delegation for history list buttons
                allDOMElements.historyList.addEventListener('click', (e) => {
                    if (e.target.dataset.replay) {
                        replaySearch(e.target.dataset.replay);
                    } else if (e.target.dataset.delete) {
                        deleteHistoryEntry(e.target.dataset.delete);
                    }
                });
                
                // Add escape key functionality for modals
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        if (!allDOMElements.readmeModal.classList.contains('hidden')) {
                            allDOMElements.readmeModal.classList.add('hidden');
                        }
                        if (!allDOMElements.filterModal.classList.contains('hidden')) {
                            allDOMElements.filterModal.classList.add('hidden');
                        }
                        if (!allDOMElements.historyModal.classList.contains('hidden')) {
                            allDOMElements.historyModal.classList.add('hidden');
                        }
                    }
                });
            };

            const applyTheme = (theme) => {
                raf(() => {
                    const root = document.documentElement;
                    const themes = ["light", "dark", "retro", "high-contrast"];
                    
                    // Remove all theme classes
                    themes.forEach(t => root.classList.remove(t));
                    
                    // Add new theme
                    root.classList.add(theme);
                    
                    // Save to localStorage
                    try {
                        localStorage.setItem('theme', theme);
                    } catch (e) {
                        console.warn('Could not save theme to localStorage:', e);
                    }
                    
                    // Update theme button states
                    allDOMElements.themeBtns.forEach(btn => {
                        btn.classList.toggle('font-bold', btn.dataset.theme === theme);
                    });
                    
                    // Reset logo filter
                    if (allDOMElements.mozLogo) {
                        allDOMElements.mozLogo.style.filter = 'none';
                    }
                });
            };

            const fetchQuota = async (apiKey) => {
                if (!apiKey) return;
                try {
                    // Add timeout to prevent hanging requests
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                    
                    const response = await fetch('https://mozapi-proxy-server.vercel.app/api/getMozData', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ apiKey, method: 'getQuota' }),
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    if (!data.quota?.quota) {
                        throw new Error('Invalid quota data received');
                    }
                    
                    const { used, allotted } = data.quota.quota;
                    allDOMElements.quotaText.textContent = `API Usage: ${used.toLocaleString()} / ${allotted.toLocaleString()} Rows Used`;
                    allDOMElements.quotaText.style.color = used >= allotted ? 'var(--text-error)' : 'var(--text-secondary)';
                    allDOMElements.quotaDisplay.classList.remove('hidden');
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.warn("Quota fetch error:", error);
                    }
                    allDOMElements.quotaText.textContent = 'Could not retrieve API usage.';
                    allDOMElements.quotaDisplay.classList.remove('hidden');
                }
            };
            
            const loadApiKey = () => {
                try {
                    const savedKey = localStorage.getItem('mozApiKey');
                    if (savedKey) {
                        allDOMElements.apiKeyText.textContent = `${savedKey.substring(0, 6)}...${savedKey.substring(savedKey.length - 4)}`;
                        allDOMElements.apiKeyInput.value = savedKey;
                        allDOMElements.apiKeyDisplay.classList.remove('hidden');
                        allDOMElements.apiKeyDisplay.classList.add('flex');
                        allDOMElements.apiKeyInputArea.classList.add('hidden');
                        fetchQuota(savedKey);
                    } else {
                        allDOMElements.apiKeyDisplay.classList.add('hidden');
                        allDOMElements.apiKeyInputArea.classList.remove('hidden');
                        allDOMElements.quotaDisplay.classList.add('hidden');
                    }
                } catch (e) {
                    console.warn('Could not load API key from localStorage:', e);
                    allDOMElements.apiKeyDisplay.classList.add('hidden');
                    allDOMElements.apiKeyInputArea.classList.remove('hidden');
                    allDOMElements.quotaDisplay.classList.add('hidden');
                }
            };
            
            async function handleFormSubmit(e) {
                e.preventDefault();

                // Prevent double submissions
                if (inFlightRequest) {
                    inFlightRequest.abort();
                }
                inFlightRequest = new AbortController();


                allDOMElements.errorMessage.classList.add('hidden');
                allDOMElements.resultsContainer.classList.add('hidden');
                allDOMElements.submitBtn.disabled = true;
                allDOMElements.submitBtn.setAttribute('aria-busy', 'true');
                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Processing...</span>';
                const apiKey = allDOMElements.apiKeyInput.value.trim();
                const selectedMethod = allDOMElements.methodSelector.value;
                if (!apiKey || !selectedMethod) {
                    displayError('Please provide an API Key and select a method.');
                    resetSubmitButton(); return;
                }
                let payload;
                try {
                    payload = buildPayload(apiKey, selectedMethod);
                } catch (error) {
                    displayError(error.message);
                    resetSubmitButton(); return;
                }
                const PROXY_URL = document.body.dataset.proxy;
                
                // Special handling for competitive analysis
                if (selectedMethod === 'competitiveAnalysis') {
                    try {
                        const competitiveData = await runCompetitiveAnalysis(apiKey, payload.params, PROXY_URL, inFlightRequest);
                        currentResultsData = competitiveData;
                        currentOriginalParams = payload.params;
                        currentMethod = selectedMethod;
                        showCompetitiveDashboard(competitiveData);
                        fetchQuota(apiKey);
                        autoSaveToHistory();
                    } catch (error) {
                        if (error.name !== 'AbortError') {
                            displayError(error.message);
                        }
                    } finally {
                        resetSubmitButton();
                        inFlightRequest = null;
                    }
                    return;
                }
                
                // For non-competitive analysis methods, ensure dashboard is cleared
                const existingDashboard = document.getElementById('competitive-dashboard');
                if (existingDashboard) {
                    existingDashboard.remove();
                }
                
                try {
                    const response = await fetch(PROXY_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        signal: inFlightRequest.signal
                    });
                    const data = await response.json();
                    if (!response.ok) throw new Error(data.error || `Request failed with status ${response.status}`);
                    currentResultsData = data;
                    currentOriginalParams = payload.params;
                    currentMethod = selectedMethod;
                    showRawJsonResults(data);
                    fetchQuota(apiKey);
                    
                    // Auto-save successful search to history
                    autoSaveToHistory();
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        displayError(error.message);
                    }
                } finally {
                    resetSubmitButton();
                    inFlightRequest = null;
                }
            }

            async function runCompetitiveAnalysis(apiKey, params, proxyUrl, opensignal) {
                const allDomains = [params.yourDomain, ...params.competitors];
                const results = {};
                
                // Update progress
                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Fetching data for ' + allDomains.length + ' domains...</span>';
                
                // For each domain, make 3 API calls: siteMetrics, brandAuthority, rankingKeywords
                for (let i = 0; i < allDomains.length; i++) {
                    const domain = allDomains[i];
                    const domainLabel = i === 0 ? 'Your Domain' : `Competitor ${i}`;
                    
                    allDOMElements.submitBtn.innerHTML = `<div class="spinner"></div><span class="ml-2">Processing ${domainLabel} (${i + 1}/${allDomains.length})...</span>`;
                    
                    results[domain] = {
                        domain,
                        label: domainLabel,
                        siteMetrics: null,
                        brandAuthority: null,
                        rankingKeywords: null,
                        keywordCount: null,
                        errors: []
                    };
                    
                    // Fetch Site Metrics
                    try {
                        const smResponse = await fetch(proxyUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                apiKey,
                                method: 'siteMetrics',
                                params: { scope: 'domain', targets: [domain] }
                            }),
                            signal: opensignal.signal
                        });
                        const smData = await smResponse.json();
                        if (smResponse.ok && Array.isArray(smData) && smData[0]?.status === 'success') {
                            results[domain].siteMetrics = smData[0];
                        } else {
                            results[domain].errors.push('Site Metrics: ' + (smData[0]?.reason || 'Failed'));
                        }
                    } catch (e) {
                        results[domain].errors.push('Site Metrics: ' + e.message);
                    }
                    
                    // Fetch Brand Authority
                    try {
                        const baResponse = await fetch(proxyUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                apiKey,
                                method: 'brandAuthority',
                                params: { targets: [domain] }
                            }),
                            signal: opensignal.signal
                        });
                        const baData = await baResponse.json();
                        if (baResponse.ok && Array.isArray(baData) && baData[0]?.status === 'success') {
                            results[domain].brandAuthority = baData[0];
                        } else {
                            results[domain].errors.push('Brand Authority: ' + (baData[0]?.reason || 'Failed'));
                        }
                    } catch (e) {
                        results[domain].errors.push('Brand Authority: ' + e.message);
                    }
                    
                    // Fetch Ranking Keywords
                    try {
                        const rkResponse = await fetch(proxyUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                apiKey,
                                method: 'rankingKeywords',
                                params: { 
                                    scope: 'domain', 
                                    locale: params.locale || 'en-US',
                                    targets: [domain],
                                    limit: params.limit || 25
                                }
                            }),
                            signal: opensignal.signal
                        });
                        const rkData = await rkResponse.json();
                        if (rkResponse.ok && Array.isArray(rkData) && rkData[0]?.status === 'success') {
                            results[domain].rankingKeywords = rkData[0];
                        } else {
                            results[domain].errors.push('Ranking Keywords: ' + (rkData[0]?.reason || 'Failed'));
                        }
                    } catch (e) {
                        results[domain].errors.push('Ranking Keywords: ' + e.message);
                    }
                    
                    // Fetch Keyword Count
                    try {
                        const kcResponse = await fetch(proxyUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                apiKey,
                                method: 'keywordCount',
                                params: { 
                                    scope: 'domain', 
                                    locale: params.locale || 'en-US',
                                    targets: [domain]
                                }
                            }),
                            signal: opensignal.signal
                        });
                        const kcData = await kcResponse.json();
                        if (kcResponse.ok && Array.isArray(kcData) && kcData[0]?.status === 'success') {
                            results[domain].keywordCount = kcData[0];
                        } else {
                            results[domain].errors.push('Keyword Count: ' + (kcData[0]?.reason || 'Failed'));
                        }
                    } catch (e) {
                        results[domain].errors.push('Keyword Count: ' + e.message);
                    }
                }
                
                return results;
            }

            function showCompetitiveDashboard(data) {
                // Hide regular view elements
                allDOMElements.tableWrapper.classList.add('hidden');
                allDOMElements.filterBtn.classList.add('hidden');
                
                // Show results container and raw wrapper (we'll put dashboard in rawWrapper)
                allDOMElements.resultsContainer.classList.remove('hidden');
                
                // Helper function to format numbers with K/M abbreviations
                const formatNumber = (num) => {
                    if (typeof num !== 'number' || num === 'N/A') return num;
                    if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
                    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                    return num.toLocaleString();
                };
                
                // Helper function to create tooltip
                const createTooltip = (text, tooltipText) => {
                    return `<span class="tooltip-container">${text}<span class="tooltip-icon">?</span><span class="tooltip-text">${tooltipText}</span></span>`;
                };
                
                // Create dashboard HTML
                let dashboardHTML = '<div id="competitive-dashboard" class="space-y-6">';
                dashboardHTML += '<h3 class="text-xl font-bold text-[var(--text-heading)] mb-4">Competitive Analysis Dashboard</h3>';
                
                // Create domain selector
                dashboardHTML += '<div class="mb-6"><label for="domain-selector" class="block text-sm font-medium text-[var(--text-secondary)] mb-2">View Details For:</label>';
                dashboardHTML += '<select id="domain-selector" class="w-full bg-[var(--bg-input)] border border-[var(--border-secondary)] rounded-md px-3 py-2 text-[var(--text-primary)]">';
                Object.values(data).forEach((domainData, idx) => {
                    dashboardHTML += `<option value="${idx}">${domainData.label}: ${domainData.domain}</option>`;
                });
                dashboardHTML += '</select></div>';
                
                // Create metrics grid - ensure all 4 boxes in one row on large screens
                dashboardHTML += '<div class="metrics-grid-container gap-4 mb-6">';
                Object.values(data).forEach((domainData, idx) => {
                    const sm = domainData.siteMetrics?.data?.site_metrics || {};
                    const ba = domainData.brandAuthority?.data?.site_metrics?.brand_authority_score ?? 'N/A';
                    const da = sm.domain_authority ?? 'N/A';
                    const links = sm.external_pages_to_root_domain ?? 'N/A';
                    const linkingDomains = sm.root_domains_to_root_domain ?? 'N/A';
                    const spam = sm.spam_score ?? 'N/A';
                    
                    // Extract domain name from URL
                    const domainName = domainData.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0];
                    
                    // Enhanced styling for "Your Domain" and competitor cards with gradients
                    const isYourDomain = idx === 0;
                    let cardClasses = '';
                    let gradientBar = '';
                    
                    if (isYourDomain) {
                        cardClasses = 'bg-gradient-to-br from-[var(--text-accent)]/10 to-[var(--bg-container)] border-2 border-[var(--text-accent)] rounded-lg p-4 shadow-lg relative';
                        gradientBar = '<div class="absolute top-0 left-0 right-0 h-1 bg-gradient-to-r from-[var(--text-accent)] to-transparent rounded-t-lg"></div>';
                    } else {
                        // Competitor outlines: neon pink (idx 1), neon green (idx 2), neon purple (idx 3)
                        // Only outline/border, no background fill - matching "Your Domain" style
                        const competitorBorders = [
                            'border-2 border-fuchsia-400',
                            'border-2 border-emerald-400',
                            'border-2 border-violet-400'
                        ];
                        const gradientIndex = idx - 1;
                        cardClasses = 'bg-[var(--bg-container)] ' + competitorBorders[gradientIndex] + ' rounded-lg p-4 shadow-md relative';
                        const gradientColors = ['from-fuchsia-400 via-fuchsia-500 to-transparent', 'from-emerald-400 via-emerald-500 to-transparent', 'from-violet-400 via-violet-500 to-transparent'];
                        gradientBar = `<div class="absolute top-0 left-0 right-0 h-1 bg-gradient-to-r ${gradientColors[gradientIndex]} rounded-t-lg"></div>`;
                    }
                    
                    // Ensure grid items are properly constrained
                    dashboardHTML += `<div class="${cardClasses}">`;
                    dashboardHTML += gradientBar;
                    dashboardHTML += `<h4 class="font-bold text-[var(--text-primary)] mb-1 ${isYourDomain ? 'text-lg' : ''}">${isYourDomain ? 'Your Domain' : domainName}</h4>`;
                    dashboardHTML += `<p class="text-xs text-[var(--text-secondary)] mb-3">${domainData.domain}</p>`;
                    
                    // Authority Metrics Group
                    dashboardHTML += `<div class="mb-3 pb-3 border-b border-[var(--border-primary)]">`;
                    dashboardHTML += `<div class="text-xs font-semibold text-[var(--text-secondary)] mb-2 uppercase tracking-wide">Authority Metrics</div>`;
                    dashboardHTML += `<div class="space-y-2 text-sm">`;
                    dashboardHTML += `<div>${createTooltip('Brand Authority', 'Moz metric measuring brand strength based on search visibility and mentions')}: <span class="font-semibold text-[var(--text-primary)]">${ba}</span></div>`;
                    dashboardHTML += `<div>Domain Authority: <span class="font-semibold text-[var(--text-primary)]">${da}</span></div>`;
                    dashboardHTML += `</div></div>`;
                    
                    // Link Metrics Group
                    dashboardHTML += `<div class="mb-3 pb-3 border-b border-[var(--border-primary)]">`;
                    dashboardHTML += `<div class="text-xs font-semibold text-[var(--text-secondary)] mb-2 uppercase tracking-wide">Link Metrics</div>`;
                    dashboardHTML += `<div class="space-y-2 text-sm">`;
                    dashboardHTML += `<div>Total Links: <span class="font-semibold text-[var(--text-primary)]">${typeof links === 'number' ? formatNumber(links) : links}</span></div>`;
                    dashboardHTML += `<div>Linking Domains: <span class="font-semibold text-[var(--text-primary)]">${typeof linkingDomains === 'number' ? formatNumber(linkingDomains) : linkingDomains}</span></div>`;
                    dashboardHTML += `<div>${createTooltip('Spam Score', 'Likelihood of penalization based on backlink profile quality')}: <span class="font-semibold text-[var(--text-primary)]">${spam}</span></div>`;
                    dashboardHTML += `</div></div>`;
                    
                    // Add keyword count breakdown
                    const kc = domainData.keywordCount?.data?.ranking_keyword_count;
                    if (kc) {
                        const positions = kc.position || {};
                        const rank1_3 = (positions.rank_1 || 0) + (positions.rank_2 || 0) + (positions.rank_3 || 0);
                        const rank4_10 = [4,5,6,7,8,9,10].reduce((sum, r) => sum + (positions[`rank_${r}`] || 0), 0);
                        const rank11_20 = [11,12,13,14,15,16,17,18,19,20].reduce((sum, r) => sum + (positions[`rank_${r}`] || 0), 0);
                        const rank21_50 = [21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50].reduce((sum, r) => sum + (positions[`rank_${r}`] || 0), 0);
                        
                        dashboardHTML += `<div class="mt-3">`;
                        dashboardHTML += `<div class="text-xs font-semibold text-[var(--text-secondary)] mb-2 uppercase tracking-wide">Keyword Metrics</div>`;
                        dashboardHTML += `<div class="space-y-1 text-xs">`;
                        dashboardHTML += `<div><span class="text-[var(--text-secondary)]">Ranks 1-3:</span> <span class="font-semibold text-[var(--text-primary)]">${formatNumber(rank1_3)}</span></div>`;
                        dashboardHTML += `<div><span class="text-[var(--text-secondary)]">Ranks 4-10:</span> <span class="font-semibold text-[var(--text-primary)]">${formatNumber(rank4_10)}</span></div>`;
                        dashboardHTML += `<div><span class="text-[var(--text-secondary)]">Ranks 11-20:</span> <span class="font-semibold text-[var(--text-primary)]">${formatNumber(rank11_20)}</span></div>`;
                        dashboardHTML += `<div><span class="text-[var(--text-secondary)]">Ranks 21-50:</span> <span class="font-semibold text-[var(--text-primary)]">${formatNumber(rank21_50)}</span></div>`;
                        dashboardHTML += `<div><span class="text-[var(--text-secondary)]">Total:</span> <span class="font-semibold text-[var(--text-primary)]">${formatNumber(kc.total || 0)}</span></div>`;
                        dashboardHTML += `</div></div>`;
                    }
                    
                    dashboardHTML += `</div>`;
                    
                    if (domainData.errors && domainData.errors.length > 0) {
                        dashboardHTML += `<div class="mt-2 text-xs text-[var(--text-error)]">Errors: ${domainData.errors.join(', ')}</div>`;
                    }
                    dashboardHTML += `</div>`;
                });
                dashboardHTML += '</div>';
                
                // Add overlapping keywords section
                dashboardHTML += '<div id="overlapping-keywords-section" class="mt-6">';
                dashboardHTML += '<div class="flex items-center justify-between mb-4">';
                dashboardHTML += '<h4 class="font-bold text-lg text-[var(--text-primary)]">Overlapping Keywords</h4>';
                dashboardHTML += '<button id="toggle-overlapping" class="text-sm text-[var(--text-accent)] hover:text-[var(--text-accent-hover)] font-semibold">Collapse</button>';
                dashboardHTML += '</div>';
                dashboardHTML += '<div id="overlapping-keywords-content">';
                
                // Extract all keywords for each domain
                const domainKeywords = {};
                Object.values(data).forEach((domainData, idx) => {
                    const keywords = domainData.rankingKeywords?.data?.ranking_keywords || [];
                    const domainName = domainData.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0];
                    domainKeywords[domainName] = keywords.map(kw => kw.keyword?.toLowerCase()).filter(Boolean);
                });
                
                // Find overlapping keywords
                const domainNames = Object.keys(domainKeywords);
                if (domainNames.length > 1) {
                    // Create a map of keyword to domains that rank for it
                    const keywordToDomains = {};
                    domainNames.forEach(domain => {
                        domainKeywords[domain].forEach(keyword => {
                            if (!keywordToDomains[keyword]) {
                                keywordToDomains[keyword] = [];
                            }
                            if (!keywordToDomains[keyword].includes(domain)) {
                                keywordToDomains[keyword].push(domain);
                            }
                        });
                    });
                    
                    // Find keywords that appear in 2+ domains
                    const overlappingKeywords = Object.entries(keywordToDomains)
                        .filter(([keyword, domains]) => domains.length > 1)
                        .map(([keyword, domains]) => {
                            const keywordData = {};
                            domainNames.forEach(domain => {
                                // Find the domain data entry that matches this domain name
                                const domainEntry = Object.values(data).find(d => {
                                    const dName = d.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0];
                                    return dName === domain;
                                });
                                const kwData = domainEntry?.rankingKeywords?.data?.ranking_keywords?.find(k => k.keyword?.toLowerCase() === keyword);
                                if (kwData) {
                                    keywordData[domain] = {
                                        rank: kwData.rank_position
                                    };
                                }
                            });
                            return { keyword, domains, data: keywordData };
                        })
                        .sort((a, b) => b.domains.length - a.domains.length || a.keyword.localeCompare(b.keyword));
                    
                    if (overlappingKeywords.length > 0) {
                        dashboardHTML += '<div class="overflow-x-auto"><table class="w-full border border-[var(--border-primary)] rounded-lg"><thead class="bg-[var(--bg-input)]"><tr>';
                        dashboardHTML += '<th class="px-4 py-2 text-left text-[var(--text-primary)] border-b border-[var(--border-primary)]">Keyword</th>';
                        dashboardHTML += '<th class="px-4 py-2 text-left text-[var(--text-primary)] border-b border-[var(--border-primary)]">Shared By</th>';
                        domainNames.forEach(domain => {
                            dashboardHTML += `<th class="px-4 py-2 text-left text-[var(--text-primary)] border-b border-[var(--border-primary)]">${domain}</th>`;
                        });
                        dashboardHTML += '</tr></thead><tbody>';
                        
                        overlappingKeywords.forEach(overlap => {
                            dashboardHTML += '<tr class="border-b border-[var(--border-primary)]">';
                            dashboardHTML += `<td class="px-4 py-2 text-[var(--text-primary)] font-semibold">${overlap.keyword}</td>`;
                            dashboardHTML += `<td class="px-4 py-2 text-[var(--text-primary)]">${overlap.domains.length} domains</td>`;
                            domainNames.forEach(domain => {
                                const kwData = overlap.data[domain];
                                if (kwData) {
                                    dashboardHTML += `<td class="px-4 py-2 text-[var(--text-primary)] text-sm">${kwData.rank ?? 'N/A'}</td>`;
                                } else {
                                    dashboardHTML += `<td class="px-4 py-2 text-[var(--text-secondary)] text-sm">Not ranking</td>`;
                                }
                            });
                            dashboardHTML += '</tr>';
                        });
                        
                        dashboardHTML += '</tbody></table></div>';
                    } else {
                        dashboardHTML += '<div class="bg-[var(--bg-input)] border border-[var(--border-primary)] rounded-lg p-6 text-center">';
                        dashboardHTML += '<p class="text-[var(--text-secondary)] mb-2">No overlapping keywords found.</p>';
                        dashboardHTML += '<p class="text-sm text-[var(--text-secondary)]">Try expanding your competitors list or increase ranking keyword counts to get more comparisons.</p>';
                        dashboardHTML += '</div>';
                    }
                } else {
                    dashboardHTML += '<p class="text-[var(--text-secondary)]">Add competitors to see overlapping keywords.</p>';
                }
                dashboardHTML += '</div>';
                dashboardHTML += '</div>';
                
                // Add Keyword Gap Snapshot section
                dashboardHTML += '<div id="keyword-gap-section" class="mt-6">';
                dashboardHTML += '<h4 class="font-bold text-lg text-[var(--text-primary)] mb-2">Keyword Gap Snapshot</h4>';
                dashboardHTML += '<p class="text-sm text-[var(--text-secondary)] mb-4">Here\'s a list of keywords your competitors are ranking for that may be fruitful opportunities to target.</p>';
                
                // Get your domain's keywords
                const yourDomainData = Object.values(data)[0];
                const yourDomainName = yourDomainData.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0];
                const yourKeywords = new Set((yourDomainData.rankingKeywords?.data?.ranking_keywords || []).map(kw => kw.keyword?.toLowerCase()).filter(Boolean));
                
                // Find keywords competitors rank for that your domain doesn't
                const gapKeywords = [];
                Object.values(data).slice(1).forEach((competitorData) => {
                    const competitorKeywords = competitorData.rankingKeywords?.data?.ranking_keywords || [];
                    competitorKeywords.forEach(kw => {
                        const kwLower = kw.keyword?.toLowerCase();
                        if (kwLower && !yourKeywords.has(kwLower) && kw.volume) {
                            gapKeywords.push({
                                keyword: kw.keyword,
                                volume: kw.volume || 0,
                                difficulty: kw.difficulty,
                                competitor: competitorData.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0]
                            });
                        }
                    });
                });
                
                // Remove duplicates and sort by volume
                const uniqueGapKeywords = [];
                const seenKeywords = new Set();
                gapKeywords.forEach(kw => {
                    if (!seenKeywords.has(kw.keyword.toLowerCase())) {
                        seenKeywords.add(kw.keyword.toLowerCase());
                        uniqueGapKeywords.push(kw);
                    }
                });
                uniqueGapKeywords.sort((a, b) => (b.volume || 0) - (a.volume || 0));
                
                if (uniqueGapKeywords.length > 0) {
                    dashboardHTML += '<div class="overflow-x-auto"><table class="w-full border border-[var(--border-primary)] rounded-lg"><thead class="bg-[var(--bg-input)]"><tr>';
                    dashboardHTML += '<th class="px-4 py-2 text-left text-[var(--text-primary)] border-b border-[var(--border-primary)]">Keyword</th>';
                    dashboardHTML += '<th class="px-4 py-2 text-left text-[var(--text-primary)] border-b border-[var(--border-primary)]">Volume</th>';
                    dashboardHTML += '<th class="px-4 py-2 text-left text-[var(--text-primary)] border-b border-[var(--border-primary)]">Difficulty</th>';
                    dashboardHTML += '<th class="px-4 py-2 text-left text-[var(--text-primary)] border-b border-[var(--border-primary)]">Competitor</th>';
                    dashboardHTML += '</tr></thead><tbody>';
                    
                    uniqueGapKeywords.slice(0, 20).forEach(kw => {
                        dashboardHTML += '<tr class="border-b border-[var(--border-primary)]">';
                        dashboardHTML += `<td class="px-4 py-2 text-[var(--text-primary)] font-semibold">${kw.keyword}<span class="copy-keyword-btn text-[var(--text-accent)]" data-keyword="${kw.keyword}" title="Copy keyword">📋</span></td>`;
                        dashboardHTML += `<td class="px-4 py-2 text-[var(--text-primary)]">${kw.volume ? formatNumber(kw.volume) : 'N/A'}</td>`;
                        dashboardHTML += `<td class="px-4 py-2 text-[var(--text-primary)]">${kw.difficulty ?? 'N/A'}</td>`;
                        dashboardHTML += `<td class="px-4 py-2 text-[var(--text-secondary)] text-sm">${kw.competitor}</td>`;
                        dashboardHTML += '</tr>';
                    });
                    
                    dashboardHTML += '</tbody></table></div>';
                    if (uniqueGapKeywords.length > 20) {
                        dashboardHTML += `<p class="text-sm text-[var(--text-secondary)] mt-2">Showing top 20 of ${uniqueGapKeywords.length} keyword opportunities</p>`;
                    }
                } else {
                    dashboardHTML += '<p class="text-[var(--text-secondary)]">No keyword gaps found — your domain ranks for all competitor keywords.</p>';
                }
                dashboardHTML += '</div>';
                
                // Create keywords section
                dashboardHTML += '<div id="keywords-section" class="mt-6">';
                dashboardHTML += '<h4 class="font-bold text-lg text-[var(--text-primary)] mb-4">Top Ranking Keywords</h4>';
                Object.values(data).forEach((domainData, idx) => {
                    dashboardHTML += `<div id="keywords-${idx}" class="keywords-panel ${idx === 0 ? '' : 'hidden'}">`;
                    dashboardHTML += `<h5 class="font-semibold text-[var(--text-heading)] mb-2">${domainData.label}</h5>`;
                    
                    const keywords = domainData.rankingKeywords?.data?.ranking_keywords || [];
                    if (keywords.length > 0) {
                        dashboardHTML += '<div class="overflow-x-auto"><table class="w-full border border-[var(--border-primary)] rounded-lg keywords-table" id="keywords-table-' + idx + '"><thead class="bg-[var(--bg-input)]"><tr>';
                        dashboardHTML += '<th class="px-4 py-2 text-left text-[var(--text-primary)] border-b border-[var(--border-primary)] sortable-header" data-sort="keyword">Keyword<span class="sort-indicator"></span></th>';
                        dashboardHTML += '<th class="px-4 py-2 text-left text-[var(--text-primary)] border-b border-[var(--border-primary)] sortable-header" data-sort="rank">Rank<span class="sort-indicator"></span></th>';
                        dashboardHTML += '<th class="px-4 py-2 text-left text-[var(--text-primary)] border-b border-[var(--border-primary)]">Page</th>';
                        dashboardHTML += '<th class="px-4 py-2 text-left text-[var(--text-primary)] border-b border-[var(--border-primary)] sortable-header" data-sort="difficulty">Difficulty<span class="sort-indicator"></span></th>';
                        dashboardHTML += '<th class="px-4 py-2 text-left text-[var(--text-primary)] border-b border-[var(--border-primary)] sortable-header" data-sort="volume">Volume<span class="sort-indicator"></span></th>';
                        dashboardHTML += '</tr></thead><tbody>';
                        
                        const limit = currentOriginalParams?.limit || 25;
                        keywords.slice(0, limit).forEach(kw => {
                            dashboardHTML += '<tr class="border-b border-[var(--border-primary)]" data-keyword="' + (kw.keyword || '').toLowerCase() + '" data-rank="' + (kw.rank_position || 999) + '" data-difficulty="' + (kw.difficulty || 999) + '" data-volume="' + (kw.volume || 0) + '">';
                            dashboardHTML += `<td class="px-4 py-2 text-[var(--text-primary)]">${kw.keyword || 'N/A'}<span class="copy-keyword-btn text-[var(--text-accent)]" data-keyword="${kw.keyword || ''}" title="Copy keyword">📋</span></td>`;
                            dashboardHTML += `<td class="px-4 py-2 text-[var(--text-primary)]">${kw.rank_position ?? 'N/A'}</td>`;
                            dashboardHTML += `<td class="px-4 py-2 text-[var(--text-secondary)] text-sm break-all max-w-xs">${kw.ranking_page || 'N/A'}</td>`;
                            dashboardHTML += `<td class="px-4 py-2 text-[var(--text-primary)]">${kw.difficulty ?? 'N/A'}</td>`;
                            dashboardHTML += `<td class="px-4 py-2 text-[var(--text-primary)]">${kw.volume ? formatNumber(kw.volume) : 'N/A'}</td>`;
                            dashboardHTML += '</tr>';
                        });
                        
                        dashboardHTML += '</tbody></table></div>';
                    } else {
                        dashboardHTML += '<p class="text-[var(--text-secondary)]">No ranking keywords found.</p>';
                    }
                    dashboardHTML += '</div>';
                });
                dashboardHTML += '</div>';
                dashboardHTML += '</div>';
                
                // Store JSON data and replace raw wrapper with dashboard
                allDOMElements.rawCode.textContent = JSON.stringify(data, null, 2);
                allDOMElements.rawWrapper.innerHTML = dashboardHTML;
                allDOMElements.rawWrapper.classList.remove('hidden');
                allDOMElements.viewDataBtn.textContent = 'View JSON';
                allDOMElements.exportPdfBtn.classList.remove('hidden');
                
                // Change "Clear Data" button to "Reset" for competitive analysis
                const clearBtn = allDOMElements.clearDataBtn;
                if (clearBtn) {
                    clearBtn.textContent = 'Reset';
                    clearBtn.dataset.originalText = 'Clear Data';
                }
                
                // Add event listener for domain selector
                const selector = document.getElementById('domain-selector');
                if (selector) {
                    selector.addEventListener('change', (e) => {
                        const selectedIdx = parseInt(e.target.value);
                        document.querySelectorAll('.keywords-panel').forEach((panel, idx) => {
                            panel.classList.toggle('hidden', idx !== selectedIdx);
                        });
                    });
                }
                
                // Add event listener for overlapping keywords toggle
                const toggleOverlapping = document.getElementById('toggle-overlapping');
                const overlappingContent = document.getElementById('overlapping-keywords-content');
                if (toggleOverlapping && overlappingContent) {
                    toggleOverlapping.addEventListener('click', () => {
                        const isHidden = overlappingContent.classList.contains('hidden');
                        if (isHidden) {
                            overlappingContent.classList.remove('hidden');
                            toggleOverlapping.textContent = 'Collapse';
                        } else {
                            overlappingContent.classList.add('hidden');
                            toggleOverlapping.textContent = 'Expand';
                        }
                    });
                }
                
                // Add sorting functionality for keywords tables
                document.querySelectorAll('.sortable-header').forEach(header => {
                    header.addEventListener('click', function() {
                        const table = this.closest('table');
                        const tbody = table.querySelector('tbody');
                        const rows = Array.from(tbody.querySelectorAll('tr'));
                        const sortBy = this.dataset.sort;
                        const isAsc = this.classList.contains('sort-asc');
                        
                        // Remove all sort classes
                        table.querySelectorAll('.sortable-header').forEach(h => {
                            h.classList.remove('sort-asc', 'sort-desc');
                        });
                        
                        // Add sort class
                        this.classList.add(isAsc ? 'sort-desc' : 'sort-asc');
                        
                        // Sort rows
                        rows.sort((a, b) => {
                            let aVal, bVal;
                            if (sortBy === 'keyword') {
                                aVal = a.dataset.keyword || '';
                                bVal = b.dataset.keyword || '';
                                return isAsc ? bVal.localeCompare(aVal) : aVal.localeCompare(bVal);
                            } else {
                                aVal = parseFloat(a.dataset[sortBy]) || 0;
                                bVal = parseFloat(b.dataset[sortBy]) || 0;
                                return isAsc ? bVal - aVal : aVal - bVal;
                            }
                        });
                        
                        // Reorder rows
                        rows.forEach(row => tbody.appendChild(row));
                    });
                });
                
                // Add copy keyword functionality
                document.querySelectorAll('.copy-keyword-btn').forEach(btn => {
                    btn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const keyword = this.dataset.keyword;
                        if (keyword) {
                            if (navigator.clipboard && navigator.clipboard.writeText) {
                                navigator.clipboard.writeText(keyword).then(() => {
                                    const originalText = this.textContent;
                                    this.textContent = '✓';
                                    setTimeout(() => {
                                        this.textContent = originalText;
                                    }, 2000);
                                }).catch(() => {
                                    displayError('Failed to copy keyword.');
                                });
                            } else {
                                // Fallback
                                const textArea = document.createElement('textarea');
                                textArea.value = keyword;
                                document.body.appendChild(textArea);
                                textArea.select();
                                try {
                                    document.execCommand('copy');
                                    const originalText = this.textContent;
                                    this.textContent = '✓';
                                    setTimeout(() => {
                                        this.textContent = originalText;
                                    }, 2000);
                                } catch (e) {
                                    displayError('Failed to copy keyword.');
                                }
                                document.body.removeChild(textArea);
                            }
                        }
                    });
                });
            }

            function handleExportPdf() {
                if (currentMethod !== 'competitiveAnalysis' || !currentResultsData) {
                    displayError('PDF export is only available for competitive analysis results.');
                    return;
                }
                
                const dashboard = document.getElementById('competitive-dashboard');
                if (!dashboard) {
                    displayError('Dashboard not found. Please run the analysis again.');
                    return;
                }
                
                // Show loading state
                const originalText = allDOMElements.exportPdfBtn.textContent;
                allDOMElements.exportPdfBtn.textContent = 'Generating PDF...';
                allDOMElements.exportPdfBtn.disabled = true;
                
                // Use html2canvas to capture the dashboard
                html2canvas(dashboard, {
                    backgroundColor: getComputedStyle(document.body).backgroundColor,
                    scale: 2,
                    logging: false
                }).then(canvas => {
                    const imgData = canvas.toDataURL('image/png');
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF('p', 'mm', 'a4');
                    
                    const imgWidth = 210; // A4 width in mm
                    const pageHeight = 297; // A4 height in mm
                    const imgHeight = (canvas.height * imgWidth) / canvas.width;
                    let heightLeft = imgHeight;
                    let position = 0;
                    
                    pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;
                    
                    while (heightLeft > 0) {
                        position = heightLeft - imgHeight;
                        pdf.addPage();
                        pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                        heightLeft -= pageHeight;
                    }
                    
                    const dateStr = new Date().toISOString().split('T')[0];
                    pdf.save(`competitive-analysis-${dateStr}.pdf`);
                    
                    // Reset button
                    allDOMElements.exportPdfBtn.textContent = originalText;
                    allDOMElements.exportPdfBtn.disabled = false;
                }).catch(error => {
                    console.error('PDF export error:', error);
                    displayError('Failed to export PDF. Please try again.');
                    allDOMElements.exportPdfBtn.textContent = originalText;
                    allDOMElements.exportPdfBtn.disabled = false;
                });
            }

            function handleCopyJson() {
                if (allDOMElements.rawCode.textContent) {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(allDOMElements.rawCode.textContent).then(() => {
                            allDOMElements.copyJsonBtn.textContent = 'Copied!';
                            setTimeout(() => { allDOMElements.copyJsonBtn.textContent = 'Copy JSON'; }, 2000);
                        }, () => {
                            displayError('Failed to copy JSON.');
                        });
                    } else {
                        // Fallback for older browsers
                        const textArea = document.createElement('textarea');
                        textArea.value = allDOMElements.rawCode.textContent;
                        document.body.appendChild(textArea);
                        textArea.select();
                        try {
                            document.execCommand('copy');
                            allDOMElements.copyJsonBtn.textContent = 'Copied!';
                            setTimeout(() => { allDOMElements.copyJsonBtn.textContent = 'Copy JSON'; }, 2000);
                        } catch (e) {
                            displayError('Failed to copy JSON.');
                        }
                        document.body.removeChild(textArea);
                    }
                }
            }
            
            function handleExportCsv() {
                if (currentMethod === 'competitiveAnalysis' && currentResultsData) {
                    exportCompetitiveAnalysisToCsv(currentResultsData, currentOriginalParams);
                } else if (currentResultsData) {
                    exportDataToCsv(currentResultsData, currentMethod, currentOriginalParams);
                } else {
                    displayError("No data available to export.");
                }
            }
            
            function exportCompetitiveAnalysisToCsv(data, params) {
                // Load SheetJS library dynamically
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                script.onload = () => {
                    try {
                        const workbook = XLSX.utils.book_new();
                        
                        // Sheet 1: Domain Metrics Summary
                        const metricsData = [];
                        metricsData.push(['Domain', 'Brand Authority', 'Domain Authority', 'Total Links', 'Linking Domains', 'Spam Score', 'Ranks 1-3', 'Ranks 4-10', 'Ranks 11-20', 'Ranks 21-50', 'Total Keywords']);
                        
                        Object.values(data).forEach((domainData) => {
                            const sm = domainData.siteMetrics?.data?.site_metrics || {};
                            const ba = domainData.brandAuthority?.data?.site_metrics?.brand_authority_score ?? 'N/A';
                            const da = sm.domain_authority ?? 'N/A';
                            const links = sm.external_pages_to_root_domain ?? 'N/A';
                            const linkingDomains = sm.root_domains_to_root_domain ?? 'N/A';
                            const spam = sm.spam_score ?? 'N/A';
                            
                            const kc = domainData.keywordCount?.data?.ranking_keyword_count;
                            const positions = kc?.position || {};
                            const rank1_3 = (positions.rank_1 || 0) + (positions.rank_2 || 0) + (positions.rank_3 || 0);
                            const rank4_10 = [4,5,6,7,8,9,10].reduce((sum, r) => sum + (positions[`rank_${r}`] || 0), 0);
                            const rank11_20 = [11,12,13,14,15,16,17,18,19,20].reduce((sum, r) => sum + (positions[`rank_${r}`] || 0), 0);
                            const rank21_50 = [21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50].reduce((sum, r) => sum + (positions[`rank_${r}`] || 0), 0);
                            
                            const domainName = domainData.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0];
                            metricsData.push([
                                domainName,
                                ba,
                                da,
                                typeof links === 'number' ? links : links,
                                typeof linkingDomains === 'number' ? linkingDomains : linkingDomains,
                                spam,
                                rank1_3,
                                rank4_10,
                                rank11_20,
                                rank21_50,
                                kc?.total || 0
                            ]);
                        });
                        
                        const metricsSheet = XLSX.utils.aoa_to_sheet(metricsData);
                        XLSX.utils.book_append_sheet(workbook, metricsSheet, 'Domain Metrics');
                        
                        // Sheet 2: Ranking Keywords (one per domain)
                        Object.values(data).forEach((domainData, idx) => {
                            const keywords = domainData.rankingKeywords?.data?.ranking_keywords || [];
                            const domainName = domainData.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0];
                            const sheetName = idx === 0 ? 'Your Domain Keywords' : `${domainName} Keywords`;
                            
                            const keywordsData = [['Keyword', 'Rank', 'Page', 'Difficulty', 'Volume']];
                            keywords.forEach(kw => {
                                keywordsData.push([
                                    kw.keyword || 'N/A',
                                    kw.rank_position ?? 'N/A',
                                    kw.ranking_page || 'N/A',
                                    kw.difficulty ?? 'N/A',
                                    kw.volume || 'N/A'
                                ]);
                            });
                            
                            const keywordsSheet = XLSX.utils.aoa_to_sheet(keywordsData);
                            XLSX.utils.book_append_sheet(workbook, keywordsSheet, sheetName.substring(0, 31)); // Excel sheet name limit
                        });
                        
                        // Sheet 3: Overlapping Keywords
                        const domainKeywords = {};
                        Object.values(data).forEach((domainData) => {
                            const keywords = domainData.rankingKeywords?.data?.ranking_keywords || [];
                            const domainName = domainData.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0];
                            domainKeywords[domainName] = keywords.map(kw => kw.keyword?.toLowerCase()).filter(Boolean);
                        });
                        
                        const domainNames = Object.keys(domainKeywords);
                        if (domainNames.length > 1) {
                            const keywordToDomains = {};
                            domainNames.forEach(domain => {
                                domainKeywords[domain].forEach(keyword => {
                                    if (!keywordToDomains[keyword]) {
                                        keywordToDomains[keyword] = [];
                                    }
                                    if (!keywordToDomains[keyword].includes(domain)) {
                                        keywordToDomains[keyword].push(domain);
                                    }
                                });
                            });
                            
                            const overlappingKeywords = Object.entries(keywordToDomains)
                                .filter(([keyword, domains]) => domains.length > 1)
                                .map(([keyword, domains]) => {
                                    const keywordData = {};
                                    domainNames.forEach(domain => {
                                        const domainEntry = Object.values(data).find(d => {
                                            const dName = d.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0];
                                            return dName === domain;
                                        });
                                        const kwData = domainEntry?.rankingKeywords?.data?.ranking_keywords?.find(k => k.keyword?.toLowerCase() === keyword);
                                        if (kwData) {
                                            keywordData[domain] = { rank: kwData.rank_position };
                                        }
                                    });
                                    return { keyword, domains, data: keywordData };
                                })
                                .sort((a, b) => b.domains.length - a.domains.length || a.keyword.localeCompare(b.keyword));
                            
                            if (overlappingKeywords.length > 0) {
                                const overlapData = [['Keyword', 'Shared By', ...domainNames]];
                                overlappingKeywords.forEach(overlap => {
                                    const row = [overlap.keyword, `${overlap.domains.length} domains`];
                                    domainNames.forEach(domain => {
                                        const kwData = overlap.data[domain];
                                        row.push(kwData ? kwData.rank : 'Not ranking');
                                    });
                                    overlapData.push(row);
                                });
                                
                                const overlapSheet = XLSX.utils.aoa_to_sheet(overlapData);
                                XLSX.utils.book_append_sheet(workbook, overlapSheet, 'Overlapping Keywords');
                            }
                        }
                        
                        // Sheet 4: Keyword Gap Snapshot
                        const yourDomainData = Object.values(data)[0];
                        const yourKeywords = new Set((yourDomainData.rankingKeywords?.data?.ranking_keywords || []).map(kw => kw.keyword?.toLowerCase()).filter(Boolean));
                        
                        const gapKeywords = [];
                        Object.values(data).slice(1).forEach((competitorData) => {
                            const competitorKeywords = competitorData.rankingKeywords?.data?.ranking_keywords || [];
                            competitorKeywords.forEach(kw => {
                                const kwLower = kw.keyword?.toLowerCase();
                                if (kwLower && !yourKeywords.has(kwLower) && kw.volume) {
                                    gapKeywords.push({
                                        keyword: kw.keyword,
                                        volume: kw.volume || 0,
                                        difficulty: kw.difficulty,
                                        competitor: competitorData.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0]
                                    });
                                }
                            });
                        });
                        
                        const uniqueGapKeywords = [];
                        const seenKeywords = new Set();
                        gapKeywords.forEach(kw => {
                            if (!seenKeywords.has(kw.keyword.toLowerCase())) {
                                seenKeywords.add(kw.keyword.toLowerCase());
                                uniqueGapKeywords.push(kw);
                            }
                        });
                        uniqueGapKeywords.sort((a, b) => (b.volume || 0) - (a.volume || 0));
                        
                        if (uniqueGapKeywords.length > 0) {
                            const gapData = [['Keyword', 'Volume', 'Difficulty', 'Competitor']];
                            uniqueGapKeywords.forEach(kw => {
                                gapData.push([kw.keyword, kw.volume || 'N/A', kw.difficulty ?? 'N/A', kw.competitor]);
                            });
                            
                            const gapSheet = XLSX.utils.aoa_to_sheet(gapData);
                            XLSX.utils.book_append_sheet(workbook, gapSheet, 'Keyword Gap Opportunities');
                        }
                        
                        // Export the workbook
                        const dateStr = new Date().toISOString().split('T')[0];
                        XLSX.writeFile(workbook, `competitive-analysis-${dateStr}.xlsx`);
                    } catch (error) {
                        console.error('Excel export error:', error);
                        displayError('Failed to export Excel file. Please try again.');
                    }
                };
                script.onerror = () => {
                    displayError('Failed to load Excel export library. Please try again.');
                };
                document.head.appendChild(script);
            }

            function toggleDataView() {
                // Handle competitive analysis specially
                if (currentMethod === 'competitiveAnalysis') {
                    const dashboard = document.getElementById('competitive-dashboard');
                    const isDashboardVisible = dashboard && !dashboard.closest('.hidden');
                    
                    if (isDashboardVisible) {
                        // Switch to JSON view
                        dashboard.parentElement.innerHTML = '<pre class="whitespace-pre-wrap break-all text-sm bg-[var(--bg-code)] text-[var(--text-primary)] p-4 rounded-lg" role="region" aria-label="Raw JSON data"><code></code></pre>';
                        const codeEl = allDOMElements.rawWrapper.querySelector('code');
                        if (codeEl) codeEl.textContent = JSON.stringify(currentResultsData, null, 2);
                        allDOMElements.viewDataBtn.textContent = 'View Dashboard';
                        allDOMElements.rawWrapper.classList.remove('hidden');
                        allDOMElements.exportPdfBtn.classList.add('hidden');
                    } else {
                        // Switch back to dashboard
                        showCompetitiveDashboard(currentResultsData);
                        allDOMElements.viewDataBtn.textContent = 'View JSON';
                        allDOMElements.exportPdfBtn.classList.remove('hidden');
                    }
                    return;
                }
                
                // Regular view toggle
                const isTableVisible = !allDOMElements.tableWrapper.classList.contains('hidden');
                if (isTableVisible) {
                    allDOMElements.tableWrapper.classList.add('hidden');
                    allDOMElements.rawWrapper.classList.remove('hidden');
                    allDOMElements.viewDataBtn.textContent = 'View Table';
                    allDOMElements.filterBtn.classList.add('hidden');
                    allDOMElements.exportPdfBtn.classList.add('hidden');
                } else {
                    allDOMElements.rawWrapper.classList.add('hidden');
                    allDOMElements.tableWrapper.classList.remove('hidden');
                    allDOMElements.viewDataBtn.textContent = 'View JSON';
                    allDOMElements.filterBtn.classList.remove('hidden');
                    allDOMElements.exportPdfBtn.classList.add('hidden');
                    renderTable(currentResultsData, currentMethod, currentOriginalParams);
                }
            }
            
            function showRawJsonResults(data) {
                // Don't override competitive dashboard
                if (currentMethod === 'competitiveAnalysis') {
                    return;
                }
                
                // Clear any existing dashboard
                const dashboard = document.getElementById('competitive-dashboard');
                if (dashboard) {
                    dashboard.remove();
                }
                
                // Reset "Reset" button back to "Clear Data" if it was changed
                if (allDOMElements.clearDataBtn && allDOMElements.clearDataBtn.dataset.originalText) {
                    allDOMElements.clearDataBtn.textContent = allDOMElements.clearDataBtn.dataset.originalText;
                    delete allDOMElements.clearDataBtn.dataset.originalText;
                }
                
                // Reset to standard JSON view
                allDOMElements.rawWrapper.innerHTML = '<pre class="whitespace-pre-wrap break-all text-sm bg-[var(--bg-code)] text-[var(--text-primary)] p-4 rounded-lg" role="region" aria-label="Raw JSON data"><code></code></pre>';
                allDOMElements.rawCode = document.querySelector('#raw-wrapper code');
                
                allDOMElements.rawCode.textContent = JSON.stringify(data, null, 2);
                allDOMElements.resultsContainer.classList.remove('hidden');
                allDOMElements.tableWrapper.classList.add('hidden');
                allDOMElements.rawWrapper.classList.remove('hidden');
                allDOMElements.viewDataBtn.textContent = 'View Table';
                allDOMElements.exportPdfBtn.classList.add('hidden');
            }

            function clearResultsData() {
                currentResultsData = null;
                currentOriginalParams = null;
                currentMethod = null;
                currentFilters = [];
                if (table) {
                    table.destroy();
                    table = null;
                }
                
                // Clear any competitive dashboard
                const dashboard = document.getElementById('competitive-dashboard');
                if (dashboard) {
                    dashboard.remove();
                }
                
                // Reset "Reset" button back to "Clear Data" if it was changed
                if (allDOMElements.clearDataBtn && allDOMElements.clearDataBtn.dataset.originalText) {
                    allDOMElements.clearDataBtn.textContent = allDOMElements.clearDataBtn.dataset.originalText;
                    delete allDOMElements.clearDataBtn.dataset.originalText;
                }
                
                // Reset rawWrapper to default structure
                allDOMElements.rawWrapper.innerHTML = '<pre class="whitespace-pre-wrap break-all text-sm bg-[var(--bg-code)] text-[var(--text-primary)] p-4 rounded-lg" role="region" aria-label="Raw JSON data"><code></code></pre>';
                allDOMElements.rawCode = document.querySelector('#raw-wrapper code');
                allDOMElements.rawCode.textContent = '';
                
                allDOMElements.resultsContainer.classList.add('hidden');
                allDOMElements.tableWrapper.classList.add('hidden');
                allDOMElements.rawWrapper.classList.add('hidden');
                allDOMElements.filterBtn.classList.add('hidden');
                allDOMElements.exportPdfBtn.classList.add('hidden');
                allDOMElements.activeFiltersContainer.classList.add('hidden');
                allDOMElements.activeFiltersContainer.innerHTML = '';
            }

            // History Management Functions

            function autoSaveToHistory() {
                if (currentMethod && currentOriginalParams && currentResultsData) {
                    const historyEntry = {
                        id: Date.now(),
                        timestamp: new Date().toISOString(),
                        method: currentMethod,
                        params: { ...currentOriginalParams },
                        resultCount: currentResultsData.length || 0,
                        success: true
                    };

                    const history = getSearchHistory();
                    history.unshift(historyEntry);
                    
                    // Keep only last 50 auto-saved entries
                    if (history.length > 50) {
                        history.splice(50);
                    }

                    saveSearchHistory(history);
                }
            }

            function getSearchHistory() {
                try {
                    const history = localStorage.getItem('mozSearchHistory');
                    return history ? JSON.parse(history) : [];
                } catch (e) {
                    console.warn('Could not load search history:', e);
                    return [];
                }
            }

            function saveSearchHistory(history) {
                try {
                    localStorage.setItem('mozSearchHistory', JSON.stringify(history));
                } catch (e) {
                    console.warn('Could not save search history:', e);
                    displayError('Could not save search history. Storage may be full.');
                }
            }

            function renderHistoryList(history = null) {
                const searchHistory = history || getSearchHistory();
                const searchTerm = allDOMElements.historySearch.value.toLowerCase();
                
                const filteredHistory = searchTerm 
                    ? searchHistory.filter(entry => 
                        entry.method.toLowerCase().includes(searchTerm) ||
                        JSON.stringify(entry.params).toLowerCase().includes(searchTerm) ||
                        new Date(entry.timestamp).toLocaleDateString().includes(searchTerm)
                      )
                    : searchHistory;

                if (filteredHistory.length === 0) {
                    allDOMElements.historyEmpty.classList.remove('hidden');
                    allDOMElements.historyList.innerHTML = '';
                    allDOMElements.historyList.appendChild(allDOMElements.historyEmpty);
                    return;
                }

                allDOMElements.historyEmpty.classList.add('hidden');
                allDOMElements.historyList.innerHTML = '';

                filteredHistory.forEach(entry => {
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'border border-[var(--border-primary)] rounded-lg p-4 mb-3 hover:bg-[var(--bg-input)] transition-colors';
                    
                    const methodName = entry.method.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                    const date = new Date(entry.timestamp).toLocaleString();
                    const paramsSummary = Object.entries(entry.params)
                        .filter(([key, value]) => value && value.length > 0)
                        .map(([key, value]) => `${key}: ${Array.isArray(value) ? value.join(', ') : value}`)
                        .join(' | ');

                    entryDiv.innerHTML = `
                        <div class="flex justify-between items-start mb-2">
                            <h3 class="font-semibold text-[var(--text-primary)]">${methodName}</h3>
                            <div class="flex items-center gap-2">
                                <span class="text-sm text-[var(--text-secondary)]">${date}</span>
                                <button class="text-[var(--text-accent)] hover:text-[var(--text-accent-hover)] text-sm" data-replay="${entry.id}">Replay</button>
                                <button class="text-[var(--text-error)] hover:text-red-600 text-sm" data-delete="${entry.id}">Delete</button>
                            </div>
                        </div>
                        <p class="text-sm text-[var(--text-secondary)] mb-2">${paramsSummary}</p>
                        <div class="flex items-center gap-4 text-xs text-[var(--text-secondary)]">
                            <span>Results: ${entry.resultCount}</span>
                            <span>Status: ${entry.success ? 'Success' : 'Failed'}</span>
                        </div>
                    `;

                    allDOMElements.historyList.appendChild(entryDiv);
                });
            }

            function filterHistory() {
                renderHistoryList();
            }

            function replaySearch(entryId) {
                const history = getSearchHistory();
                const entry = history.find(h => h.id.toString() === entryId);
                
                if (!entry) {
                    displayError('Search entry not found.');
                    return;
                }

                // Set the method
                allDOMElements.methodSelector.value = entry.method;
                allDOMElements.methodSelector.dispatchEvent(new Event('change'));

                // Populate form fields
                setTimeout(() => {
                    Object.entries(entry.params).forEach(([key, value]) => {
                        // Map parameter names to field IDs
                        const fieldId = getFieldIdForParam(entry.method, key);
                        const element = document.getElementById(fieldId);
                        
                        if (element) {
                            if (element.type === 'checkbox') {
                                element.checked = value;
                            } else if (Array.isArray(value)) {
                                // For competitive analysis competitors array or any array value
                                element.value = value.join('\n');
                            } else if (element.type === 'select-one' || element.type === 'select-multiple') {
                                if (Array.isArray(value)) {
                                    // For multi-select
                                    Array.from(element.options).forEach(option => {
                                        option.selected = value.includes(option.value);
                                    });
                                } else {
                                    element.value = value;
                                }
                            } else {
                                element.value = value;
                            }
                        }
                    });
                }, 100);

                allDOMElements.historyModal.classList.add('hidden');
            }

            // Map parameter names to field IDs
            function getFieldIdForParam(method, paramName) {
                const mappings = {
                    'siteMetrics': {
                        'scope': 'smScopeSelect',
                        'urls': 'smUrlsInput'
                    },
                    'keywordMetrics': {
                        'metricType': 'kmMetricTypeSelect',
                        'device': 'kmDeviceSelect',
                        'engine': 'kmEngineSelect',
                        'locale': 'kmLocaleSelect',
                        'keywords': 'kmKeywordsInput'
                    },
                    'brandAuthority': {
                        'urls': 'baUrlsInput'
                    },
                    'searchIntent': {
                        'locale': 'siLocaleSelect',
                        'keywords': 'siKeywordsInput'
                    },
                    'rankingKeywords': {
                        'scope': 'rkScopeSelect',
                        'locale': 'rkLocaleSelect',
                        'limit': 'rkLimit',
                        'urls': 'rkUrlsInput'
                    },
                    'relatedKeywords': {
                        'locale': 'rlLocaleSelect',
                        'keywords': 'rlKeywordsInput'
                    },
                    'keywordCount': {
                        'scope': 'kcScopeSelect',
                        'locale': 'kcLocaleSelect',
                        'urls': 'kcUrlsInput'
                    },
                    'anchorText': {
                        'scope': 'atScopeSelect',
                        'limit': 'atLimit',
                        'urls': 'atUrlsInput'
                    },
                    'recentlyGainedLinks': {
                        'scope': 'rglScopeSelect',
                        'limit': 'rglLimit',
                        'beginDate': 'rglBeginDate',
                        'endDate': 'rglEndDate',
                        'urls': 'rglUrlsInput'
                    },
                    'recentlyLostLinks': {
                        'scope': 'rllScopeSelect',
                        'limit': 'rllLimit',
                        'beginDate': 'rllBeginDate',
                        'endDate': 'rllEndDate',
                        'urls': 'rllUrlsInput'
                    },
                    'linkingDomains': {
                        'scope': 'ldScopeSelect',
                        'sort': 'ldSortSelect',
                        'filters': 'ldFilterSelect',
                        'limit': 'ldLimit',
                        'urls': 'ldUrlsInput'
                    },
                    'finalRedirect': {
                        'scope': 'frScopeSelect',
                        'urls': 'frUrlsInput'
                    },
                    'topPages': {
                        'scope': 'tpScopeSelect',
                        'filter': 'tpFilterSelect',
                        'sort': 'tpSortSelect',
                        'limit': 'tpLimit',
                        'urls': 'tpUrlsInput'
                    },
                    'linkIntersect': {
                        'scope': 'liScopeSelect',
                        'sort': 'liSortSelect',
                        'minMatch': 'liMinMatch',
                        'limit': 'liLimit',
                        'isLinkingTo': 'liIsLinkingTo',
                        'notLinkingTo': 'liNotLinkingTo'
                    },
                    'listLinks': {
                        'scope': 'llScopeSelect',
                        'sort': 'llSortSelect',
                        'filters': 'llFilterSelect',
                        'limit': 'llLimit',
                        'urls': 'llUrlsInput'
                    },
                    'linkStatus': {
                        'targetScope': 'lsTargetScopeSelect',
                        'targetUrl': 'lsTargetUrl',
                        'sourceScope': 'lsSourceScopeSelect',
                        'sourceUrl': 'lsSourceUrl'
                    },
                    'filterLinksByAnchor': {
                        'scope': 'flaScopeSelect',
                        'anchor': 'flaAnchor',
                        'limit': 'flaLimit',
                        'urls': 'flaUrlsInput'
                    },
                    'filterLinksByDomain': {
                        'scope': 'fldScopeSelect',
                        'domain': 'fldDomain',
                        'limit': 'fldLimit',
                        'urls': 'fldUrlsInput'
                    },
                    'competitiveAnalysis': {
                        'yourDomain': 'caYourDomain',
                        'competitors': 'caCompetitors',
                        'locale': 'caLocaleSelect',
                        'limit': 'caLimit'
                    }
                };

                return mappings[method]?.[paramName] || paramName;
            }

            function deleteHistoryEntry(entryId) {
                if (confirm('Are you sure you want to delete this search from history?')) {
                    const history = getSearchHistory();
                    const filteredHistory = history.filter(h => h.id.toString() !== entryId);
                    saveSearchHistory(filteredHistory);
                    renderHistoryList();
                }
            }

            function exportHistory() {
                const history = getSearchHistory();
                if (history.length === 0) {
                    displayError('No history to export.');
                    return;
                }

                const dataStr = JSON.stringify(history, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `moz-search-history-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);
            }

            function clearAllHistory() {
                if (confirm('Are you sure you want to clear all search history? This cannot be undone.')) {
                    saveSearchHistory([]);
                    renderHistoryList();
                }
            }

            function displayError(message) {
                 const hints = /quota|limit/i.test(message) ? 'You may be out of rows. Check your API Dashboard.' :
                              /unauthorized|401|403/i.test(message) ? 'Invalid API key. Recheck or regenerate in your dashboard.' :
                              /network|abort/i.test(message) ? 'Network hiccup or request was canceled. Try again.' : '';
                allDOMElements.errorMessage.innerHTML = `${message}${hints ? `<br><span class="text-[var(--text-secondary)]">${hints}</span>` : ''}`;
                allDOMElements.errorMessage.classList.remove('hidden');
            }
            
            function resetSubmitButton() {
                allDOMElements.submitBtn.disabled = allDOMElements.methodSelector.value === "";
                allDOMElements.submitBtn.innerHTML = 'Run Request';
                allDOMElements.submitBtn.removeAttribute('aria-busy');
            }

            function buildPayload(apiKey, selectedMethod) {
                let payload = { apiKey, method: selectedMethod, params: {} };
                const getInputValue = (id) => document.getElementById(id)?.value;
                const getCleanedList = (id) => getInputValue(id)?.split(/[\n,]/).map(item => item.trim()).filter(Boolean);
                const getSelectedOptions = (id) => Array.from(document.getElementById(id).selectedOptions).map(({ value }) => value);

                switch (selectedMethod) {
                    case 'siteMetrics': payload.params = { scope: getInputValue('smScopeSelect'), targets: getCleanedList('smUrlsInput') }; break;
                    case 'keywordMetrics': payload.params = { metricType: getInputValue('kmMetricTypeSelect'), device: getInputValue('kmDeviceSelect'), engine: getInputValue('kmEngineSelect'), locale: getInputValue('kmLocaleSelect'), keywords: getCleanedList('kmKeywordsInput') }; break;
                    case 'brandAuthority': payload.params = { targets: getCleanedList('baUrlsInput') }; break;
                    case 'searchIntent': payload.params = { locale: getInputValue('siLocaleSelect'), keywords: getCleanedList('siKeywordsInput') }; break;
                    case 'rankingKeywords': payload.params = { scope: getInputValue('rkScopeSelect'), locale: getInputValue('rkLocaleSelect'), targets: getCleanedList('rkUrlsInput'), limit: parseInt(getInputValue('rkLimit'), 10) || 25 }; break;
                    case 'relatedKeywords': payload.params = { locale: getInputValue('rlLocaleSelect'), keywords: getCleanedList('rlKeywordsInput') }; break;
                    case 'keywordCount': payload.params = { scope: getInputValue('kcScopeSelect'), locale: getInputValue('kcLocaleSelect'), targets: getCleanedList('kcUrlsInput') }; break;
                    case 'anchorText': payload.params = { scope: getInputValue('atScopeSelect'), targets: getCleanedList('atUrlsInput'), limit: parseInt(getInputValue('atLimit'), 10) || 25 }; break;
                    case 'recentlyGainedLinks': payload.params = { scope: getInputValue('rglScopeSelect'), targets: getCleanedList('rglUrlsInput'), limit: parseInt(getInputValue('rglLimit'), 10) || 25, beginDate: getInputValue('rglBeginDate'), endDate: getInputValue('rglEndDate') }; break;
                    case 'recentlyLostLinks': payload.params = { scope: getInputValue('rllScopeSelect'), targets: getCleanedList('rllUrlsInput'), limit: parseInt(getInputValue('rllLimit'), 10) || 25, beginDate: getInputValue('rllBeginDate'), endDate: getInputValue('rllEndDate') }; break;
                    case 'linkingDomains': payload.params = { scope: getInputValue('ldScopeSelect'), targets: getCleanedList('ldUrlsInput'), limit: parseInt(getInputValue('ldLimit'), 10) || 25, sort: getInputValue('ldSortSelect'), filters: getSelectedOptions('ldFilterSelect')}; break;
                    case 'finalRedirect': payload.params = { scope: getInputValue('frScopeSelect'), targets: getCleanedList('frUrlsInput') }; break;
                    case 'topPages': payload.params = { scope: getInputValue('tpScopeSelect'), targets: getCleanedList('tpUrlsInput'), limit: parseInt(getInputValue('tpLimit'), 10) || 25, filter: getInputValue('tpFilterSelect'), sort: getInputValue('tpSortSelect') }; break;
                    case 'linkIntersect': {
                        const intersectScope = getInputValue('liScopeSelect');
                        payload.params = { 
                            scope: intersectScope, 
                            limit: parseInt(getInputValue('liLimit'), 10) || 25, 
                            is_linking_to: getCleanedList('liIsLinkingTo').map(q => ({query: q, scope: intersectScope})), 
                            not_linking_to: getCleanedList('liNotLinkingTo').map(q => ({query: q, scope: intersectScope})), 
                            sort: getInputValue('liSortSelect'), 
                            minimum_matching_targets: parseInt(getInputValue('liMinMatch'), 10) || 1 
                        }; 
                        break;
                    }
                    case 'listLinks': payload.params = { scope: getInputValue('llScopeSelect'), targets: getCleanedList('llUrlsInput'), limit: parseInt(getInputValue('llLimit'), 10) || 25, filters: getSelectedOptions('llFilterSelect'), sort: getInputValue('llSortSelect') }; break;
                    case 'linkStatus': payload.params = { targetScope: getInputValue('lsTargetScopeSelect'), targetQuery: getInputValue('lsTargetUrl'), sourceScope: getInputValue('lsSourceScopeSelect'), sourceQuery: getInputValue('lsSourceUrl') }; break;
                    case 'filterLinksByAnchor': payload.params = { scope: getInputValue('flaScopeSelect'), targets: getCleanedList('flaUrlsInput'), anchorText: getInputValue('flaAnchorText'), limit: parseInt(getInputValue('flaLimit'), 10) || 25, filters: getSelectedOptions('flaFilterSelect'), sort: getInputValue('flaSortSelect') }; break;
                    case 'filterLinksByDomain': payload.params = { targetScope: getInputValue('fldTargetScopeSelect'), targetQueries: getCleanedList('fldTargetUrls'), sourceScope: getInputValue('fldSourceScopeSelect'), sourceQueries: getCleanedList('fldSourceUrls'), limit: parseInt(getInputValue('fldLimit'), 10) || 25, filters: getSelectedOptions('fldFilterSelect')}; break;
                    case 'competitiveAnalysis': {
                        const yourDomain = getInputValue('caYourDomain')?.trim();
                        const competitors = getInputValue('caCompetitors')?.split(/[\n,]/).map(item => item.trim()).filter(Boolean).slice(0, 3);
                        if (!yourDomain) throw new Error('Please enter your domain.');
                        if (!competitors || competitors.length === 0) throw new Error('Please enter at least one competitor domain.');
                        payload.params = { 
                            yourDomain, 
                            competitors, 
                            locale: getInputValue('caLocaleSelect') || 'en-US',
                            limit: parseInt(getInputValue('caLimit'), 10) || 25
                        };
                        break;
                    }
                    default: throw new Error('Invalid method selected.');
                }
                
                if (['siteMetrics', 'keywordMetrics', 'brandAuthority', 'searchIntent', 'rankingKeywords', 'relatedKeywords', 'keywordCount', 'anchorText', 'recentlyGainedLinks', 'recentlyLostLinks', 'linkingDomains', 'finalRedirect', 'topPages', 'listLinks', 'filterLinksByAnchor'].includes(selectedMethod)) {
                    if ((payload.params.targets?.length === 0) && (payload.params.keywords?.length === 0)) {
                        throw new Error('Please enter at least one URL or Keyword.');
                    }
                }
                 if (selectedMethod === 'linkIntersect' && payload.params.is_linking_to.length === 0) {
                     throw new Error('Please enter at least one URL for "Linking To".');
                 }
                 if (selectedMethod === 'linkStatus' && (!payload.params.targetQuery || !payload.params.sourceQuery)) {
                    throw new Error('Please enter both a Target and Source URL for Link Status.');
                 }
                return payload;
            }
             
            function exportDataToCsv(results, method, originalParams) {
                const rows = DataProcessor.processResults(results, method, originalParams);
                if (rows.length === 0) { displayError("No valid data to export."); return; }
                
                const allKeys = [...new Set(rows.flatMap(row => Object.keys(row)))];
                const header = allKeys.join(',');
                const csvRows = rows.map(row => allKeys.map(key => {
                    const value = row[key] === undefined || row[key] === null ? '' : row[key];
                    const stringValue = String(value);
                    if (stringValue.includes(',') || stringValue.includes('"')) {
                        return `"${stringValue.replace(/"/g, '""')}"`;
                    }
                    return stringValue;
                }).join(','));
                const csvString = '\uFEFF' + [header, ...csvRows].join('\n');
                const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `moz-api-results-${method}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            function renderTable(results, method, originalParams) {
                if (table) {
                    table.destroy();
                }
                
                const rows = DataProcessor.processResults(results, method, originalParams);
                
                if (rows.length > 0) {
                    const allKeys = [...new Set(rows.flatMap(row => Object.keys(row)))];
                    const columns = allKeys.map(key => ({ title: key, field: key }));
                    
                    table = new Tabulator("#results-table", {
                        data: rows,
                        columns: columns,
                        layout: "fitDataFill",
                        pagination: "local",
                        paginationSize: 100,
                        movableColumns: true,
                        resizableRows: false,
                    });

                    allDOMElements.filterFieldsContainer.innerHTML = '';
                    columns.forEach(col => {
                        if (col.field) {
                            const div = document.createElement('div');
                            const label = document.createElement('label');
                            label.textContent = col.title;
                            label.className = 'block text-sm font-medium text-[var(--text-secondary)]';
                            const input = document.createElement('input');
                            input.type = 'text';
                            input.dataset.field = col.field;
                            input.className = 'w-full bg-[var(--bg-input-secondary)] border-[var(--border-secondary)] rounded-md p-2 mt-1 text-[var(--text-primary)]';
                            div.appendChild(label);
                            div.appendChild(input);
                            allDOMElements.filterFieldsContainer.appendChild(div);
                        }
                    });
                }
            }

            function applyTableFilters() {
                const filterInputs = allDOMElements.filterFieldsContainer.querySelectorAll('input');
                currentFilters = [];
                filterInputs.forEach(input => {
                    if (input.value) {
                        currentFilters.push({
                            field: input.dataset.field,
                            type: 'like',
                            value: input.value
                        });
                    }
                });
                table.setFilter(currentFilters);
                updateActiveFilterChips();
                allDOMElements.filterModal.classList.add('hidden');
            }

            function updateActiveFilterChips() {
                allDOMElements.activeFiltersContainer.innerHTML = '';
                if (currentFilters.length > 0) {
                    const title = document.createElement('span');
                    title.className = 'text-sm font-bold text-[var(--text-secondary)]';
                    title.textContent = 'Active Filters:';
                    allDOMElements.activeFiltersContainer.appendChild(title);

                    currentFilters.forEach((filter, index) => {
                        const chip = document.createElement('span');
                        chip.className = 'inline-flex items-center px-2 py-1 bg-[var(--bg-input-secondary)] text-sm rounded-full';
                        chip.textContent = `${filter.field}: "${filter.value}"`;
                        const closeBtn = document.createElement('button');
                        closeBtn.className = 'ml-2 text-[var(--text-accent)]';
                        closeBtn.innerHTML = '&times;';
                        closeBtn.onclick = () => {
                            currentFilters.splice(index, 1);
                            table.setFilter(currentFilters);
                            updateActiveFilterChips();
                        };
                        chip.appendChild(closeBtn);
                        allDOMElements.activeFiltersContainer.appendChild(chip);
                    });
                    allDOMElements.activeFiltersContainer.classList.remove('hidden');
                } else {
                    allDOMElements.activeFiltersContainer.classList.add('hidden');
                }
            }

            // Initial calls
            allDOMElements.readmeModalContent.innerHTML = readmeContent;
            populateInputs();
            setupEventListeners();
            loadApiKey();
            allDOMElements.submitBtn.disabled = true;
            
            // Performance monitoring
            performanceMonitor.mark('init-complete');
            performanceMonitor.measure('initialization', 'dom-ready', 'init-complete');
            
            // Log performance metrics after a short delay
            setTimeout(() => {
                performanceMonitor.logMetrics();
            }, 100);

        });
    </script>
</body>
</html>
