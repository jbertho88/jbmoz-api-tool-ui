<!DOCTYPE html>
<html lang="en"> <!-- Theme class will be added here by JS -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow">
    <meta name="description" content="Advanced Moz API Tool for SEO data analysis and link building research">
    <title>Advanced Moz API Tool</title>
    
    <!-- Preload critical resources for faster loading -->
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com">
    <link rel="preconnect" href="https://cdn.tailwindcss.com">
    
    <!-- DNS prefetch for additional performance -->
    <link rel="dns-prefetch" href="https://upload.wikimedia.org">
    <link rel="dns-prefetch" href="https://mozapi-proxy-server.vercel.app">
    
    <!-- Load Tailwind CSS synchronously to prevent FOUC -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load fonts with immediate fallback -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"></noscript>
    
    <!-- Tabulator CSS - Load synchronously to prevent FOUC -->
    <link rel="stylesheet" href="https://unpkg.com/tabulator-tables@5.5.2/dist/css/tabulator.min.css">
    <link rel="preload" href="https://unpkg.com/tabulator-tables@5.5.2/dist/css/tabulator.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://unpkg.com/tabulator-tables@5.5.2/dist/css/tabulator.min.css"></noscript>
    
    <!-- Load Tabulator JS asynchronously with error handling -->
    <script>
        // Load Tabulator asynchronously to improve initial page load
        (function() {
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/tabulator-tables@5.5.2/dist/js/tabulator.min.js';
            script.async = true;
            script.crossOrigin = 'anonymous';
            script.onerror = function() {
                console.warn('Failed to load Tabulator library. Table functionality will be limited.');
            };
            document.head.appendChild(script);
        })();
    </script>
    <!-- Load jsPDF for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* Critical CSS - Prevents FOUC */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: #f9fafb;
            color: #111827;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            opacity: 1;
            transition: opacity 0.3s ease;
        }
        
        /* Loading state - hidden until CSS loads */
        .css-loading {
            opacity: 0;
        }
        
        .css-loaded {
            opacity: 1;
        }
        
        /* Base styles */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: var(--bg-body);
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
            margin: 0;
            padding: 0;
            will-change: background-color, color;
        }

        /* Theme Variables - Light (Default) */
        :root, .light {
            /* Backgrounds */
            --bg-body: #f9fafb;
            --bg-container: #ffffff;
            --bg-container-translucent: rgba(255, 255, 255, 0.5);
            --bg-input: #f3f4f6;
            --bg-input-secondary: #e5e7eb;
            --bg-code: #fefce8;
            --bg-disabled: #d1d5db;
            
            /* Borders */
            --border-primary: #e5e7eb;
            --border-secondary: #d1d5db;
            
            /* Text Colors */
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --text-accent: #0284c7;
            --text-accent-hover: #0369a1;
            --text-heading: #0ea5e9;
            --text-error: #b91c1c;
            
            /* Button Colors */
            --btn-primary-bg: #002F50;
            --btn-primary-hover: #001d30;
            --btn-copy-bg: #f97316;
            --btn-copy-hover: #ea580c;
            --btn-export-bg: #10b981;
            --btn-export-hover: #059669;
            --btn-view-data-bg: #0ea5e9;
            --btn-view-data-hover: #0284c7;
            --btn-clear-bg: #ef4444;
            --btn-clear-hover: #b91c1c;
            
            /* Error Colors */
            --error-bg: #fee2e2;
            --error-border: #fca5a5;
            
            /* Tabulator Colors */
            --tabulator-header-bg: var(--bg-input);
            --tabulator-row-bg: var(--bg-container);
            --tabulator-row-even-bg: var(--bg-input-secondary);
            --tabulator-border: var(--border-primary);
            --tabulator-text: var(--text-primary);
            --tabulator-footer-bg: var(--bg-input);
            --tabulator-pag-button-bg: var(--bg-container);
            --tabulator-pag-button-hover: var(--bg-input-secondary);
        }

        /* Dark Theme */
        .dark {
            --bg-body: #020617;
            --bg-container: #1e293b;
            --bg-container-translucent: rgba(30, 41, 59, 0.5);
            --bg-input: #0f172a;
            --bg-input-secondary: #334155;
            --bg-code: #000000;
            --bg-disabled: #475569;
            --border-primary: #334155;
            --border-secondary: #475569;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --text-accent: #38bdf8;
            --text-accent-hover: #7dd3fc;
            --text-heading: #38bdf8;
            --text-error: #f87171;
            --btn-primary-bg: #0ea5e9;
            --btn-primary-hover: #38bdf8;
            --btn-copy-bg: #f97316;
            --btn-copy-hover: #fb923c;
            --btn-export-bg: #10b981;
            --btn-export-hover: #34d399;
            --btn-view-data-bg: #0ea5e9;
            --btn-view-data-hover: #38bdf8;
            --btn-clear-bg: #ef4444;
            --btn-clear-hover: #f87171;
            --error-bg: rgba(153, 27, 27, 0.5);
            --error-border: #ef4444;
            --tabulator-header-bg: var(--bg-input);
            --tabulator-row-bg: #1e293b;
            --tabulator-row-even-bg: #0f172a;
            --tabulator-border: var(--border-primary);
            --tabulator-text: var(--text-primary);
            --tabulator-footer-bg: var(--bg-input);
            --tabulator-pag-button-bg: var(--bg-input-secondary);
            --tabulator-pag-button-hover: #475569;
        }

        /* Retro Theme */
        .retro {
            --bg-body: #000000;
            --bg-container: #1a001a;
            --bg-container-translucent: rgba(26, 0, 26, 0.5);
            --bg-input: #2a002a;
            --bg-input-secondary: #3d003d;
            --bg-code: #000000;
            --bg-disabled: #4a148c;
            --border-primary: #4a148c;
            --border-secondary: #6a1b9a;
            --text-primary: #e0e0e0;
            --text-secondary: #ad5eda;
            --text-accent: #2de2e6;
            --text-accent-hover: #81f7f9;
            --text-heading: #9700cc;
            --text-error: #f6019d;
            --btn-primary-bg: #f6019d;
            --btn-primary-hover: #d40078;
            --btn-copy-bg: #9700cc;
            --btn-copy-hover: #7b00a3;
            --btn-export-bg: #11d18e;
            --btn-export-hover: #0da872;
            --btn-view-data-bg: #2de2e6;
            --btn-view-data-hover: #81f7f9;
            --btn-clear-bg: #f6019d;
            --btn-clear-hover: #d40078;
            --error-bg: rgba(246, 1, 157, 0.2);
            --error-border: #f6019d;
            --tabulator-header-bg: var(--bg-input);
            --tabulator-row-bg: #1a001a;
            --tabulator-row-even-bg: #2a002a;
            --tabulator-border: var(--border-primary);
            --tabulator-text: var(--text-primary);
            --tabulator-footer-bg: var(--bg-input);
            --tabulator-pag-button-bg: var(--bg-input-secondary);
            --tabulator-pag-button-hover: #6a1b9a;
        }

        /* High Contrast Theme */
        .high-contrast {
            --bg-body: #000000;
            --bg-container: #000000;
            --bg-container-translucent: rgba(0, 0, 0, 0.5);
            --bg-input: #000000;
            --bg-input-secondary: #000000;
            --bg-code: #000000;
            --bg-disabled: #333333;
            --border-primary: #ffffff;
            --border-secondary: #ffffff;
            --text-primary: #ffffff;
            --text-secondary: #e5e5e5;
            --text-accent: #ffffff;
            --text-accent-hover: #cccccc;
            --text-heading: #ffffff;
            --text-error: #ffffff;
            --btn-primary-bg: #ffffff;
            --btn-primary-hover: #e5e5e5;
            --btn-copy-bg: #ffffff;
            --btn-copy-hover: #e5e5e5;
            --btn-export-bg: #ffffff;
            --btn-export-hover: #e5e5e5;
            --btn-view-data-bg: #ffffff;
            --btn-view-data-hover: #e5e5e5;
            --btn-clear-bg: #ffffff;
            --btn-clear-hover: #e5e5e5;
            --error-bg: #000000;
            --error-border: #ff0000;
            --tabulator-header-bg: #000;
            --tabulator-row-bg: #000;
            --tabulator-row-even-bg: #000;
            --tabulator-border: #fff;
            --tabulator-text: #fff;
            --tabulator-footer-bg: #000;
            --tabulator-pag-button-bg: #333;
            --tabulator-pag-button-hover: #555;
        }
        
        /* High contrast button text override */
        .high-contrast .btn-inverted-text {
            color: #000000 !important;
        }

        /* Loading spinner */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.2);
            width: 24px; 
            height: 24px; 
            border-radius: 50%;
            border-left-color: #ffffff;
            animation: spin 1s ease infinite;
            will-change: transform;
        }
        
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }
        
        /* Form elements */
        .input-section { 
            display: none; 
            margin-top: 1.5rem; 
            padding-top: 1.5rem; 
            border-top-width: 1px; 
            border-color: var(--border-primary); 
        }
        
        option[disabled] { 
            font-weight: bold; 
            background-color: var(--bg-input-secondary); 
        }

        /* Modal content styles */
        #readme-modal-content h2 { 
            border-bottom: 1px solid var(--border-primary);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
            margin-top: 1.25rem;
            font-size: 1.25rem;
            line-height: 1.75rem;
            border-color: var(--border-primary); 
            color: var(--text-accent); 
        }
        
        #readme-modal-content h3 { 
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
            font-size: 1.125rem;
            line-height: 1.75rem;
            color: var(--text-primary); 
        }
        
        #readme-modal-content p, 
        #readme-modal-content li { 
            color: var(--text-secondary); 
        }
        
        #readme-modal-content a { 
            color: var(--text-accent); 
            text-decoration: underline;
        }
        
        #readme-modal-content a:hover { 
            text-decoration: underline;
        }
        
        #readme-modal-content ul, 
        #readme-modal-content ol { 
            margin-left: 1.25rem;
            list-style-type: disc;
        }
        
        #readme-modal-content ol { 
            list-style-type: decimal;
        }
        
        #readme-modal-content code { 
            background-color: rgba(0, 0, 0, 0.5);
            padding: 0.125rem 0.25rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            line-height: 1.25rem;
            color: var(--btn-copy-bg); 
        }
        
        .readme-method { 
            margin-bottom: 1.5rem; 
        }

        /* Tabulator table styles */
        .tabulator {
            border-color: var(--border-primary);
            background-color: var(--bg-container);
            color: var(--text-primary);
        }
        
        .tabulator .tabulator-header {
            background-color: var(--tabulator-header-bg);
            border-bottom-color: var(--border-primary);
        }
        
        .tabulator .tabulator-header .tabulator-col {
            background-color: var(--tabulator-header-bg);
            color: var(--text-primary);
        }
        
        .tabulator .tabulator-tableHolder .tabulator-table .tabulator-row {
            background-color: var(--tabulator-row-bg);
            color: var(--text-primary);
        }
        
        .tabulator .tabulator-tableHolder .tabulator-table .tabulator-row.tabulator-row-even {
            background-color: var(--tabulator-row-even-bg);
        }
        
        .tabulator .tabulator-footer {
            background-color: var(--tabulator-footer-bg);
            border-top-color: var(--border-primary);
        }
        
        .tabulator .tabulator-footer .tabulator-paginator button {
            background: var(--tabulator-pag-button-bg);
            color: var(--text-primary);
        }
        
        .tabulator .tabulator-footer .tabulator-paginator button:hover {
            background: var(--tabulator-pag-button-hover);
        }
        
        /* Tooltip styles */
        .tooltip-container {
            position: relative;
            display: inline-block;
        }
        
        .tooltip-icon {
            display: inline-block;
            width: 14px;
            height: 14px;
            margin-left: 4px;
            border-radius: 50%;
            background-color: var(--text-secondary);
            color: var(--bg-body);
            font-size: 10px;
            line-height: 14px;
            text-align: center;
            cursor: help;
            vertical-align: middle;
        }
        
        .tooltip-text {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--bg-container);
            color: var(--text-primary);
            text-align: center;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--border-primary);
            white-space: nowrap;
            z-index: 1000;
            font-size: 12px;
            max-width: 250px;
            white-space: normal;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        
        /* Sortable table headers */
        .sortable-header {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 20px;
        }
        
        .sortable-header:hover {
            background-color: var(--bg-input-secondary);
        }
        
        .sort-indicator {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: var(--text-secondary);
        }
        
        .sort-asc .sort-indicator::after { content: '‚ñ≤'; }
        .sort-desc .sort-indicator::after { content: '‚ñº'; }
        
        /* Copy button in table */
        .copy-keyword-btn {
            display: inline-block;
            margin-left: 4px;
            opacity: 0;
            transition: opacity 0.2s;
            cursor: pointer;
            font-size: 12px;
        }
        
        tr:hover .copy-keyword-btn {
            opacity: 1;
        }
        
        /* Competitive Analysis Dashboard Grid Constraints */
        .metrics-grid-container {
            display: grid !important;
            width: 100% !important;
            gap: 1rem !important;
            margin-bottom: 1.5rem !important;
            grid-template-columns: repeat(1, minmax(0, 1fr)) !important;
            max-width: 100% !important;
            box-sizing: border-box !important;
        }
        
        .metrics-grid-container > * {
            min-width: 0 !important;
            max-width: 100% !important;
            width: 100% !important;
            box-sizing: border-box !important;
            overflow: hidden !important;
            word-wrap: break-word !important;
            word-break: break-word !important;
        }
        
        /* Ensure grid items don't break out of grid columns */
        .metrics-grid-container > *:not([class*="col-span"]) {
            grid-column: span 1 !important;
        }
        
        /* Ensure heading spans all columns */
        .metrics-grid-container > h4[class*="col-span-full"],
        .metrics-grid-container > h4.w-full {
            grid-column: 1 / -1 !important;
        }
        
        /* Ensure card content doesn't cause expansion */
        .metrics-grid-container > * > * {
            max-width: 100% !important;
            box-sizing: border-box !important;
        }
        
        /* Ensure all nested content respects grid constraints */
        .metrics-grid-container > * * {
            min-width: 0 !important;
            max-width: 100% !important;
        }
        
        /* Specifically fix truncate in grid context */
        .metrics-grid-container .truncate {
            min-width: 0 !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
            white-space: nowrap !important;
        }
        
        @media (min-width: 768px) {
            .metrics-grid-container {
                grid-template-columns: repeat(2, minmax(0, 1fr)) !important;
            }
        }
        
        /* Manual widescreen toggle (Compare All) */
        .metrics-grid-container.wide {
            grid-template-columns: repeat(4, minmax(0, 1fr)) !important;
        }
        
        /* Optional: ensure children stretch to equal heights */
        .metric-card {
            min-height: 380px;
            display: flex;
            flex-direction: column;
        }
        
        /* Ensure parent containers don't cause overflow */
        #competitive-dashboard {
            width: 100% !important;
            max-width: 100% !important;
            box-sizing: border-box !important;
        }
        
        #raw-wrapper {
            width: 100% !important;
            max-width: 100% !important;
            box-sizing: border-box !important;
            overflow-x: hidden !important;
        }
        
        #results-container {
            overflow-x: hidden !important;
        }
        
        /* Override any Tailwind classes that might interfere */
        .metrics-grid-container.grid {
            display: grid !important;
        }
        
        /* Force grid behavior even if other classes are present */
        div.metrics-grid-container {
            display: grid !important;
        }
        
        /* Specific fix for Keyword Targeting Analysis grid - 2 columns max */
        #keyword-metrics-grid.metrics-grid-container {
            display: grid !important;
            grid-template-columns: repeat(1, minmax(0, 1fr)) !important;
            width: 100% !important;
            gap: 1rem !important;
        }
        
        @media (min-width: 768px) {
            #keyword-metrics-grid.metrics-grid-container {
                grid-template-columns: repeat(2, minmax(0, 1fr)) !important;
            }
        }
        
        /* Override general .metrics-grid-container > * rules for keyword-metrics-grid children */
        #keyword-metrics-grid.metrics-grid-container > div {
            grid-column: span 1 !important;
            min-width: 0 !important;
            max-width: 100% !important;
            width: 100% !important;
            box-sizing: border-box !important;
            overflow: hidden !important;
        }
        
        /* Ensure metric-card inside keyword-metrics-grid respects grid cell */
        #keyword-metrics-grid .metric-card {
            width: 100% !important;
            max-width: 100% !important;
        }
        
        /* Specific fix for Individual URL Summaries grid - same as Keyword Targeting Analysis (2 columns) */
        #url-metrics-grid {
            display: grid !important;
            grid-template-columns: repeat(1, minmax(0, 1fr)) !important;
            width: 100% !important;
            gap: 1rem !important;
        }
        
        @media (min-width: 768px) {
            #url-metrics-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr)) !important;
            }
        }
        
        #url-metrics-grid > h4 {
            grid-column: 1 / -1 !important;
        }
        
        #url-metrics-grid > div {
            grid-column: span 1 !important;
            min-width: 0 !important;
            max-width: 100% !important;
            width: 100% !important;
            box-sizing: border-box !important;
            overflow: hidden !important;
            word-wrap: break-word !important;
            word-break: break-word !important;
        }
        
        /* Force all content inside URL boxes to respect grid constraints */
        #url-metrics-grid > div > * {
            max-width: 100% !important;
            min-width: 0 !important;
            box-sizing: border-box !important;
        }
        
        /* Ensure SVG charts don't break layout */
        #url-metrics-grid > div svg {
            max-width: 100% !important;
            height: auto !important;
        }
        
        /* Ensure all text content wraps */
        #url-metrics-grid > div p,
        #url-metrics-grid > div div {
            word-wrap: break-word !important;
            overflow-wrap: break-word !important;
            max-width: 100% !important;
        }
        
        /* Specifically fix ranking keywords to prevent grid breakage */
        #url-metrics-grid > div .break-words {
            word-break: break-word !important;
            overflow-wrap: anywhere !important;
            hyphens: auto !important;
        }
        
        /* Ensure ranking keywords container doesn't expand */
        #url-metrics-grid > div > div > div.space-y-1 {
            min-width: 0 !important;
            max-width: 100% !important;
            overflow: hidden !important;
        }
        
        /* Modern UI Enhancements */
        select {
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
            background-position: right 0.75rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
        
        select:focus {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%230284c7' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
        }
        
        .dark select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%2394a3b8' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
        }
        
        .dark select:focus {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%2338bdf8' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
        }
        
        /* Smooth transitions for all interactive elements */
        input, select, button, textarea {
            transition: all 0.2s ease;
        }
        
        /* Better focus states */
        input:focus, select:focus, textarea:focus {
            transform: translateY(-1px);
        }
        
        /* Subtle hover effects for cards */
        section[aria-labelledby] {
            transition: all 0.2s ease;
        }
        
        /* Improved button states */
        button:not(:disabled):hover {
            transform: translateY(-1px);
        }
        
        button:not(:disabled):active {
            transform: translateY(0);
        }
        
        /* Better spacing for form elements */
        .input-section label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        
        /* Modern card hover effect */
        .bg-\[var\(--bg-container\)\] {
            transition: box-shadow 0.2s ease, transform 0.2s ease;
        }
        
        .bg-\[var\(--bg-container\)\]:hover {
            transform: translateY(-1px);
        }
        
        /* Loading skeleton states */
        .skeleton {
            background: linear-gradient(90deg, var(--bg-input) 25%, var(--bg-input-secondary) 50%, var(--bg-input) 75%);
            background-size: 200% 100%;
            animation: loading 1.5s ease-in-out infinite;
            border-radius: 0.5rem;
        }
        
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        .skeleton-text {
            height: 1rem;
            margin-bottom: 0.5rem;
        }
        
        .skeleton-title {
            height: 1.5rem;
            width: 60%;
            margin-bottom: 1rem;
        }
        
        .skeleton-button {
            height: 2.5rem;
            width: 120px;
            border-radius: 0.5rem;
        }
        
        /* Theme toggle button styles */
        #theme-toggle {
            position: relative;
        }
        
        #theme-toggle:hover {
            transform: rotate(15deg);
        }
        
        /* Improved button styles in results */
        #results-container button {
            transition: all 0.2s ease;
        }
        
        #results-container button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        #results-container button:active {
            transform: translateY(0);
        }
        
        /* Fix CCI filter button hover states */
        .cci-filter-btn.text-white {
            background-color: var(--text-accent) !important;
            color: white !important;
        }
        
        .cci-filter-btn.text-white:hover {
            background-color: var(--text-accent-hover) !important;
            color: white !important;
            opacity: 0.9;
        }
        
        .cci-filter-btn:not(.text-white):hover {
            background-color: var(--bg-container) !important;
            color: var(--text-primary) !important;
        }
        
        /* Ensure primary intent column shows full text on hover */
        .tabulator .tabulator-cell[title] {
            cursor: help;
        }
        
        .tabulator .tabulator-cell .truncate {
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
    </style>
</head>
<body data-proxy="https://mozapi-proxy-server.vercel.app/api/getMozData" class="transition-colors duration-300 css-loading">

    <div class="w-full max-w-4xl mx-auto bg-[var(--bg-container-translucent)] backdrop-blur-sm rounded-2xl shadow-2xl p-6 md:p-8 border border-[var(--border-primary)] my-8">
        
        <header class="relative text-center mb-8 pb-6 border-b border-[var(--border-primary)] bg-gradient-to-br from-[var(--bg-container)] via-[var(--bg-container)] to-[var(--bg-input)] rounded-t-2xl -mt-6 -mx-6 md:-mx-8 pt-6 px-6 md:px-8">
            <div class="flex items-center justify-between mb-4">
                <div class="flex-1"></div>
                <div class="flex-1 text-center">
                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Moz_logo.svg/177px-Moz_logo.svg.png" alt="Moz Logo" class="mx-auto h-12 opacity-90" id="moz-logo" loading="lazy" decoding="async" width="177" height="48">
                </div>
                <div class="flex-1 flex justify-end">
                    <button id="theme-toggle" class="p-2 rounded-lg bg-[var(--bg-input)] hover:bg-[var(--bg-input-secondary)] border border-[var(--border-primary)] transition-all duration-200 hover:scale-110 active:scale-95" aria-label="Toggle theme" title="Switch theme">
                        <span id="theme-icon" class="text-xl">üåì</span>
                    </button>
                </div>
            </div>
            <h1 class="text-3xl md:text-4xl font-bold text-[var(--text-heading)] mb-2 tracking-tight">Advanced Moz API Tool</h1>
            <p class="text-[var(--text-secondary)] text-sm md:text-base">Connect to the Moz API and analyze SEO data with ease</p>
        </header>
        
        <section class="mb-5 bg-[var(--bg-container)] p-5 rounded-xl border border-[var(--border-primary)] shadow-sm hover:shadow-md transition-shadow duration-200" aria-labelledby="api-key-heading">
            <h2 id="api-key-heading" class="flex items-center gap-2 text-sm font-semibold text-[var(--text-primary)] mb-3 uppercase tracking-wide">
                <span class="text-base">üîë</span> Moz API Key
            </h2>
            <div id="apiKeyDisplay" class="hidden items-center justify-between" role="status" aria-live="polite">
                <span id="apiKeyText" class="text-[var(--text-secondary)] font-mono"></span>
                <button id="editApiKeyBtn" class="text-sm text-[var(--text-accent)] hover:text-[var(--text-accent-hover)] font-semibold" aria-label="Edit API key">Edit</button>
            </div>
            <div id="apiKeyInputArea" class="flex items-center gap-3">
                <label for="apiKeyInput" class="sr-only">Enter your Moz API key</label>
                <input type="password" id="apiKeyInput" class="flex-1 bg-[var(--bg-input)] border border-[var(--border-primary)] rounded-lg px-4 py-2.5 text-[var(--text-primary)] placeholder-[var(--text-secondary)] focus:outline-none focus:ring-2 focus:ring-[var(--text-accent)] focus:border-transparent transition-all duration-200" placeholder="mozscape-1234abcd..." autocomplete="off" aria-describedby="api-key-help">
                <button type="button" id="saveApiKeyBtn" class="bg-[var(--btn-primary-bg)] hover:bg-[var(--btn-primary-hover)] text-white font-semibold px-5 py-2.5 text-sm rounded-lg transition-all duration-200 hover:scale-105 active:scale-95 shadow-sm hover:shadow-md btn-inverted-text" aria-label="Save API key">Save</button>
            </div>
            <div id="api-key-help" class="sr-only">Enter your Moz API key to access the API services</div>
            <!-- Quota Display Area -->
            <div id="quota-display" class="hidden mt-3 text-sm text-[var(--text-secondary)]" role="status" aria-live="polite">
                <span id="quota-text"></span>
            </div>
        </section>

        <section class="mb-5 bg-[var(--bg-container)] p-5 rounded-xl border border-[var(--border-primary)] shadow-sm hover:shadow-md transition-shadow duration-200" aria-labelledby="openai-api-key-heading">
            <h2 id="openai-api-key-heading" class="flex items-center gap-2 text-sm font-semibold text-[var(--text-primary)] mb-3 uppercase tracking-wide">
                <span class="text-base">ü§ñ</span> OpenAI API Key
            </h2>
            <div id="openaiApiKeyDisplay" class="hidden items-center justify-between" role="status" aria-live="polite">
                <span id="openaiApiKeyText" class="text-[var(--text-secondary)] font-mono"></span>
                <button id="editOpenaiApiKeyBtn" class="text-sm text-[var(--text-accent)] hover:text-[var(--text-accent-hover)] font-semibold" aria-label="Edit OpenAI API key">Edit</button>
            </div>
            <div id="openaiApiKeyInputArea" class="flex items-center gap-3">
                <label for="openaiApiKeyInput" class="sr-only">Enter your OpenAI API key</label>
                <input type="password" id="openaiApiKeyInput" class="flex-1 bg-[var(--bg-input)] border border-[var(--border-primary)] rounded-lg px-4 py-2.5 text-[var(--text-primary)] placeholder-[var(--text-secondary)] focus:outline-none focus:ring-2 focus:ring-[var(--text-accent)] focus:border-transparent transition-all duration-200" placeholder="sk-..." autocomplete="off" aria-describedby="openai-api-key-help">
                <button type="button" id="saveOpenaiApiKeyBtn" class="bg-[var(--btn-primary-bg)] hover:bg-[var(--btn-primary-hover)] text-white font-semibold px-5 py-2.5 text-sm rounded-lg transition-all duration-200 hover:scale-105 active:scale-95 shadow-sm hover:shadow-md btn-inverted-text" aria-label="Save OpenAI API key">Save</button>
            </div>
            <div id="openai-api-key-help" class="sr-only">Enter your OpenAI API key for Content Cluster Analysis</div>
            <p class="text-xs text-[var(--text-secondary)] mt-2">Required for Content Cluster Endpoints. Get your key from the <a href="https://platform.openai.com/api-keys" target="_blank" rel="noopener" class="hover:text-[var(--text-accent-hover)] transition text-[var(--text-accent)]">OpenAI Platform</a></p>
        </section>

        <section aria-labelledby="method-heading" class="mb-6">
            <label for="methodSelector" id="method-heading" class="flex items-center gap-2 text-sm font-semibold text-[var(--text-primary)] mb-3 uppercase tracking-wide">
                <span class="text-base">‚öôÔ∏è</span> API Method
            </label>
            <select id="methodSelector" class="w-full bg-[var(--bg-container)] border border-[var(--border-primary)] rounded-lg px-4 py-3 text-[var(--text-primary)] focus:outline-none focus:ring-2 focus:ring-[var(--text-accent)] focus:border-transparent transition-all duration-200 shadow-sm hover:shadow-md cursor-pointer" aria-describedby="method-help">
                <option value="" disabled selected>-- Select a Method --</option>
                <optgroup label="Keyword Research">
                    <option value="searchIntent">Fetch Search Intent</option>
                    <option value="keywordMetrics">Fetch Keyword Metrics</option>
                    <option value="relatedKeywords">List Related Keywords</option>
                </optgroup>
                <optgroup label="Competitive Research">
                    <option value="rankingKeywords">List Ranking Keywords</option>
                    <option value="keywordCount">Count Ranking Keywords</option>
                    <option value="topPages">List Top Pages</option>
                </optgroup>
                <optgroup label="Multi-Endpoint [Beta]">
                    <option value="competitiveAnalysis">Competitive Analysis</option>
                    <option value="keywordTargetingAnalysis">Keyword Targeting Analysis</option>
                    <option value="contentClusterAnalysis">Content Cluster Analysis</option>
                    <option value="contentClustersIdentification">Content Clusters Identification</option>
                </optgroup>
                <optgroup label="Website Research">
                    <option value="siteMetrics">Fetch Site Metrics</option>
                    <option value="brandAuthority">Fetch Brand Authority</option>
                </optgroup>
                <optgroup label="Link Building Research">
                    <option value="anchorText">Get Anchor Texts Lists</option>
                    <option value="linkingDomains">List Linking Domains</option>
                    <option value="recentlyGainedLinks">List Recently Gained Links</option>
                    <option value="recentlyLostLinks">List Recently Lost Links</option>
                    <option value="linkIntersect">Fetch Link Intersects</option>
                    <option value="listLinks">List Links</option>
                    <option value="filterLinksByAnchor">Filter Links by Anchor Text</option>
                    <option value="filterLinksByDomain">Filter Links by Domain</option>
                </optgroup>
                <optgroup label="Link Checks">
                    <option value="finalRedirect">Get Final Redirect Target</option>
                    <option value="linkStatus">Get Link Status</option>
                </optgroup>
            </select>
            <div id="method-help" class="sr-only">Choose the Moz API method you want to use</div>
        </section>

        <form id="api-form" aria-label="API request form">
             <div id="inputsContainer" class="mt-4" role="region" aria-live="polite">
                <fieldset id="siteMetricsInputs" class="input-section space-y-4"><legend class="sr-only">Site Metrics Inputs</legend></fieldset>
                <fieldset id="keywordMetricsInputs" class="input-section space-y-4"><legend class="sr-only">Keyword Metrics Inputs</legend></fieldset>
                <fieldset id="brandAuthorityInputs" class="input-section space-y-4"><legend class="sr-only">Brand Authority Inputs</legend></fieldset>
                <fieldset id="searchIntentInputs" class="input-section space-y-4"><legend class="sr-only">Search Intent Inputs</legend></fieldset>
                <fieldset id="rankingKeywordsInputs" class="input-section space-y-4"><legend class="sr-only">Ranking Keywords Inputs</legend></fieldset>
                <fieldset id="relatedKeywordsInputs" class="input-section space-y-4"><legend class="sr-only">Related Keywords Inputs</legend></fieldset>
                <fieldset id="keywordCountInputs" class="input-section space-y-4"><legend class="sr-only">Keyword Count Inputs</legend></fieldset>
                <fieldset id="anchorTextInputs" class="input-section space-y-4"><legend class="sr-only">Anchor Text Inputs</legend></fieldset>
                <fieldset id="recentlyGainedLinksInputs" class="input-section space-y-4"><legend class="sr-only">Recently Gained Links Inputs</legend></fieldset>
                <fieldset id="recentlyLostLinksInputs" class="input-section space-y-4"><legend class="sr-only">Recently Lost Links Inputs</legend></fieldset>
                <fieldset id="linkingDomainsInputs" class="input-section space-y-4"><legend class="sr-only">Linking Domains Inputs</legend></fieldset>
                <fieldset id="finalRedirectInputs" class="input-section space-y-4"><legend class="sr-only">Final Redirect Inputs</legend></fieldset>
                <fieldset id="topPagesInputs" class="input-section space-y-4"><legend class="sr-only">Top Pages Inputs</legend></fieldset>
                <fieldset id="linkIntersectInputs" class="input-section space-y-4"><legend class="sr-only">Link Intersect Inputs</legend></fieldset>
                <fieldset id="listLinksInputs" class="input-section space-y-4"><legend class="sr-only">List Links Inputs</legend></fieldset>
                <fieldset id="linkStatusInputs" class="input-section space-y-4"><legend class="sr-only">Link Status Inputs</legend></fieldset>
                <fieldset id="filterLinksByAnchorInputs" class="input-section space-y-4"><legend class="sr-only">Filter Links by Anchor Inputs</legend></fieldset>
                <fieldset id="filterLinksByDomainInputs" class="input-section space-y-4"><legend class="sr-only">Filter Links by Domain Inputs</legend></fieldset>
                <fieldset id="competitiveAnalysisInputs" class="input-section space-y-4"><legend class="sr-only">Competitive Analysis Inputs</legend></fieldset>
                <fieldset id="keywordTargetingAnalysisInputs" class="input-section space-y-4"><legend class="sr-only">Keyword Targeting Analysis Inputs</legend></fieldset>
                <fieldset id="contentClusterAnalysisInputs" class="input-section space-y-4"><legend class="sr-only">Content Cluster Analysis Inputs</legend></fieldset>
                <fieldset id="contentClustersIdentificationInputs" class="input-section space-y-4"><legend class="sr-only">Content Clusters Identification Inputs</legend></fieldset>
            </div>
            <div class="mt-8 text-center">
                <div class="flex flex-col sm:flex-row items-center justify-center gap-3">
                    <button type="submit" id="submit-btn" class="bg-[var(--btn-primary-bg)] hover:bg-[var(--btn-primary-hover)] text-white font-bold px-8 py-3.5 rounded-lg transition-all duration-200 flex items-center justify-center w-full md:w-auto md:min-w-[200px] disabled:bg-[var(--bg-disabled)] disabled:cursor-not-allowed btn-inverted-text hover:scale-105 active:scale-95 shadow-lg hover:shadow-xl" aria-describedby="submit-help">
                        <span class="mr-2">‚ñ∂</span> Run Request
                    </button>
                    <button id="history-btn" type="button" class="bg-[var(--btn-copy-bg)] hover:bg-[var(--btn-copy-hover)] text-white font-bold px-8 py-3.5 rounded-lg transition-all duration-200 btn-inverted-text hover:scale-105 active:scale-95 shadow-md hover:shadow-lg" aria-label="View recent API calls">
                        üìã Recent API Calls
                    </button>
                    <button id="saved-results-btn" type="button" class="bg-[var(--btn-export-bg)] hover:bg-[var(--btn-export-hover)] text-white font-bold px-8 py-3.5 rounded-lg transition-all duration-200 btn-inverted-text hover:scale-105 active:scale-95 shadow-md hover:shadow-lg" aria-label="View saved results">
                        üíæ Saved Results
                    </button>
                </div>
                <div id="submit-help" class="sr-only">Submit your API request with the selected method and parameters</div>
            </div>
        </form>

        <section id="status-container" class="mt-8" aria-live="polite">
            <div id="error-message" role="alert" class="hidden bg-[var(--error-bg)] border-l-4 border-[var(--error-border)] text-[var(--text-error)] px-5 py-4 rounded-lg shadow-md flex items-start gap-3">
                <span class="text-2xl flex-shrink-0">‚ö†Ô∏è</span>
                <div class="flex-1 font-medium"></div>
            </div>
            <div id="results-container" class="hidden bg-[var(--bg-container)] p-5 md:p-7 rounded-xl border border-[var(--border-primary)] shadow-lg" role="region" aria-labelledby="results-heading">
                <div class="flex flex-col sm:flex-row justify-between items-start mb-5 gap-4 pb-4 border-b border-[var(--border-primary)]">
                    <h2 id="results-heading" class="flex items-center gap-2 text-xl md:text-2xl font-bold text-[var(--text-heading)]">
                        <span class="text-2xl">üìä</span> API Results
                    </h2>
                    <div class="flex items-center gap-2 flex-wrap justify-end" role="toolbar" aria-label="Results actions">
                        <button id="view-data-btn" class="bg-[var(--btn-view-data-bg)] hover:bg-[var(--btn-view-data-hover)] text-white font-semibold px-4 py-2 text-sm rounded-md transition duration-300 btn-inverted-text" aria-label="Toggle between table and JSON view">View Table</button>
                        <button id="filter-btn" class="bg-[var(--btn-view-data-bg)] hover:bg-[var(--btn-view-data-hover)] text-white font-semibold px-4 py-2 text-sm rounded-md transition duration-300 btn-inverted-text hidden" aria-label="Filter table data">Filter</button>
                        <button id="copy-json-btn" class="bg-[var(--btn-copy-bg)] hover:bg-[var(--btn-copy-hover)] text-white font-semibold px-4 py-2 text-sm rounded-md transition duration-300 btn-inverted-text" aria-label="Copy JSON data to clipboard">Copy JSON</button>
                        <button id="export-btn" class="bg-[var(--btn-export-bg)] hover:bg-[var(--btn-export-hover)] text-white font-semibold px-4 py-2 text-sm rounded-md transition duration-300 btn-inverted-text" aria-label="Export data as CSV file">Export to CSV</button>
                        <button id="export-pdf-btn" class="bg-[var(--btn-export-bg)] hover:bg-[var(--btn-export-hover)] text-white font-semibold px-4 py-2 text-sm rounded-md transition duration-300 btn-inverted-text hidden" aria-label="Export dashboard as PDF">Export to PDF</button>
                        <button id="save-results-btn" class="bg-[var(--btn-export-bg)] hover:bg-[var(--btn-export-hover)] text-white font-semibold px-4 py-2 text-sm rounded-md transition duration-300 btn-inverted-text hidden" aria-label="Save results for later reload">üíæ Save Results</button>
                        <button id="clear-data-btn" class="bg-[var(--btn-clear-bg)] hover:bg-[var(--btn-clear-hover)] text-white font-semibold px-4 py-2 text-sm rounded-md transition duration-300 btn-inverted-text" aria-label="Clear results data">Clear Data</button>
                    </div>
                </div>
                <div id="active-filters-container" class="hidden mb-4 space-x-2" role="status" aria-live="polite"></div>
                <div id="raw-wrapper">
                    <pre class="whitespace-pre-wrap break-all text-sm bg-[var(--bg-code)] text-[var(--text-primary)] p-4 rounded-lg" role="region" aria-label="Raw JSON data"><code></code></pre>
                </div>
                <div id="table-wrapper" class="hidden overflow-x-auto" role="region" aria-label="Data table">
                    <div id="results-table"></div>
                </div>
            </div>
        </section>

        <footer class="text-center text-[var(--text-secondary)] text-sm mt-8 border-t border-[var(--border-primary)] pt-6">
            <div class="mb-4 flex justify-center items-center gap-2" role="toolbar" aria-label="Theme selection">
                <button data-theme="light" class="theme-btn p-2 rounded-lg" aria-label="Switch to light theme">Light</button>
                <button data-theme="dark" class="theme-btn p-2 rounded-lg" aria-label="Switch to dark theme">Dark</button>
                <button data-theme="retro" class="theme-btn p-2 rounded-lg" aria-label="Switch to retro theme">Retro</button>
                <button data-theme="high-contrast" class="theme-btn p-2 rounded-lg" aria-label="Switch to high contrast theme">High Contrast</button>
            </div>
            <p>&copy; Jonathan Berthold 2025</p>
            <nav class="mt-2 space-x-4" aria-label="External links">
                <a href="https://moz.com/api/dashboard" target="_blank" rel="noopener" class="hover:text-[var(--text-accent-hover)] transition text-[var(--text-accent)]">API Dashboard</a>
                <span class="text-[var(--text-secondary)]" aria-hidden="true">|</span>
                <a href="https://moz.com/products/api/keys" target="_blank" rel="noopener" class="hover:text-[var(--text-accent-hover)] transition text-[var(--text-accent)]">Get Moz API Key</a>
                <span class="text-[var(--text-secondary)]" aria-hidden="true">|</span>
                 <a href="https://moz.com/api/docs/welcome" target="_blank" rel="noopener" class="hover:text-[var(--text-accent-hover)] transition text-[var(--text-accent)]">API Docs</a>
                <span class="text-[var(--text-secondary)]" aria-hidden="true">|</span>
                <button id="readme-btn" class="hover:text-[var(--text-accent-hover)] transition text-[var(--text-accent)]" aria-label="Open help documentation">Read Me</button>
            </nav>
        </footer>

    </div>

    <!-- Modals -->
    <div id="readme-modal" class="hidden fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4" role="dialog" aria-labelledby="readme-modal-title" aria-modal="true">
        <div class="bg-[var(--bg-container)] border border-[var(--border-primary)] w-full max-w-3xl max-h-[90vh] rounded-2xl shadow-2xl flex flex-col">
            <div class="flex justify-between items-center p-4 border-b border-[var(--border-primary)]">
                <h2 id="readme-modal-title" class="text-lg font-semibold text-[var(--text-primary)]">Read Me / Help</h2>
                <button id="close-readme-btn" class="text-[var(--text-secondary)] hover:text-[var(--text-primary)]" aria-label="Close help dialog">&times;</button>
            </div>
            <div id="readme-modal-content" class="p-6 overflow-y-auto"></div>
        </div>
    </div>
     <div id="filter-modal" class="hidden fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4" role="dialog" aria-labelledby="filter-modal-title" aria-modal="true">
        <div class="bg-[var(--bg-container)] border border-[var(--border-primary)] w-full max-w-4xl rounded-2xl shadow-2xl flex flex-col max-h-[90vh]">
            <div class="flex justify-between items-center p-4 border-b border-[var(--border-primary)]">
                <h2 id="filter-modal-title" class="text-lg font-semibold text-[var(--text-primary)]">Filter Data</h2>
                <button id="close-filter-btn" class="text-[var(--text-secondary)] hover:text-[var(--text-primary)]" aria-label="Close filter dialog">&times;</button>
            </div>
            <div id="filter-fields-container" class="p-6 overflow-y-auto space-y-4"></div>
            <div class="p-4 border-t border-[var(--border-primary)] flex justify-end gap-2">
                <button id="cancel-filter-btn" class="bg-[var(--bg-input-secondary)] hover:bg-[var(--bg-disabled)] text-[var(--text-primary)] font-semibold px-4 py-2 text-sm rounded-md transition">Cancel</button>
                <button id="apply-filter-btn" class="bg-[var(--btn-primary-bg)] hover:bg-[var(--btn-primary-hover)] text-white font-semibold px-4 py-2 text-sm rounded-md transition btn-inverted-text">Apply</button>
            </div>
        </div>
    </div>

    <!-- History Modal -->
    <div id="history-modal" class="hidden fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4" role="dialog" aria-labelledby="history-modal-title" aria-modal="true">
        <div class="bg-[var(--bg-container)] border border-[var(--border-primary)] w-full max-w-4xl max-h-[90vh] rounded-2xl shadow-2xl flex flex-col">
            <div class="flex justify-between items-center p-4 border-b border-[var(--border-primary)]">
                    <h2 id="history-modal-title" class="text-lg font-semibold text-[var(--text-primary)]">Recent API Calls</h2>
                <div class="flex items-center gap-2">
                    <button id="export-history-btn" class="bg-[var(--btn-export-bg)] hover:bg-[var(--btn-export-hover)] text-white font-semibold px-3 py-1 text-sm rounded-md transition btn-inverted-text" aria-label="Export history">Export</button>
                    <button id="clear-history-btn" class="bg-[var(--btn-clear-bg)] hover:bg-[var(--btn-clear-hover)] text-white font-semibold px-3 py-1 text-sm rounded-md transition btn-inverted-text" aria-label="Clear all history">Clear All</button>
                    <button id="close-history-btn" class="text-[var(--text-secondary)] hover:text-[var(--text-primary)]" aria-label="Close history dialog">&times;</button>
                </div>
            </div>
            <div class="p-4 border-b border-[var(--border-primary)]">
                <input type="text" id="history-search" placeholder="Search history by method, parameters, or date..." class="w-full bg-[var(--bg-input)] border border-[var(--border-secondary)] rounded-md px-3 py-2 text-[var(--text-primary)] placeholder-[var(--text-secondary)]">
            </div>
            <div id="history-list" class="p-4 overflow-y-auto flex-1">
                <div id="history-empty" class="text-center text-[var(--text-secondary)] py-8">No history found.</div>
            </div>
        </div>
    </div>
    
    <!-- Saved Results Modal -->
    <div id="saved-results-modal" class="hidden fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4" role="dialog" aria-labelledby="saved-results-modal-title" aria-modal="true">
        <div class="bg-[var(--bg-container)] border border-[var(--border-primary)] w-full max-w-4xl max-h-[90vh] rounded-2xl shadow-2xl flex flex-col">
            <div class="flex justify-between items-center p-4 border-b border-[var(--border-primary)]">
                <h2 id="saved-results-modal-title" class="text-lg font-semibold text-[var(--text-primary)]">üíæ Saved Results</h2>
                <div class="flex items-center gap-2">
                    <button id="export-saved-results-btn" class="bg-[var(--btn-export-bg)] hover:bg-[var(--btn-export-hover)] text-white font-semibold px-3 py-1 text-sm rounded-md transition btn-inverted-text" aria-label="Export saved results">Export</button>
                    <button id="clear-saved-results-btn" class="bg-[var(--btn-clear-bg)] hover:bg-[var(--btn-clear-hover)] text-white font-semibold px-3 py-1 text-sm rounded-md transition btn-inverted-text" aria-label="Clear all saved results">Clear All</button>
                    <button id="close-saved-results-btn" class="text-[var(--text-secondary)] hover:text-[var(--text-primary)]" aria-label="Close saved results dialog">&times;</button>
                </div>
            </div>
            <div class="p-4 border-b border-[var(--border-primary)]">
                <input type="text" id="saved-results-search" placeholder="Search saved results by method, URLs, or date..." class="w-full bg-[var(--bg-input)] border border-[var(--border-secondary)] rounded-md px-3 py-2 text-[var(--text-primary)] placeholder-[var(--text-secondary)]">
            </div>
            <div id="saved-results-list" class="p-4 overflow-y-auto flex-1">
                <div id="saved-results-empty" class="text-center text-[var(--text-secondary)] py-8">
                    <p>No saved results yet.</p>
                    <p class="text-sm mt-2">Save results from any endpoint to reload them later without making new API calls.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Performance optimization: Use requestAnimationFrame for DOM updates
        const raf = window.requestAnimationFrame || window.setTimeout;
        
        // Debounce function for better performance
        const debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };
        
        // Data processing utilities - centralized to eliminate duplication
        const DataProcessor = {
            na: 'N/A',
            
            snakeToTitleCase: (s) => s.replace(/^_*(.)|_+(.)/g, (s, c, d) => c ? c.toUpperCase() : ' ' + d.toUpperCase()),
            
            processLinkMetrics: (linkItem, query, originalParams) => {
                const baseInfo = { 'Query': query, 'Scope': originalParams.scope };
                const metrics = linkItem.site_metrics || {};
                const otherData = { ...linkItem };
                delete otherData.site_metrics;
                const combined = { ...baseInfo, ...metrics, ...otherData };
                const titleCased = {};
                for (const key in combined) {
                    titleCased[DataProcessor.snakeToTitleCase(key)] = combined[key];
                }
                return titleCased;
            },
            
            processResults: (results, method, originalParams) => {
                const rows = [];
                
                results.forEach((res, i) => {
                    let query;
                    if (['linkIntersect', 'linkStatus', 'filterLinksByDomain'].includes(method)) {
                        query = 'N/A';
                    } else {
                        query = (originalParams.targets || originalParams.keywords)[i] || DataProcessor.na;
                    }
                    
                    if (res.status !== 'success') {
                        rows.push({ Query: query, Status: `Error: ${res.reason || 'Unknown'}` });
                        return;
                    }
                    
                    // Process each method type
                    const methodProcessors = {
                        siteMetrics: () => {
                            const metrics = res.data.site_metrics || {};
                            const orderedMetrics = {'Page Authority': metrics.page_authority, 'Domain Authority': metrics.domain_authority, 'Spam Score': metrics.spam_score };
                            for(const key in metrics){
                                if(!['page_authority', 'domain_authority', 'spam_score'].includes(key)) {
                                    orderedMetrics[DataProcessor.snakeToTitleCase(key)] = metrics[key];
                                }
                            }
                            return {'Query': res.data.site_query?.query || query, 'Scope': res.data.site_query?.scope || DataProcessor.na, 'Original Query': res.data.site_query?.original_site_query?.query || query, ...orderedMetrics };
                        },
                        
                        brandAuthority: () => ({'Site Query': res.data.site_query?.query || DataProcessor.na, 'Scope': res.data.site_query?.scope || DataProcessor.na, 'Brand Authority Score': res.data.site_metrics?.brand_authority_score ?? DataProcessor.na, 'Original Query': res.data.site_query?.original_site_query?.query || query }),
                        
                        topPages: () => {
                            const pages = [];
                            (res.data.top_pages || []).forEach(page => {
                                const pageData = { 'Query': query, 'Scope': originalParams.scope, ...page };
                                const titleCased = {};
                                for(const key in pageData) { titleCased[DataProcessor.snakeToTitleCase(key)] = pageData[key]; }
                                pages.push(titleCased);
                            });
                            if (!res.data.top_pages || res.data.top_pages.length === 0) pages.push({ Query: query, Status: 'No top pages found' });
                            return pages;
                        },
                        
                        keywordMetrics: () => {
                            const metricTypeMap = { 'all': 'All Keyword Metrics', 'volume': 'Search Volume', 'difficulty': 'Difficulty', 'opportunity': 'Organic CTR', 'priority': 'Priority' };
                            return {'Keyword': res.data.serp_query?.keyword || query, 'API Call': metricTypeMap[originalParams.metricType] || originalParams.metricType, 'Locale': res.data.serp_query?.locale || DataProcessor.na, 'Device': res.data.serp_query?.device || DataProcessor.na, 'Engine': res.data.serp_query?.engine || DataProcessor.na, 'Volume': res.data.keyword_metrics?.volume ?? DataProcessor.na, 'Difficulty': res.data.keyword_metrics?.difficulty ?? DataProcessor.na, 'Opportunity CTR': res.data.keyword_metrics?.organic_ctr ?? DataProcessor.na, 'Priority': res.data.keyword_metrics?.priority ?? DataProcessor.na };
                        },
                        
                        searchIntent: () => {
                            const intentData = {};
                            (res.data.keyword_intent?.all_intents || []).forEach(intent => {
                                intentData[`${DataProcessor.snakeToTitleCase(intent.label)} Score`] = intent.score ?? DataProcessor.na;
                            });
                            return {'Keyword': res.data.serp_query?.keyword || query, 'Locale': res.data.serp_query?.locale || DataProcessor.na, 'Device': res.data.serp_query?.device || DataProcessor.na, 'Engine': res.data.serp_query?.engine || DataProcessor.na, 'Primary Intent': (res.data.keyword_intent?.primary_intents || []).join(', ') || DataProcessor.na, ...intentData };
                        },
                        
                        rankingKeywords: () => {
                            const keywords = [];
                            const baseInfo = { 'Query': query, 'Scope': originalParams.scope, 'Locale': originalParams.locale };
                            if(res.data.ranking_keywords?.length > 0){
                                res.data.ranking_keywords.forEach(kw => { keywords.push({ ...baseInfo, 'Keyword': kw.keyword, 'Ranking Page': kw.ranking_page, 'Rank Position': kw.rank_position, 'Difficulty': kw.difficulty, 'Volume': kw.volume }); });
                            } else { keywords.push({ ...baseInfo, Status: 'No ranking keywords found' }); }
                            return keywords;
                        },
                        
                        relatedKeywords: () => {
                            const suggestions = [];
                            const baseInfo = { 'Keyword': query, 'Locale': res.data.serp_query?.locale, 'Device': res.data.serp_query?.device, 'Engine': res.data.serp_query?.engine };
                            if(res.data.suggestions?.length > 0){
                                res.data.suggestions.forEach(sug => { suggestions.push({ ...baseInfo, 'Suggested Keyword': sug.keyword, 'Relevance': sug.relevance }); });
                            } else { suggestions.push({ ...baseInfo, Status: 'No suggestions found' }); }
                            return suggestions;
                        },
                        
                        keywordCount: () => {
                            const positions = res.data.ranking_keyword_count?.position || {};
                            const rankCounts = {};
                            for (let i = 1; i <= 50; i++) {
                                rankCounts[`Rank ${i} Count`] = positions[`rank_${i}`] ?? 0;
                            }
                            return {'Query': query, 'Scope': originalParams.scope, 'Locale': originalParams.locale, 'Total Ranking Count': res.data.ranking_keyword_count?.total ?? DataProcessor.na, ...rankCounts };
                        },
                        
                        anchorText: () => {
                            const anchorTexts = [];
                            const baseInfo = { 'Query': query, 'Scope': originalParams.scope };
                            if(res.data.anchor_texts?.length > 0){
                                res.data.anchor_texts.forEach(at => { anchorTexts.push({ ...baseInfo, 'Anchor Text': at.text, 'External Root Domains': at.external_root_domains, 'External Pages': at.external_pages }); });
                            } else { anchorTexts.push({ ...baseInfo, Status: 'No anchor texts found' }); }
                            return anchorTexts;
                        },
                        
                        recentlyGainedLinks: () => {
                            const links = [];
                            (res.data.gained_linking_domains || []).forEach(link => links.push(DataProcessor.processLinkMetrics(link, query, originalParams)));
                            if (!res.data.gained_linking_domains || res.data.gained_linking_domains.length === 0) links.push({ Query: query, Status: 'No recently gained links found' });
                            return links;
                        },
                        
                        recentlyLostLinks: () => {
                            const links = [];
                            (res.data.lost_linking_domains || []).forEach(link => links.push(DataProcessor.processLinkMetrics(link, query, originalParams)));
                            if (!res.data.lost_linking_domains || res.data.lost_linking_domains.length === 0) links.push({ Query: query, Status: 'No recently lost links found' });
                            return links;
                        },
                        
                        linkingDomains: () => {
                            const links = [];
                            (res.data.linking_domains || []).forEach(link => links.push(DataProcessor.processLinkMetrics(link, query, originalParams)));
                            if (!res.data.linking_domains || res.data.linking_domains.length === 0) links.push({ Query: query, Status: 'No linking domains found' });
                            return links;
                        },
                        
                        finalRedirect: () => ({ 'Query': query, 'Scope': originalParams.scope, 'Original Query': res.data.site_query?.original_site_query?.query || query, 'Destination': res.data.destination || 'No redirect found' }),
                        
                        linkIntersect: () => {
                            const intersectData = res.data.link_intersects || [];
                            if (intersectData.length === 0) {
                                return [{ Status: 'No intersecting links found' }];
                            } else {
                                const intersects = [];
                                const baseInfo = {
                                    'Linking To': (res.data.is_linking_to || []).map(t => t.query).join(', '),
                                    'Not Linking To': (res.data.not_linking_to || []).map(t => t.query).join(', '),
                                    'Minimum Matching Targets': res.data.options?.minimum_matching_targets || DataProcessor.na,
                                    'Scope': res.data.options?.scope || DataProcessor.na,
                                    'Sort': res.data.options?.sort || DataProcessor.na
                                };
                                intersectData.forEach(intersect => {
                                    (intersect.matching_source_pages || [{page: 'N/A', page_authority: 'N/A'}]).forEach(sourcePage => {
                                        intersects.push({
                                            ...baseInfo,
                                            'Intersecting Domain': intersect.page,
                                            'Intersecting Title': intersect.title,
                                            'Intersecting DA': intersect.domain_authority,
                                            'Intersecting Spam Score': intersect.spam_score,
                                            'Matching Target Indexes': (intersect.matching_target_indexes || []).join(', '),
                                            'Source Page': sourcePage.page,
                                            'Source PA': sourcePage.page_authority
                                        });
                                    });
                                });
                                return intersects;
                            }
                        },
                        
                        listLinks: () => {
                            const links = [];
                            (res.data.links || []).forEach(link => {
                                const sourceMetrics = link.source_site_metrics || {};
                                const targetMetrics = link.target_site_metrics || {};
                                const linkInfo = { ...link };
                                delete linkInfo.source_site_metrics;
                                delete linkInfo.target_site_metrics;

                                const row = {};
                                for (const key in sourceMetrics) row[`Source ${DataProcessor.snakeToTitleCase(key)}`] = sourceMetrics[key];
                                for (const key in targetMetrics) row[`Target ${DataProcessor.snakeToTitleCase(key)}`] = targetMetrics[key];
                                for (const key in linkInfo) row[DataProcessor.snakeToTitleCase(key)] = linkInfo[key];
                                links.push(row);
                            });
                            if (!res.data.links || res.data.links.length === 0) links.push({ Query: query, Status: 'No links found' });
                            return links;
                        },
                        
                        filterLinksByAnchor: () => {
                            const links = [];
                            (res.data.links || []).forEach(link => {
                                const sourceMetrics = link.source_site_metrics || {};
                                const targetMetrics = link.target_site_metrics || {};
                                const linkInfo = { ...link };
                                delete linkInfo.source_site_metrics;
                                delete linkInfo.target_site_metrics;

                                const row = {};
                                for (const key in sourceMetrics) row[`Source ${DataProcessor.snakeToTitleCase(key)}`] = sourceMetrics[key];
                                for (const key in targetMetrics) row[`Target ${DataProcessor.snakeToTitleCase(key)}`] = targetMetrics[key];
                                for (const key in linkInfo) row[DataProcessor.snakeToTitleCase(key)] = linkInfo[key];
                                links.push(row);
                            });
                            if (!res.data.links || res.data.links.length === 0) links.push({ Query: query, Status: 'No links found' });
                            return links;
                        },
                        filterLinksByDomain: () => {
                            const links = [];
                            (res.data.links || []).forEach(link => {
                                const sourceMetrics = link.source_site_metrics || {};
                                const targetMetrics = link.target_site_metrics || {};
                                const linkInfo = { ...link };
                                delete linkInfo.source_site_metrics;
                                delete linkInfo.target_site_metrics;

                                const row = {};
                                for (const key in sourceMetrics) row[`Source ${DataProcessor.snakeToTitleCase(key)}`] = sourceMetrics[key];
                                for (const key in targetMetrics) row[`Target ${DataProcessor.snakeToTitleCase(key)}`] = targetMetrics[key];
                                for (const key in linkInfo) row[DataProcessor.snakeToTitleCase(key)] = linkInfo[key];
                                links.push(row);
                            });
                            if (!res.data.links || res.data.links.length === 0) links.push({ Query: query, Status: 'No links found' });
                            return links;
                        },
                        
                        linkStatus: () => ({ 'Target Query': res.data.target_site_query?.query, 'Source Query': res.data.source_site_query?.query, 'Exists': res.data.exists })
                    };
                    
                    const processor = methodProcessors[method];
                    if (processor) {
                        const result = processor();
                        if (Array.isArray(result)) {
                            rows.push(...result);
                        } else {
                            rows.push(result);
                        }
                    }
                });
                
                return rows;
            }
        };
        
        // Performance monitoring
        const performanceMonitor = {
            startTime: performance.now(),
            mark: (name) => performance.mark(name),
            measure: (name, start, end) => performance.measure(name, start, end),
            logMetrics: () => {
                const loadTime = performance.now() - performanceMonitor.startTime;
                console.log(`Page load time: ${loadTime.toFixed(2)}ms`);
            }
        };
        
        // Service Worker registration for caching
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').catch(() => {
                    // Service worker registration failed, continue without caching
                });
            });
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            performanceMonitor.mark('dom-ready');
            
            // Handle CSS loading state to prevent FOUC
            const handleCSSLoad = () => {
                document.body.classList.remove('css-loading');
                document.body.classList.add('css-loaded');
            };
            
            // Ensure CSS is loaded before showing content
            if (document.readyState === 'loading') {
                document.addEventListener('readystatechange', () => {
                    if (document.readyState === 'interactive' || document.readyState === 'complete') {
                        handleCSSLoad();
                    }
                });
            } else {
                // CSS already loaded
                handleCSSLoad();
            }
            
            // Fallback: Show content after a short delay if CSS hasn't loaded
            setTimeout(handleCSSLoad, 100);
            
            let currentResultsData = null;
            let currentOriginalParams = null;
            let currentMethod = null;
            let inFlightRequest = null;
            let table = null;
            let currentFilters = [];

            const allDOMElements = {
                apiKeyDisplay: document.getElementById('apiKeyDisplay'), 
                apiKeyText: document.getElementById('apiKeyText'), 
                editApiKeyBtn: document.getElementById('editApiKeyBtn'), 
                apiKeyInputArea: document.getElementById('apiKeyInputArea'), 
                apiKeyInput: document.getElementById('apiKeyInput'), 
                saveApiKeyBtn: document.getElementById('saveApiKeyBtn'),
                openaiApiKeyDisplay: document.getElementById('openaiApiKeyDisplay'),
                openaiApiKeyText: document.getElementById('openaiApiKeyText'),
                editOpenaiApiKeyBtn: document.getElementById('editOpenaiApiKeyBtn'),
                openaiApiKeyInputArea: document.getElementById('openaiApiKeyInputArea'),
                openaiApiKeyInput: document.getElementById('openaiApiKeyInput'),
                saveOpenaiApiKeyBtn: document.getElementById('saveOpenaiApiKeyBtn'),
                readmeBtn: document.getElementById('readme-btn'), 
                readmeModal: document.getElementById('readme-modal'),
                readmeModalContent: document.getElementById('readme-modal-content'), 
                closeReadmeBtn: document.getElementById('close-readme-btn'), 
                themeBtns: document.querySelectorAll('.theme-btn'), 
                methodSelector: document.getElementById('methodSelector'), 
                form: document.getElementById('api-form'), 
                submitBtn: document.getElementById('submit-btn'),
                errorMessage: document.getElementById('error-message'), 
                resultsContainer: document.getElementById('results-container'), 
                rawWrapper: document.getElementById('raw-wrapper'),
                tableWrapper: document.getElementById('table-wrapper'),
                rawCode: document.querySelector('#raw-wrapper code'), 
                exportBtn: document.getElementById('export-btn'), 
                copyJsonBtn: document.getElementById('copy-json-btn'),
                viewDataBtn: document.getElementById('view-data-btn'),
                historyBtn: document.getElementById('history-btn'),
                clearDataBtn: document.getElementById('clear-data-btn'),
                filterBtn: document.getElementById('filter-btn'),
                filterModal: document.getElementById('filter-modal'),
                closeFilterBtn: document.getElementById('close-filter-btn'),
                cancelFilterBtn: document.getElementById('cancel-filter-btn'),
                filterFieldsContainer: document.getElementById('filter-fields-container'),
                applyFilterBtn: document.getElementById('apply-filter-btn'),
                activeFiltersContainer: document.getElementById('active-filters-container'),
                mozLogo: document.getElementById('moz-logo'),
                quotaDisplay: document.getElementById('quota-display'), 
                quotaText: document.getElementById('quota-text'),
                historyModal: document.getElementById('history-modal'),
                closeHistoryBtn: document.getElementById('close-history-btn'),
                historySearch: document.getElementById('history-search'),
                historyList: document.getElementById('history-list'),
                historyEmpty: document.getElementById('history-empty'),
                exportHistoryBtn: document.getElementById('export-history-btn'),
                clearHistoryBtn: document.getElementById('clear-history-btn'),
                exportPdfBtn: document.getElementById('export-pdf-btn'),
                savedResultsBtn: document.getElementById('saved-results-btn'),
                savedResultsModal: document.getElementById('saved-results-modal'),
                closeSavedResultsBtn: document.getElementById('close-saved-results-btn'),
                savedResultsSearch: document.getElementById('saved-results-search'),
                savedResultsList: document.getElementById('saved-results-list'),
                savedResultsEmpty: document.getElementById('saved-results-empty'),
                exportSavedResultsBtn: document.getElementById('export-saved-results-btn'),
                clearSavedResultsBtn: document.getElementById('clear-saved-results-btn'),
                saveResultsBtn: document.getElementById('save-results-btn')
            };

            const populateInputs = () => {
                const createLabel = (text) => `<label class="block text-sm font-medium text-[var(--text-secondary)]">${text}</label>`;
                const createSelect = (id, options) => `<select id="${id}" class="w-full bg-[var(--bg-input-secondary)] border-[var(--border-secondary)] rounded-md p-2 mt-1 text-[var(--text-primary)]">${options}</select>`;
                const createTextarea = (id, placeholder) => `<textarea id="${id}" rows="4" class="w-full bg-[var(--bg-input)] border border-[var(--border-secondary)] rounded-md p-2 mt-1 text-[var(--text-primary)] placeholder-[var(--text-secondary)]" placeholder="${placeholder}"></textarea>`;
                const createDescription = text => `<p class="text-sm text-[var(--text-secondary)]">${text}</p>`;
                const createNumberInput = (id, value, min, max, label) => createLabel(label) + `<input type="number" id="${id}" value="${value}" min="${min}" max="${max}" class="w-full bg-[var(--bg-input-secondary)] border-[var(--border-secondary)] rounded-md p-2 mt-1 text-[var(--text-primary)]">`;
                const createDateInput = (id) => `<input type="date" id="${id}" class="w-full bg-[var(--bg-input-secondary)] border-[var(--border-secondary)] rounded-md p-2 mt-1 text-[var(--text-primary)]">`;
                const createMultiSelect = (id, options) => `<select id="${id}" multiple class="w-full h-32 bg-[var(--bg-input-secondary)] border-[var(--border-secondary)] rounded-md p-2 mt-1 text-[var(--text-primary)]">${options}</select>`;
                
                const scopeOptions = `<option value="domain" selected>Domain</option><option value="subdomain">Subdomain</option><option value="subfolder">Subfolder</option><option value="url">URL</option>`;
                const limitedScopeOptions = `<option value="domain" selected>Domain</option><option value="subdomain">Subdomain</option><option value="url">URL</option>`;
                const localeOptions = `<option value="en-US" selected>en-US</option><option value="en-CA">en-CA</option><option value="en-GB">en-GB</option><option value="en-AU">en-AU</option>`;
                const keywordMetricOptions = `<option value="all" selected>All Metrics</option><option value="volume">Search Volume</option><option value="difficulty">Difficulty</option><option value="opportunity">Organic CTR</option><option value="priority">Priority</option>`;
                const deviceOptions = `<option value="desktop" selected>Desktop</option><option value="mobile_android">Mobile Android</option><option value="mobile_ios">Mobile iOS</option>`;
                const engineOptions = `<option value="google" selected>Google</option><option value="bing">Bing</option><option value="yahoo">Yahoo</option>`;
                const topPagesFilterOptions = `<option value="all" selected>All</option><option value="status_200">Status 200</option><option value="status_301">Status 301</option><option value="status_302">Status 302</option><option value="status_4xx">Status 4xx</option><option value="status_5xx">Status 5xx</option>`;
                const topPagesSortOptions = `<option value="page_authority" selected>Page Authority</option><option value="root_domains_to_page">Linking Root Domains</option><option value="external_pages_to_page">External Linking Pages</option>`;
                const listLinksFilterOptions = `<option value="external">external</option><option value="follow">follow</option><option value="nofollow">nofollow</option><option value="deleted">deleted</option><option value="not_deleted">not_deleted</option><option value="redirect">redirect</option><option value="not_redirect">not_redirect</option><option value="rel_canonical">rel_canonical</option><option value="not_rel_canonical">not_rel_canonical</option><option value="via_redirect">via_redirect</option><option value="not_via_redirect">not_via_redirect</option><option value="via_rel_canonical">via_rel_canonical</option><option value="not_via_rel_canonical">not_via_rel_canonical</option>`;
                const linkIntersectSortOptions = `<option value="matching_target_count" selected>Matching Target Count</option><option value="source_spam_score">Source Spam Score</option><option value="source_domain_authority">Source Domain Authority</option>`;
                const linkingDomainsSortOptions = `<option value="source_domain_authority" selected>Source Domain Authority</option><option value="source_link_propensity">Source Link Propensity</option><option value="source_spam_score">Source Spam Score</option>`;
                const linkingDomainsFilterOptions = `<option value="external">external</option><option value="follow">follow</option><option value="nofollow">nofollow</option><option value="deleted">deleted</option>`;
                const listLinksSortOptions = `<option value="source_page_authority" selected>Source Page Authority</option><option value="source_domain_authority">Source Domain Authority</option><option value="source_link_propensity">Source Link Propensity</option><option value="source_spam_score">Source Spam Score</option>`;
                const filterAnchorSortOptions = `<option value="source_page_authority" selected>Source Page Authority</option><option value="source_domain_authority">Source Domain Authority</option><option value="source_link_propensity">Source Link Propensity</option><option value="source_spam_score">Source Spam Score</option>`;
                const filterAnchorFilterOptions = `<option value="external">external</option><option value="follow">follow</option><option value="nofollow">nofollow</option><option value="deleted">deleted</option><option value="not_deleted">not_deleted</option><option value="redirect">redirect</option><option value="not_redirect">not_redirect</option><option value="rel_canonical">rel_canonical</option><option value="not_rel_canonical">not_rel_canonical</option><option value="via_redirect">via_redirect</option><option value="not_via_redirect">not_via_redirect</option><option value="via_rel_canonical">via_rel_canonical</option><option value="not_via_rel_canonical">not_via_rel_canonical</option>`;
                const filterDomainFilterOptions = `<option value="external">external</option><option value="follow">follow</option><option value="nofollow">nofollow</option><option value="deleted">deleted</option>`;

                const limitLabel = 'Number of Results (Default 25; Choose from 1 to 50)';
                const limitLabelLarge = 'Number of Results (Default 25; Choose from 1 to 500)';

                document.getElementById('siteMetricsInputs').innerHTML = createDescription('Get metrics like DA, PA, Spam Score, and link counts for URLs.') + createLabel('Scope') + createSelect('smScopeSelect', scopeOptions) + createLabel('Domains / URLs') + createTextarea('smUrlsInput', 'One per line or comma-separated (must include http/https)');
                document.getElementById('keywordMetricsInputs').innerHTML = createDescription('Get volume, difficulty, CTR, and priority for keywords.') + createLabel('Metric Type') + createSelect('kmMetricTypeSelect', keywordMetricOptions) + createLabel('Device') + createSelect('kmDeviceSelect', deviceOptions) + createLabel('Engine') + createSelect('kmEngineSelect', engineOptions) + createLabel('Locale') + createSelect('kmLocaleSelect', localeOptions) + createLabel('Keywords') + createTextarea('kmKeywordsInput', 'One per line or comma-separated');
                document.getElementById('brandAuthorityInputs').innerHTML = createDescription('Get the Brand Authority‚Ñ¢ score for a given site.') + createLabel('Domains / URLs') + createTextarea('baUrlsInput', 'One per line or comma-separated.');
                document.getElementById('searchIntentInputs').innerHTML = createDescription('Retrieve search intent scores for any keyword.') + createLabel('Locale') + createSelect('siLocaleSelect', localeOptions) + createLabel('Keywords') + createTextarea('siKeywordsInput', 'One per line or comma-separated.');
                document.getElementById('rankingKeywordsInputs').innerHTML = createDescription('List keywords for which a site ranks.') + createLabel('Scope') + createSelect('rkScopeSelect', scopeOptions) + createLabel('Locale') + createSelect('rkLocaleSelect', localeOptions) + createNumberInput('rkLimit', 25, 1, 500, limitLabelLarge) + createLabel('Domains / URLs') + createTextarea('rkUrlsInput', 'One per line or comma-separated.');
                document.getElementById('relatedKeywordsInputs').innerHTML = createDescription('Get a list of related keyword suggestions.') + createLabel('Locale') + createSelect('rlLocaleSelect', localeOptions) + createLabel('Keywords') + createTextarea('rlKeywordsInput', 'One per line or comma-separated.');
                document.getElementById('keywordCountInputs').innerHTML = createDescription('Count keywords for which a site ranks in the top 50.') + createLabel('Scope') + createSelect('kcScopeSelect', limitedScopeOptions) + createLabel('Locale') + createSelect('kcLocaleSelect', localeOptions) + createLabel('Domains / URLs') + createTextarea('kcUrlsInput', 'One per line or comma-separated.');
                document.getElementById('anchorTextInputs').innerHTML = createDescription('Get data about anchor text used to link to a specified site.') + createLabel('Scope') + createSelect('atScopeSelect', scopeOptions) + createNumberInput('atLimit', 25, 1, 50, limitLabel) + createLabel('Domains / URLs') + createTextarea('atUrlsInput', 'One per line or comma-separated.');
                document.getElementById('recentlyGainedLinksInputs').innerHTML = createDescription('Get external root domains that added new links to a target during the past 60 days.') + createLabel('Scope') + createSelect('rglScopeSelect', scopeOptions) + createNumberInput('rglLimit', 25, 1, 50, limitLabel) + createLabel('Begin Date (Optional)') + createDateInput('rglBeginDate') + createLabel('End Date (Optional)') + createDateInput('rglEndDate') + createLabel('Domains / URLs') + createTextarea('rglUrlsInput', 'One per line or comma-separated.');
                document.getElementById('recentlyLostLinksInputs').innerHTML = createDescription('Get root domains that removed links to a target during the past 60 days.') + createLabel('Scope') + createSelect('rllScopeSelect', scopeOptions) + createNumberInput('rllLimit', 25, 1, 50, limitLabel) + createLabel('Begin Date (Optional)') + createDateInput('rllBeginDate') + createLabel('End Date (Optional)') + createDateInput('rllEndDate') + createLabel('Domains / URLs') + createTextarea('rllUrlsInput', 'One per line or comma-separated.');
                document.getElementById('linkingDomainsInputs').innerHTML = createDescription('Get a list of linking root domains to a target.') + createLabel('Scope') + createSelect('ldScopeSelect', scopeOptions) + createLabel('Sort') + createSelect('ldSortSelect', linkingDomainsSortOptions) + createLabel('Filters') + createMultiSelect('ldFilterSelect', linkingDomainsFilterOptions) + createDescription('If providing multiple filters, "external" must be one of them.') + createNumberInput('ldLimit', 25, 1, 50, limitLabel) + createLabel('Domains / URLs') + createTextarea('ldUrlsInput', 'One per line or comma-separated.');
                document.getElementById('finalRedirectInputs').innerHTML = createDescription('See the final redirect target of a page.') + createLabel('Scope') + createSelect('frScopeSelect', scopeOptions) + createLabel('Domains / URLs') + createTextarea('frUrlsInput', 'One per line or comma-separated.');
                document.getElementById('topPagesInputs').innerHTML = createDescription('Return a list of the top pages on a target domain.') + createLabel('Scope') + createSelect('tpScopeSelect', scopeOptions) + createLabel('Filter') + createSelect('tpFilterSelect', topPagesFilterOptions) + createLabel('Sort') + createSelect('tpSortSelect', topPagesSortOptions) + createNumberInput('tpLimit', 25, 1, 50, limitLabel) + createLabel('Domains / URLs') + createTextarea('tpUrlsInput', 'One per line or comma-separated.');
                document.getElementById('linkIntersectInputs').innerHTML = createDescription('Find sites that link to some domains but not others.') + createLabel('Scope') + createSelect('liScopeSelect', scopeOptions) + createLabel('Sort') + createSelect('liSortSelect', linkIntersectSortOptions) + createNumberInput('liMinMatch', 1, 1, 6, 'Minimum Matching Targets') + createNumberInput('liLimit', 25, 1, 50, limitLabel) + createLabel('Linking To') + createTextarea('liIsLinkingTo', 'One per line...') + createLabel('NOT Linking To (Optional)') + createTextarea('liNotLinkingTo', 'One per line...');
                document.getElementById('listLinksInputs').innerHTML = createDescription('Get a list of links to a target.') + createLabel('Scope') + createSelect('llScopeSelect', scopeOptions) + createLabel('Sort') + createSelect('llSortSelect', listLinksSortOptions) + createLabel('Filters') + createMultiSelect('llFilterSelect', listLinksFilterOptions) + createDescription('If providing multiple filters, "external" must be one of them.') + createNumberInput('llLimit', 25, 1, 50, limitLabel) + createLabel('Domains / URLs') + createTextarea('llUrlsInput', 'One per line or comma-separated.');
                document.getElementById('linkStatusInputs').innerHTML = createDescription('Get the status of a link from a source to a target.') + createLabel('Target Scope') + createSelect('lsTargetScopeSelect', scopeOptions) + createLabel('Target URL') + createTextarea('lsTargetUrl', 'Target URL') + createLabel('Source Scope') + createSelect('lsSourceScopeSelect', scopeOptions) + createLabel('Source URL') + createTextarea('lsSourceUrl', 'Source URL');
                document.getElementById('filterLinksByAnchorInputs').innerHTML = createDescription('Get a list of links to a target where the anchor text exactly matches a string.') + createLabel('Scope') + createSelect('flaScopeSelect', scopeOptions) + createLabel('Anchor Text') + createTextarea('flaAnchorText', 'Enter exact anchor text...') + createLabel('Sort') + createSelect('flaSortSelect', filterAnchorSortOptions) + createLabel('Filters') + createMultiSelect('flaFilterSelect', filterAnchorFilterOptions) + createDescription('If providing multiple filters, "external" must be one of them.') + createNumberInput('flaLimit', 25, 1, 50, limitLabel) + createLabel('Domains / URLs') + createTextarea('flaUrlsInput', 'One per line or comma-separated.');
                document.getElementById('filterLinksByDomainInputs').innerHTML = createDescription('Find links pointing to a target only if they originate from a particular root domain.') + createLabel('Target Scope') + createSelect('fldTargetScopeSelect', scopeOptions) + createLabel('Target URLs') + createTextarea('fldTargetUrls', 'One per line...') + createLabel('Source Domain Scope') + createSelect('fldSourceScopeSelect', scopeOptions) + createLabel('Source Domain URLs') + createTextarea('fldSourceUrls', 'One per line...') + createLabel('Filters') + createMultiSelect('fldFilterSelect', filterDomainFilterOptions) + createDescription('If providing multiple filters, "external" must be one of them.') + createNumberInput('fldLimit', 25, 1, 50, limitLabel);
                document.getElementById('competitiveAnalysisInputs').innerHTML = 
                    '<div class="mb-4 p-3 bg-[var(--bg-input)] border border-[var(--border-primary)] rounded-lg">' +
                    '<label class="flex items-center gap-2 cursor-pointer">' +
                    '<input type="checkbox" id="caTestMode" class="w-4 h-4 text-[var(--text-accent)] bg-[var(--bg-input-secondary)] border-[var(--border-secondary)] rounded focus:ring-[var(--text-accent)]">' +
                    '<span class="text-sm font-semibold text-[var(--text-primary)]">üß™ Test Mode (Use sample data - No API calls)</span>' +
                    '</label>' +
                    '<p class="text-xs text-[var(--text-secondary)] mt-1 ml-6">Enable to preview the dashboard with sample data without consuming API credits.</p>' +
                    '</div>' +
                    createDescription('Compare your domain against up to 3 competitors. Analyzes Brand Authority, Domain Authority, Spam Score, Link Metrics HD Ranking Keywords for each domain.') + 
                    createLabel('Your Domain') + 
                    createTextarea('caYourDomain', 'Enter your domain (e.g., https://example.com)') + 
                    createLabel('Competitor Domains (up to 3)') + 
                    createTextarea('caCompetitors', 'Enter competitor domains, one per line (e.g., https://competitor1.com)') + 
                    createLabel('Locale') + 
                    createSelect('caLocaleSelect', localeOptions) + 
                    createNumberInput('caLimit', 25, 1, 500, 'Number of Ranking Keywords to Display (Default 25; Choose from 1 to 500)');
                document.getElementById('keywordTargetingAnalysisInputs').innerHTML = 
                    '<div class="mb-4 p-3 bg-[var(--bg-input)] border border-[var(--border-primary)] rounded-lg">' +
                    '<label class="flex items-center gap-2 cursor-pointer">' +
                    '<input type="checkbox" id="ktaTestMode" class="w-4 h-4 text-[var(--text-accent)] bg-[var(--bg-input-secondary)] border-[var(--border-secondary)] rounded focus:ring-[var(--text-accent)]">' +
                    '<span class="text-sm font-semibold text-[var(--text-primary)]">üß™ Test Mode (Use sample data - No API calls)</span>' +
                    '</label>' +
                    '<p class="text-xs text-[var(--text-secondary)] mt-1 ml-6">Enable to preview the dashboard with sample data without consuming API credits.</p>' +
                    '</div>' +
                    createDescription('Analyze a single URL: page-level metrics, ranking keywords with intent, intent mix, and top inbound anchor texts.') +
                    createLabel('URL (scope: URL only)') +
                    createTextarea('ktaUrl', 'Enter a single URL (e.g., https://example.com/page)') +
                    createLabel('Locale') +
                    createSelect('ktaLocaleSelect', localeOptions) +
                    createNumberInput('ktaLimit', 25, 1, 500, 'Number of Ranking Keywords to Analyze (Default 25; 1-500)');
                const modelOptions = `<option value="gpt-3.5-turbo">GPT-3.5 Turbo (Recommended - ~90% cheaper, good quality)</option><option value="gpt-4o-mini">GPT-4o mini (Fast, affordable, better quality)</option><option value="gpt-4o">GPT-4o (Best quality, more expensive)</option>`;
                document.getElementById('contentClusterAnalysisInputs').innerHTML = 
                    '<div class="mb-4 p-3 bg-[var(--bg-input)] border border-[var(--border-primary)] rounded-lg">' +
                    '<label class="flex items-center gap-2 cursor-pointer">' +
                    '<input type="checkbox" id="ccaTestMode" class="w-4 h-4 text-[var(--text-accent)] bg-[var(--bg-input-secondary)] border-[var(--border-secondary)] rounded focus:ring-[var(--text-accent)]">' +
                    '<span class="text-sm font-semibold text-[var(--text-primary)]">üß™ Test Mode (Use sample data - No API calls)</span>' +
                    '</label>' +
                    '<p class="text-xs text-[var(--text-secondary)] mt-1 ml-6">Enable to preview the dashboard with sample data without consuming API credits.</p>' +
                    '</div>' +
                    createDescription('Analyze content similarity across multiple URLs using semantic embeddings. Identifies content consolidation opportunities and keyword targeting gaps.') +
                    createLabel('OpenAI Model') +
                    createSelect('ccaModelSelect', modelOptions) +
                    createDescription('<strong>Model Selection:</strong> GPT-3.5 Turbo is recommended for most use cases (~90% cost savings). GPT-4o mini provides better quality at moderate cost. GPT-4o offers the best quality but is more expensive.') +
                    createLabel('Seed Topic') +
                    createTextarea('ccaSeedTopic', 'Enter the main topic/keyword to analyze pages against (e.g., "digital marketing")') +
                    createLabel('URLs') +
                    createTextarea('ccaUrls', 'Enter URLs to analyze, one per line (e.g., https://example.com/page1)') +
                    createLabel('Locale') +
                    createSelect('ccaLocaleSelect', localeOptions) +
                    createLabel('Similarity Threshold (Default 0.85; 0-1)') +
                    '<input type="number" id="ccaSimilarityThreshold" value="0.85" min="0" max="1" step="0.01" class="w-full bg-[var(--bg-input-secondary)] border-[var(--border-secondary)] rounded-md p-2 mt-1 text-[var(--text-primary)]">' +
                    createNumberInput('ccaLimit', 25, 1, 500, 'Number of Ranking Keywords to Analyze per URL (Default 25; 1-500)');
                document.getElementById('contentClustersIdentificationInputs').innerHTML = 
                    '<div class="mb-4 p-3 bg-[var(--bg-input)] border border-[var(--border-primary)] rounded-lg">' +
                    '<label class="flex items-center gap-2 cursor-pointer">' +
                    '<input type="checkbox" id="cciTestMode" class="w-4 h-4 text-[var(--text-accent)] bg-[var(--bg-input-secondary)] border-[var(--border-secondary)] rounded focus:ring-[var(--text-accent)]">' +
                    '<span class="text-sm font-semibold text-[var(--text-primary)]">üß™ Test Mode (Use sample data - No API calls)</span>' +
                    '</label>' +
                    '<p class="text-xs text-[var(--text-secondary)] mt-1 ml-6">Enable to preview the dashboard with sample data without consuming API credits.</p>' +
                    '</div>' +
                    createDescription('Scan a list of URLs and automatically segment them into topic clusters using OpenAI. Returns LLM-defined topics and maps them to your content clusters.') +
                    createLabel('OpenAI Model') +
                    createSelect('cciModelSelect', modelOptions) +
                    createDescription('<strong>Model Selection:</strong> GPT-3.5 Turbo is recommended for most use cases (~90% cost savings). GPT-4o mini provides better quality at moderate cost. GPT-4o offers the best quality but is more expensive.') +
                    createLabel('URLs (10-1000)') +
                    createTextarea('cciUrls', 'Enter URLs to analyze, one per line (e.g., https://example.com/page1). Minimum 10, maximum 1000 URLs.') +
                    createLabel('Scope (Default: URL)') +
                    createSelect('cciScopeSelect', scopeOptions) +
                    createLabel('Content Clusters (Optional)') +
                    createTextarea('cciContentClusters', 'Enter seed topics/clusters for content assignment, one per line (e.g., "Digital Marketing", "SEO Best Practices"). Leave blank to auto-generate clusters.') +
                    createDescription('If provided, pages will be mapped to these clusters. If blank, clusters will be auto-generated from the content.');
            };
            
            const readmeContent = `
                <h2>Moz API Assistant - Comprehensive Guide</h2>
                
                <h3>Overview</h3>
                <p>This tool allows you to connect directly to the Moz API (v3) using your personal API key to fetch valuable SEO data. The interface provides an intuitive way to access all major Moz API endpoints with detailed parameter configuration and results visualization.</p>
                
                <h2>üîê API Key Security & Setup</h2>
                <div class="p-4 rounded-lg mb-4" style="background-color: var(--bg-input); border: 1px solid var(--border-secondary);">
                    <h4><strong>Security Features:</strong></h4>
                    <ul class="mt-2">
                        <li><strong>Local Storage Only:</strong> Your API key is stored securely in your browser's local storage and never transmitted to external servers</li>
                        <li><strong>No Server Storage:</strong> This tool runs entirely in your browser - no data is sent to third-party servers</li>
                        <li><strong>Encrypted Transmission:</strong> All API calls are made directly to Moz's secure HTTPS endpoints</li>
                        <li><strong>Auto-Save:</strong> Your API key is automatically saved and restored between sessions</li>
                    </ul>
                </div>
                
                <h4>Setup Steps:</h4>
                <ol>
                    <li><strong>Get API Key:</strong> You need a valid Moz API Key. You can get one or manage your existing key from the <a href="https://moz.com/products/api/keys" target="_blank" rel="noopener">Moz API Dashboard</a>.</li>
                    <li><strong>Add Key to Tool:</strong> Use the API Key input at the top of the tool. Your key is stored securely in your browser's local storage.</li>
                    <li><strong>Verify Connection:</strong> Run a simple API call to verify your key is working correctly.</li>
                </ol>
                
                <h2>üìä Recent API Calls & History</h2>
                <div class="p-4 rounded-lg mb-4" style="background-color: var(--bg-input); border: 1px solid var(--border-secondary);">
                    <h4><strong>API History Features:</strong></h4>
                    <ul class="mt-2">
                        <li><strong>Automatic Logging:</strong> Every successful API call is automatically saved to your local history</li>
                        <li><strong>Search & Filter:</strong> Use the search bar to find specific calls by method, parameters, or date</li>
                        <li><strong>Replay Functionality:</strong> Click any history entry to instantly replay that exact API call with the same parameters</li>
                        <li><strong>Export History:</strong> Download your complete API call history as a CSV file for record-keeping</li>
                        <li><strong>Individual Management:</strong> Delete specific entries or clear your entire history as needed</li>
                    </ul>
                </div>
                
                <p><strong>Accessing Your History:</strong> Click the "Recent API Calls" button in the top navigation to view your complete API call history. Each entry shows the method used, parameters, timestamp, and allows you to replay or delete the call.</p>
                
                <h2>üöÄ Available API Methods</h2>
                <p>Select a method from the dropdown to get started. Methods are organized by category:</p>
                
                <hr class="my-4" style="border-color: var(--border-primary);">
                
                <h3>üìç Site Metrics</h3>
                <div class="readme-method mb-4">
                    <h4><strong><u>Fetch Site Metrics</u></strong></h4>
                    <p><strong>Description:</strong> Get comprehensive metrics like Domain Authority (DA), Page Authority (PA), Spam Score, and link counts for URLs.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose between page-level or domain-level analysis</li>
                        <li><strong>Domains/URLs:</strong> Enter one URL per line or comma-separated (must include http/https)</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Fetch Brand Authority</u></strong></h4>
                    <p><strong>Description:</strong> Get the Brand Authority‚Ñ¢ score for a given site, measuring brand strength and recognition.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Domains/URLs:</strong> Enter one URL per line or comma-separated</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>List Top Pages</u></strong></h4>
                    <p><strong>Description:</strong> Return a list of the top-performing pages on a target domain based on various ranking factors.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Filter:</strong> Filter results by specific criteria</li>
                        <li><strong>Sort:</strong> Choose how to sort the results</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <hr class="my-4" style="border-color: var(--border-primary);">
                
                <h3>üîç Keyword Research</h3>
                <div class="readme-method mb-4">
                    <h4><strong><u>Fetch Keyword Metrics</u></strong></h4>
                    <p><strong>Description:</strong> Get comprehensive keyword data including search volume, difficulty, CTR estimates, and priority scores.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Metric Type:</strong> Choose the type of keyword metrics to retrieve</li>
                        <li><strong>Device:</strong> Select device type (desktop, mobile, tablet)</li>
                        <li><strong>Engine:</strong> Choose search engine (Google, Bing, etc.)</li>
                        <li><strong>Locale:</strong> Select geographic region/language</li>
                        <li><strong>Keywords:</strong> Enter keywords one per line or comma-separated</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Fetch Search Intent</u></strong></h4>
                    <p><strong>Description:</strong> Retrieve search intent scores for any keyword, helping understand user motivation behind searches.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Locale:</strong> Select geographic region/language</li>
                        <li><strong>Keywords:</strong> Enter keywords one per line or comma-separated</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>List Ranking Keywords</u></strong></h4>
                    <p><strong>Description:</strong> List keywords for which a specific site currently ranks in search results.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Locale:</strong> Select geographic region/language</li>
                        <li><strong>Number of Results:</strong> Limit results (1-500, default 25)</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>List Related Keywords</u></strong></h4>
                    <p><strong>Description:</strong> Get a list of related keyword suggestions based on seed keywords.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Locale:</strong> Select geographic region/language</li>
                        <li><strong>Keywords:</strong> Enter seed keywords one per line or comma-separated</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Count Ranking Keywords</u></strong></h4>
                    <p><strong>Description:</strong> Count the total number of keywords for which a site ranks in the top 50 search results.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (limited options available)</li>
                        <li><strong>Locale:</strong> Select geographic region/language</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Competitive Analysis</u></strong></h4>
                    <p><strong>Description:</strong> Comprehensive competitive analysis comparing your domain against up to 3 competitors. Automatically fetches and displays Brand Authority, Domain Authority, Spam Score, Link Metrics, and Top Ranking Keywords side-by-side.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Your Domain:</strong> Enter your domain URL (must include http/https)</li>
                        <li><strong>Competitor Domains:</strong> Enter up to 3 competitor domains, one per line (must include http/https)</li>
                        <li><strong>Locale:</strong> Select geographic region/language for ranking keywords analysis</li>
                        <li><strong>Number of Ranking Keywords:</strong> Limit the number of keywords to display (1-500, default 25)</li>
                    </ul>
                    <p><strong>Features:</strong></p>
                    <ul>
                        <li>Side-by-side comparison dashboard showing all metrics at a glance</li>
                        <li>Interactive domain selector to view detailed ranking keywords for each domain</li>
                        <li>Comprehensive metrics including Brand Authority Score, DA, Total Links, Linking Domains, and Spam Score</li>
                        <li>Toggles between dashboard and JSON view</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Content Cluster Analysis</u></strong></h4>
                    <p><strong>Description:</strong> Advanced content analysis using OpenAI API to analyze URLs, identify content clusters, determine semantic similarity to a seed topic, and provide consolidation recommendations. Uses semantic embeddings to understand content relationships beyond keyword matching.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Seed Topic:</strong> The main keyword/topic to analyze pages against</li>
                        <li><strong>URLs:</strong> Enter URLs to analyze (1-25 URLs, one per line)</li>
                        <li><strong>Locale:</strong> Select geographic region/language for keyword analysis</li>
                        <li><strong>Similarity Threshold:</strong> Threshold for consolidation recommendations (default 0.85)</li>
                        <li><strong>Limit:</strong> Number of related keywords to fetch (default 25)</li>
                        <li><strong>OpenAI API Key:</strong> Required for content analysis and embeddings</li>
                    </ul>
                    <p><strong>Features:</strong></p>
                    <ul>
                        <li>Semantic similarity scoring using OpenAI embeddings</li>
                        <li>Content segmentation by search intent (Informational, Commercial, Navigational, Transactional)</li>
                        <li>Value Score calculation for each URL (see formula below)</li>
                        <li>Content consolidation recommendations based on similarity and keyword overlap</li>
                        <li>Main topic page identification</li>
                        <li>Content recommendations and new content opportunities</li>
                        <li>Keyword metrics for target keywords in new content ideas</li>
                    </ul>
                    <div class="p-4 rounded-lg mt-3" style="background-color: var(--bg-input); border: 1px solid var(--border-secondary);">
                        <h4><strong>Value Score Calculation</strong></h4>
                        <p>The Value Score is a weighted metric used to evaluate the relative value of URLs in a content cluster. It helps identify which pages should be prioritized or kept when consolidating content.</p>
                        <p><strong>Formula:</strong></p>
                        <code style="display: block; padding: 0.5rem; background: var(--bg-container); border-radius: 4px; margin: 0.5rem 0;">
                            Value Score = (Ranking Keywords Count √ó 2.0)<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (Linking Domains √ó 1.5)<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (Inbound Links √ó 0.5)<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (Page Authority √ó 0.1)<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (Anchor Text Diversity √ó 0.3)
                        </code>
                        <p><strong>Components:</strong></p>
                        <ul>
                            <li><strong>Ranking Keywords Count √ó 2.0</strong> - Highest weight, number of keywords the URL ranks for</li>
                            <li><strong>Linking Domains √ó 1.5</strong> - Number of unique root domains linking to the page</li>
                            <li><strong>Inbound Links √ó 0.5</strong> - Total number of external pages linking to the URL</li>
                            <li><strong>Page Authority √ó 0.1</strong> - Moz's Page Authority score (0-100)</li>
                            <li><strong>Anchor Text Diversity √ó 0.3</strong> - Count of unique anchor texts used to link to the page</li>
                        </ul>
                        <p><strong>Usage:</strong> The Value Score is used to identify the main topic page (highest value score among URLs with ranking keywords) and helps determine which URL to keep when consolidating similar content.</p>
                    </div>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Content Clusters Identification</u></strong></h4>
                    <p><strong>Description:</strong> Automatically scan and segment a list of URLs into topic clusters using OpenAI. This method uses LLM analysis to identify content themes and map URLs to your defined content clusters or auto-generate clusters.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>URLs:</strong> Enter 10-1000 URLs to analyze, one per line</li>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Content Clusters (Optional):</strong> Pre-defined clusters/topics to map URLs to, or leave blank for auto-generation</li>
                        <li><strong>OpenAI Model:</strong> Select the model for content analysis (see OpenAI Model Guide below)</li>
                        <li><strong>OpenAI API Key:</strong> Required for content analysis</li>
                    </ul>
                    <p><strong>Features:</strong></p>
                    <ul>
                        <li>Automatic topic clustering using advanced LLM analysis</li>
                        <li>Search intent classification for each URL</li>
                        <li>Content cluster overview with filterable views</li>
                        <li>Page analysis results in filterable table format</li>
                        <li>Toggle between LLM-defined and user-defined clusters</li>
                    </ul>
                </div>
                
                <hr class="my-4" style="border-color: var(--border-primary);">
                
                <h2>ü§ñ OpenAI Model Guide & Pricing</h2>
                <div class="p-4 rounded-lg mb-4" style="background-color: var(--bg-input); border: 1px solid var(--border-secondary);">
                    <h3><strong>Recommended Models for Content Analysis</strong></h3>
                    <p>For the BEST content recommendations and analysis, we recommend these models in order of quality:</p>
                    <ol class="mt-2">
                        <li><strong>GPT-5.1</strong> - Latest model, best for content analysis and recommendations</li>
                        <li><strong>o3-deep-research</strong> - Most powerful deep research model, excellent for comprehensive content analysis</li>
                        <li><strong>GPT-5</strong> - Best model for coding and agentic tasks, great for structured content analysis</li>
                        <li><strong>o4-mini-deep-research</strong> - Faster, more affordable deep research option</li>
                        <li><strong>GPT-4.1</strong> - Smartest non-reasoning model, excellent quality</li>
                        <li><strong>GPT-4o</strong> - High quality, reliable for content analysis</li>
                        <li><strong>GPT-5-mini</strong> - Cost-efficient GPT-5 variant</li>
                        <li><strong>GPT-4o-mini</strong> - Fast and affordable</li>
                        <li><strong>GPT-3.5 Turbo</strong> - Budget-friendly option (~90% cost savings)</li>
                    </ol>
                </div>
                
                <div class="p-4 rounded-lg mb-4" style="background-color: var(--bg-input); border: 1px solid var(--border-secondary);">
                    <h3><strong>OpenAI Model Pricing (per 1M tokens)</strong></h3>
                    <p class="text-xs text-[var(--text-secondary)] mb-3">Pricing is approximate and may vary. Check <a href="https://platform.openai.com/pricing" target="_blank" rel="noopener" class="text-[var(--text-accent)] hover:underline">OpenAI's official pricing page</a> for the most current rates.</p>
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
                            <thead>
                                <tr style="background-color: var(--bg-container); border-bottom: 2px solid var(--border-primary);">
                                    <th style="padding: 0.75rem; text-align: left; font-weight: bold; color: var(--text-primary);">Model</th>
                                    <th style="padding: 0.75rem; text-align: right; font-weight: bold; color: var(--text-primary);">Input (per 1M tokens)</th>
                                    <th style="padding: 0.75rem; text-align: right; font-weight: bold; color: var(--text-primary);">Output (per 1M tokens)</th>
                                    <th style="padding: 0.75rem; text-align: left; font-weight: bold; color: var(--text-primary);">Best For</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="border-bottom: 1px solid var(--border-secondary);">
                                    <td style="padding: 0.75rem; color: var(--text-primary);"><strong>GPT-5.1</strong></td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$1.50</td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$12.00</td>
                                    <td style="padding: 0.75rem; color: var(--text-secondary); font-size: 0.875rem;">Latest, best content analysis</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-secondary);">
                                    <td style="padding: 0.75rem; color: var(--text-primary);"><strong>o3-deep-research</strong></td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$15.00</td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$60.00</td>
                                    <td style="padding: 0.75rem; color: var(--text-secondary); font-size: 0.875rem;">Deep research, comprehensive analysis</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-secondary);">
                                    <td style="padding: 0.75rem; color: var(--text-primary);"><strong>GPT-5</strong></td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$1.25</td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$10.00</td>
                                    <td style="padding: 0.75rem; color: var(--text-secondary); font-size: 0.875rem;">Coding, agentic tasks, structured analysis</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-secondary);">
                                    <td style="padding: 0.75rem; color: var(--text-primary);"><strong>o4-mini-deep-research</strong></td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$3.00</td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$12.00</td>
                                    <td style="padding: 0.75rem; color: var(--text-secondary); font-size: 0.875rem;">Affordable deep research</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-secondary);">
                                    <td style="padding: 0.75rem; color: var(--text-primary);"><strong>GPT-4.1</strong></td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$3.00</td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$12.00</td>
                                    <td style="padding: 0.75rem; color: var(--text-secondary); font-size: 0.875rem;">Smartest non-reasoning model</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-secondary);">
                                    <td style="padding: 0.75rem; color: var(--text-primary);"><strong>GPT-4o</strong></td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$2.50</td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$15.00</td>
                                    <td style="padding: 0.75rem; color: var(--text-secondary); font-size: 0.875rem;">High quality, reliable</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-secondary);">
                                    <td style="padding: 0.75rem; color: var(--text-primary);"><strong>GPT-5-mini</strong></td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$0.25</td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$2.00</td>
                                    <td style="padding: 0.75rem; color: var(--text-secondary); font-size: 0.875rem;">Cost-efficient GPT-5</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-secondary);">
                                    <td style="padding: 0.75rem; color: var(--text-primary);"><strong>GPT-4o-mini</strong></td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$0.15</td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$1.50</td>
                                    <td style="padding: 0.75rem; color: var(--text-secondary); font-size: 0.875rem;">Fast, affordable</td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-secondary);">
                                    <td style="padding: 0.75rem; color: var(--text-primary);"><strong>GPT-3.5 Turbo</strong></td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$0.50</td>
                                    <td style="padding: 0.75rem; text-align: right; color: var(--text-primary);">~$1.50</td>
                                    <td style="padding: 0.75rem; color: var(--text-secondary); font-size: 0.875rem;">Budget-friendly (~90% savings)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p class="text-xs text-[var(--text-secondary)] mt-3"><strong>Note:</strong> Pricing is approximate and subject to change. Input costs apply to tokens sent to the model, output costs apply to tokens generated by the model. For content analysis tasks, expect to use both input and output tokens.</p>
                </div>
                
                <hr class="my-4" style="border-color: var(--border-primary);">
                
                <h3>üîó Link Building</h3>
                <div class="readme-method mb-4">
                    <h4><strong><u>Get Anchor Texts Lists</u></strong></h4>
                    <p><strong>Description:</strong> Get comprehensive data about anchor text used to link to a specified site.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>List Linking Domains</u></strong></h4>
                    <p><strong>Description:</strong> Get a comprehensive list of linking root domains to a target site.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Sort:</strong> Choose how to sort the results</li>
                        <li><strong>Filters:</strong> Apply filters (if multiple filters, "external" must be one)</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>List Recently Gained Links</u></strong></h4>
                    <p><strong>Description:</strong> Get external root domains that added new links to a target during a specified time period.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Begin Date (Optional):</strong> Start date for the analysis period</li>
                        <li><strong>End Date (Optional):</strong> End date for the analysis period</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>List Recently Lost Links</u></strong></h4>
                    <p><strong>Description:</strong> Get root domains that removed links to a target during a specified time period.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Begin Date (Optional):</strong> Start date for the analysis period</li>
                        <li><strong>End Date (Optional):</strong> End date for the analysis period</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Fetch Link Intersects</u></strong></h4>
                    <p><strong>Description:</strong> Find sites that link to some domains but not others, useful for competitive analysis.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Sort:</strong> Choose how to sort the results</li>
                        <li><strong>Minimum Matching Targets:</strong> Minimum number of targets that must match (1-6)</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Linking To:</strong> Domains that should be linked to</li>
                        <li><strong>NOT Linking To (Optional):</strong> Domains that should NOT be linked to</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>List Links</u></strong></h4>
                    <p><strong>Description:</strong> Get a comprehensive list of all links pointing to a target site.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Sort:</strong> Choose how to sort the results</li>
                        <li><strong>Filters:</strong> Apply filters (if multiple filters, "external" must be one)</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Filter Links by Anchor Text</u></strong></h4>
                    <p><strong>Description:</strong> Get a list of links to a target where the anchor text exactly matches a specified string.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Anchor Text:</strong> Enter exact anchor text to search for</li>
                        <li><strong>Sort:</strong> Choose how to sort the results</li>
                        <li><strong>Filters:</strong> Apply filters (if multiple filters, "external" must be one)</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Domains/URLs:</strong> Enter target domains or URLs</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Filter Links by Domain</u></strong></h4>
                    <p><strong>Description:</strong> Find links pointing to a target only if they originate from a particular root domain.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Target Scope:</strong> Choose target analysis scope</li>
                        <li><strong>Target URLs:</strong> Enter target URLs</li>
                        <li><strong>Source Scope:</strong> Choose source analysis scope</li>
                        <li><strong>Source URLs:</strong> Enter source domain URLs</li>
                        <li><strong>Number of Results:</strong> Limit results (1-50, default 25)</li>
                        <li><strong>Filters:</strong> Apply additional filters</li>
                    </ul>
                </div>
                
                <hr class="my-4" style="border-color: var(--border-primary);">
                
                <h3>‚öôÔ∏è Technical SEO</h3>
                <div class="readme-method mb-4">
                    <h4><strong><u>Get Final Redirect Target</u></strong></h4>
                    <p><strong>Description:</strong> See the final redirect target of a page, following the complete redirect chain.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Scope:</strong> Choose analysis scope (page or domain level)</li>
                        <li><strong>Domains/URLs:</strong> Enter URLs to analyze for redirects</li>
                    </ul>
                </div>
                
                <div class="readme-method mb-4">
                    <h4><strong><u>Get Link Status</u></strong></h4>
                    <p><strong>Description:</strong> Get the current status of a specific link from a source to a target URL.</p>
                    <p><strong>Inputs Required:</strong></p>
                    <ul>
                        <li><strong>Target Scope:</strong> Choose target analysis scope</li>
                        <li><strong>Target URL:</strong> Enter the target URL</li>
                        <li><strong>Source Scope:</strong> Choose source analysis scope</li>
                        <li><strong>Source URL:</strong> Enter the source URL</li>
                    </ul>
                </div>
                
                <hr class="my-4" style="border-color: var(--border-primary);">
                
                <h2>üìã General Usage Notes</h2>
                <div class="p-4 rounded-lg" style="background-color: var(--bg-input); border: 1px solid var(--border-secondary);">
                    <h4><strong>Important Information:</strong></h4>
                    <ul class="mt-2">
                        <li><strong>API Usage:</strong> Each API call consumes rows from your Moz API subscription quota. Monitor your usage in the Moz API Dashboard.</li>
                        <li><strong>Rate Limits:</strong> Be mindful of API rate limits to avoid temporary blocks on your requests.</li>
                        <li><strong>Data Freshness:</strong> Moz data is updated regularly, but some metrics may have different refresh schedules.</li>
                        <li><strong>Error Handling:</strong> If an API call fails, detailed error messages will be displayed with the JSON response containing specific error details.</li>
                        <li><strong>Results Export:</strong> All results can be exported as CSV files for further analysis in spreadsheet applications.</li>
                        <li><strong>URL Format:</strong> Always include the full URL with http:// or https:// when entering URLs for analysis.</li>
                    </ul>
                </div>
                
                <h2>üõ†Ô∏è Tips for Best Results</h2>
                <ul>
                    <li><strong>Batch Processing:</strong> Use comma-separated or line-separated lists to analyze multiple URLs or keywords in a single call</li>
                    <li><strong>Scope Selection:</strong> Choose the appropriate scope (page vs domain) based on your analysis needs</li>
                    <li><strong>Filter Usage:</strong> Use filters to narrow down results and focus on the most relevant data</li>
                    <li><strong>History Management:</strong> Regularly review your API call history to track usage patterns and identify frequently used queries</li>
                    <li><strong>Export Regularly:</strong> Export important results as CSV files for backup and further analysis</li>
                </ul>
            `;
            
            const setupEventListeners = () => {
                allDOMElements.readmeBtn.addEventListener('click', () => allDOMElements.readmeModal.classList.remove('hidden'));
                allDOMElements.closeReadmeBtn.addEventListener('click', () => allDOMElements.readmeModal.classList.add('hidden'));
                allDOMElements.readmeModal.addEventListener('click', (e) => {
                    if (e.target === allDOMElements.readmeModal) allDOMElements.readmeModal.classList.add('hidden');
                });
                allDOMElements.themeBtns.forEach(btn => {
                    btn.addEventListener('click', () => applyTheme(btn.dataset.theme));
                });
                allDOMElements.saveApiKeyBtn.addEventListener('click', () => {
                    const key = allDOMElements.apiKeyInput.value.trim();
                    if (key) {
                        try {
                            localStorage.setItem('mozApiKey', key);
                            loadApiKey();
                        } catch (e) {
                            console.warn('Could not save API key to localStorage:', e);
                            displayError('Could not save API key. Please try again.');
                        }
                    }
                });
                allDOMElements.editApiKeyBtn.addEventListener('click', () => {
                    allDOMElements.apiKeyDisplay.classList.add('hidden');
                    allDOMElements.apiKeyInputArea.classList.remove('hidden');
                    allDOMElements.apiKeyInput.focus();
                });
                allDOMElements.saveOpenaiApiKeyBtn.addEventListener('click', () => {
                    const key = allDOMElements.openaiApiKeyInput.value.trim();
                    if (key) {
                        try {
                            localStorage.setItem('openaiApiKey', key);
                            loadOpenaiApiKey();
                        } catch (e) {
                            console.warn('Could not save OpenAI API key to localStorage:', e);
                            displayError('Could not save OpenAI API key. Please try again.');
                        }
                    }
                });
                allDOMElements.editOpenaiApiKeyBtn.addEventListener('click', () => {
                    allDOMElements.openaiApiKeyDisplay.classList.add('hidden');
                    allDOMElements.openaiApiKeyInputArea.classList.remove('hidden');
                    allDOMElements.openaiApiKeyInput.focus();
                });
                allDOMElements.methodSelector.addEventListener('change', () => {
                    document.querySelectorAll('.input-section').forEach(section => section.style.display = 'none');
                    const selectedMethod = allDOMElements.methodSelector.value;
                    if (selectedMethod) {
                        const sectionToShow = document.getElementById(selectedMethod + 'Inputs');
                        if (sectionToShow) sectionToShow.style.display = 'block';
                        allDOMElements.submitBtn.disabled = false;
                    } else {
                        allDOMElements.submitBtn.disabled = true;
                    }
                });
                allDOMElements.form.addEventListener('submit', handleFormSubmit);
                allDOMElements.copyJsonBtn.addEventListener('click', handleCopyJson);
                allDOMElements.exportBtn.addEventListener('click', handleExportCsv);
                allDOMElements.viewDataBtn.addEventListener('click', toggleDataView);
                allDOMElements.historyBtn.addEventListener('click', () => {
                    allDOMElements.historyModal.classList.remove('hidden');
                    renderHistoryList();
                });
                allDOMElements.savedResultsBtn.addEventListener('click', () => {
                    allDOMElements.savedResultsModal.classList.remove('hidden');
                    renderSavedResultsList();
                });
                allDOMElements.closeSavedResultsBtn.addEventListener('click', () => allDOMElements.savedResultsModal.classList.add('hidden'));
                allDOMElements.savedResultsModal.addEventListener('click', (e) => {
                    if (e.target === allDOMElements.savedResultsModal) allDOMElements.savedResultsModal.classList.add('hidden');
                });
                allDOMElements.savedResultsSearch.addEventListener('input', debounce(filterSavedResults, 300));
                allDOMElements.saveResultsBtn.addEventListener('click', saveCurrentResults);
                allDOMElements.exportSavedResultsBtn.addEventListener('click', exportSavedResults);
                allDOMElements.clearSavedResultsBtn.addEventListener('click', clearAllSavedResults);
                allDOMElements.clearDataBtn.addEventListener('click', clearResultsData);
                allDOMElements.exportPdfBtn.addEventListener('click', handleExportPdf);
                allDOMElements.filterBtn.addEventListener('click', () => allDOMElements.filterModal.classList.remove('hidden'));
                allDOMElements.closeFilterBtn.addEventListener('click', () => allDOMElements.filterModal.classList.add('hidden'));
                allDOMElements.cancelFilterBtn.addEventListener('click', () => allDOMElements.filterModal.classList.add('hidden'));
                allDOMElements.filterModal.addEventListener('click', (e) => {
                    if (e.target === allDOMElements.filterModal) allDOMElements.filterModal.classList.add('hidden');
                });
                allDOMElements.applyFilterBtn.addEventListener('click', applyTableFilters);
                
                // History modal event listeners
                allDOMElements.closeHistoryBtn.addEventListener('click', () => allDOMElements.historyModal.classList.add('hidden'));
                allDOMElements.historyModal.addEventListener('click', (e) => {
                    if (e.target === allDOMElements.historyModal) allDOMElements.historyModal.classList.add('hidden');
                });
                allDOMElements.historySearch.addEventListener('input', debounce(filterHistory, 300));
                allDOMElements.exportHistoryBtn.addEventListener('click', exportHistory);
                allDOMElements.clearHistoryBtn.addEventListener('click', clearAllHistory);
                
                // Event delegation for history list buttons
                allDOMElements.historyList.addEventListener('click', (e) => {
                    if (e.target.dataset.replay) {
                        replaySearch(e.target.dataset.replay);
                    } else if (e.target.dataset.edit) {
                        editSearch(e.target.dataset.edit);
                    } else if (e.target.dataset.delete) {
                        deleteHistoryEntry(e.target.dataset.delete);
                    }
                });
                
                // Add escape key functionality for modals
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        if (!allDOMElements.readmeModal.classList.contains('hidden')) {
                            allDOMElements.readmeModal.classList.add('hidden');
                        }
                        if (!allDOMElements.filterModal.classList.contains('hidden')) {
                            allDOMElements.filterModal.classList.add('hidden');
                        }
                        if (!allDOMElements.historyModal.classList.contains('hidden')) {
                            allDOMElements.historyModal.classList.add('hidden');
                        }
                    }
                });
            };

            const applyTheme = (theme) => {
                raf(() => {
                    const root = document.documentElement;
                    const themes = ["light", "dark", "retro", "high-contrast"];
                    
                    // Remove all theme classes
                    themes.forEach(t => root.classList.remove(t));
                    
                    // Add new theme
                    root.classList.add(theme);
                    
                    // Save to localStorage
                    try {
                        localStorage.setItem('theme', theme);
                    } catch (e) {
                        console.warn('Could not save theme to localStorage:', e);
                    }
                    
                    // Update theme button states
                    allDOMElements.themeBtns.forEach(btn => {
                        btn.classList.toggle('font-bold', btn.dataset.theme === theme);
                    });
                    
                    // Update theme toggle icon
                    updateThemeToggleIcon(theme);
                    
                    // Reset logo filter
                    if (allDOMElements.mozLogo) {
                        allDOMElements.mozLogo.style.filter = 'none';
                    }
                });
            };
            
            // Theme toggle button functionality
            const themeToggle = document.getElementById('theme-toggle');
            const themeIcon = document.getElementById('theme-icon');
            
            function updateThemeToggleIcon(theme) {
                if (!themeIcon) return;
                const icons = {
                    'light': '‚òÄÔ∏è',
                    'dark': 'üåô',
                    'retro': 'üíú',
                    'high-contrast': '‚ö´'
                };
                themeIcon.textContent = icons[theme] || 'üåì';
            }
            
            if (themeToggle) {
                themeToggle.addEventListener('click', () => {
                    const currentTheme = document.documentElement.className.match(/(light|dark|retro|high-contrast)/)?.[0] || 'light';
                    const themes = ['light', 'dark', 'retro', 'high-contrast'];
                    const currentIndex = themes.indexOf(currentTheme);
                    const nextIndex = (currentIndex + 1) % themes.length;
                    const nextTheme = themes[nextIndex];
                    
                    // Trigger theme change
                    const themeBtn = Array.from(allDOMElements.themeBtns).find(btn => btn.dataset.theme === nextTheme);
                    if (themeBtn) {
                        themeBtn.click();
                    }
                });
                
                // Initialize theme toggle icon on page load
                const initializeThemeToggle = () => {
                    const savedTheme = localStorage.getItem('theme') || 'light';
                    const currentTheme = document.documentElement.className.match(/(light|dark|retro|high-contrast)/)?.[0] || savedTheme;
                    updateThemeToggleIcon(currentTheme);
                };
                
                // Call on DOMContentLoaded and after theme changes
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initializeThemeToggle);
                } else {
                    initializeThemeToggle();
                }
            }
            

            const fetchQuota = async (apiKey) => {
                if (!apiKey) return;
                try {
                    // Add timeout to prevent hanging requests
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                    
                    const response = await fetch('https://mozapi-proxy-server.vercel.app/api/getMozData', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ apiKey, method: 'getQuota' }),
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    if (!data.quota?.quota) {
                        throw new Error('Invalid quota data received');
                    }
                    
                    const { used, allotted } = data.quota.quota;
                    allDOMElements.quotaText.textContent = `API Usage: ${used.toLocaleString()} / ${allotted.toLocaleString()} Rows Used`;
                    allDOMElements.quotaText.style.color = used >= allotted ? 'var(--text-error)' : 'var(--text-secondary)';
                    allDOMElements.quotaDisplay.classList.remove('hidden');
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.warn("Quota fetch error:", error);
                    }
                    allDOMElements.quotaText.textContent = 'Could not retrieve API usage.';
                    allDOMElements.quotaDisplay.classList.remove('hidden');
                }
            };
            
            const loadApiKey = () => {
                try {
                    const savedKey = localStorage.getItem('mozApiKey');
                    if (savedKey) {
                        allDOMElements.apiKeyText.textContent = `${savedKey.substring(0, 6)}...${savedKey.substring(savedKey.length - 4)}`;
                        allDOMElements.apiKeyInput.value = savedKey;
                        allDOMElements.apiKeyDisplay.classList.remove('hidden');
                        allDOMElements.apiKeyDisplay.classList.add('flex');
                        allDOMElements.apiKeyInputArea.classList.add('hidden');
                        fetchQuota(savedKey);
                    } else {
                        allDOMElements.apiKeyDisplay.classList.add('hidden');
                        allDOMElements.apiKeyInputArea.classList.remove('hidden');
                        allDOMElements.quotaDisplay.classList.add('hidden');
                    }
                } catch (e) {
                    console.warn('Could not load API key from localStorage:', e);
                    allDOMElements.apiKeyDisplay.classList.add('hidden');
                    allDOMElements.apiKeyInputArea.classList.remove('hidden');
                    allDOMElements.quotaDisplay.classList.add('hidden');
                }
            };

            const loadOpenaiApiKey = () => {
                try {
                    const savedKey = localStorage.getItem('openaiApiKey');
                    if (savedKey) {
                        allDOMElements.openaiApiKeyText.textContent = `${savedKey.substring(0, 6)}...${savedKey.substring(savedKey.length - 4)}`;
                        allDOMElements.openaiApiKeyInput.value = savedKey;
                        allDOMElements.openaiApiKeyDisplay.classList.remove('hidden');
                        allDOMElements.openaiApiKeyDisplay.classList.add('flex');
                        allDOMElements.openaiApiKeyInputArea.classList.add('hidden');
                    } else {
                        allDOMElements.openaiApiKeyDisplay.classList.add('hidden');
                        allDOMElements.openaiApiKeyInputArea.classList.remove('hidden');
                    }
                } catch (e) {
                    console.warn('Could not load OpenAI API key from localStorage:', e);
                    allDOMElements.openaiApiKeyDisplay.classList.add('hidden');
                    allDOMElements.openaiApiKeyInputArea.classList.remove('hidden');
                }
            };

            // Sample Data Generators for Test Mode
            function generateSampleCompetitiveAnalysis(params) {
                const domains = [params.yourDomain, ...params.competitors];
                const results = {};
                domains.forEach((domain, idx) => {
                    const label = idx === 0 ? 'Your Domain' : `Competitor ${idx}`;
                    results[domain] = {
                        domain,
                        label,
                        siteMetrics: {
                            status: 'success',
                            data: {
                                site_metrics: {
                                    domain_authority: 45 + Math.floor(Math.random() * 30),
                                    page_authority: 35 + Math.floor(Math.random() * 25),
                                    spam_score: Math.floor(Math.random() * 5),
                                    external_pages_to_root_domain: 5000 + Math.floor(Math.random() * 10000),
                                    root_domains_to_root_domain: 200 + Math.floor(Math.random() * 500)
                                }
                            }
                        },
                        brandAuthority: {
                            status: 'success',
                            data: {
                                site_metrics: {
                                    brand_authority_score: 30 + Math.floor(Math.random() * 40)
                                }
                            }
                        },
                        rankingKeywords: {
                            status: 'success',
                            data: {
                                ranking_keywords: Array.from({ length: params.limit || 25 }, (_, i) => ({
                                    keyword: `sample keyword ${i + 1}`,
                                    rank_position: i + 1,
                                    ranking_page: `${domain}/page-${i + 1}`,
                                    difficulty: Math.floor(Math.random() * 50) + 20,
                                    volume: Math.floor(Math.random() * 10000) + 100
                                }))
                            }
                        },
                        keywordCount: {
                            status: 'success',
                            data: {
                                ranking_keyword_count: {
                                    total: 1000 + Math.floor(Math.random() * 5000),
                                    position: {
                                        rank_1: Math.floor(Math.random() * 10),
                                        rank_2: Math.floor(Math.random() * 15),
                                        rank_3: Math.floor(Math.random() * 20)
                                    }
                                }
                            }
                        },
                        errors: []
                    };
                });
                return results;
            }

            function generateSampleKeywordTargetingAnalysis(params) {
                const urls = Array.isArray(params.urls) ? params.urls : [params.url].filter(Boolean);
                const resultsByUrl = {};
                const allKeywords = ['seo tools', 'keyword research', 'link building', 'on-page seo', 'technical seo'];
                const intents = ['Informational', 'Commercial', 'Transactional', 'Navigational'];
                
                urls.forEach(url => {
                    const keywords = Array.from({ length: params.limit || 25 }, (_, i) => ({
                        keyword: allKeywords[i % allKeywords.length] + ` ${Math.floor(i / allKeywords.length) + 1}`,
                        rank_position: i + 1,
                        ranking_page: url,
                        difficulty: Math.floor(Math.random() * 50) + 20,
                        volume: Math.floor(Math.random() * 10000) + 100
                    }));
                    
                    resultsByUrl[url] = {
                        url,
                        siteMetrics: {
                            status: 'success',
                            data: {
                                site_metrics: {
                                    page_authority: 35 + Math.floor(Math.random() * 25),
                                    domain_authority: 45 + Math.floor(Math.random() * 30),
                                    external_pages_to_page: 100 + Math.floor(Math.random() * 500),
                                    root_domains_to_page: 50 + Math.floor(Math.random() * 200)
                                }
                            }
                        },
                        rankingKeywords: keywords,
                        topAnchors: Array.from({ length: 10 }, (_, i) => ({
                            text: `anchor text ${i + 1}`,
                            external_root_domains: 10 + Math.floor(Math.random() * 50),
                            external_pages: 20 + Math.floor(Math.random() * 100)
                        })),
                        searchIntent: {},
                        intentDistribution: {
                            Informational: 40,
                            Commercial: 30,
                            Transactional: 20,
                            Navigational: 10,
                            Unknown: 0
                        },
                        errors: []
                    };
                    
                    keywords.forEach(kw => {
                        resultsByUrl[url].searchIntent[kw.keyword] = intents[Math.floor(Math.random() * intents.length)];
                    });
                });
                
                const overlaps = [];
                if (urls.length > 1) {
                    overlaps.push({
                        keyword: 'seo tools',
                        urls: urls.slice(0, 2),
                        data: { [urls[0]]: { rank: 5 }, [urls[1]]: { rank: 8 } }
                    });
                }
                
                return { urls, locale: params.locale || 'en-US', limit: params.limit || 25, resultsByUrl, overlaps };
            }

            function generateSampleContentClusterAnalysis(params) {
                const urls = params.urls || [];
                const resultsByUrl = {};
                const seedTopicSimilarities = {};
                const intentGroups = { Informational: [], Commercial: [], Transactional: [] };
                
                urls.forEach((url, idx) => {
                    const similarity = 0.7 + Math.random() * 0.25;
                    seedTopicSimilarities[url] = similarity;
                    const intent = ['Informational', 'Commercial', 'Transactional'][Math.floor(Math.random() * 3)];
                    intentGroups[intent].push(url);
                    
                    resultsByUrl[url] = {
                        url,
                        siteMetrics: {
                            status: 'success',
                            data: {
                                site_metrics: {
                                    page_authority: 35 + Math.floor(Math.random() * 25),
                                    domain_authority: 45 + Math.floor(Math.random() * 30)
                                }
                            }
                        },
                        rankingKeywords: Array.from({ length: params.limit || 25 }, (_, i) => ({
                            keyword: `${params.seedTopic} related ${i + 1}`,
                            rank_position: i + 1,
                            ranking_page: url,
                            difficulty: Math.floor(Math.random() * 50) + 20,
                            volume: Math.floor(Math.random() * 10000) + 100
                        })),
                        primaryIntent: intent,
                        valueScore: Math.floor(Math.random() * 50) + 50,
                        mozMetrics: {
                            rankingKeywordsCount: params.limit || 25,
                            linkingDomains: 50 + Math.floor(Math.random() * 200),
                            inboundLinks: 100 + Math.floor(Math.random() * 500),
                            pageAuthority: 35 + Math.floor(Math.random() * 25)
                        },
                        errors: []
                    };
                });
                
                const mainTopicPage = urls[0] || '';
                const consolidationClusters = [
                    {
                        intent: 'Informational',
                        urls: intentGroups.Informational.slice(0, 3),
                        overlappingKeywords: ['seo basics', 'keyword research', 'on-page optimization']
                    }
                ];
                
                return {
                    seedTopic: params.seedTopic || 'Sample Topic',
                    urls,
                    locale: params.locale || 'en-US',
                    limit: params.limit || 25,
                    similarityThreshold: params.similarityThreshold || 0.85,
                    resultsByUrl,
                    seedTopicSimilarities,
                    intentGroups,
                    consolidationClusters,
                    mainTopicPage,
                    relatedKeywords: ['related keyword 1', 'related keyword 2', 'related keyword 3'],
                    contentRecommendations: {
                        recommendations: urls.slice(0, 2).map(url => ({
                            url,
                            recommendations: ['Improve internal linking', 'Add more relevant keywords', 'Enhance meta descriptions']
                        })),
                        generalRecommendations: ['Consolidate similar content', 'Improve keyword targeting']
                    },
                    newContentToCreate: {
                        newContentIdeas: [
                            {
                                title: 'Advanced SEO Techniques',
                                intent: 'Informational',
                                targetKeywords: ['advanced seo', 'seo strategies'],
                                rationale: 'Fill content gap for advanced users'
                            }
                        ]
                    }
                };
            }

            function generateSampleContentClustersIdentification(params) {
                const urls = params.urls || [];
                const resultsByUrl = {};
                const clusters = [
                    { clusterIndex: 0, urls: urls.slice(0, Math.floor(urls.length / 3)) },
                    { clusterIndex: 1, urls: urls.slice(Math.floor(urls.length / 3), Math.floor(urls.length * 2 / 3)) },
                    { clusterIndex: 2, urls: urls.slice(Math.floor(urls.length * 2 / 3)) }
                ].filter(c => c.urls.length > 0);
                
                const clusterLabels = clusters.map((cluster, idx) => ({
                    clusterIndex: idx,
                    clusterName: `Sample Cluster ${idx + 1}`,
                    description: `This cluster contains ${cluster.urls.length} pages related to sample topic ${idx + 1}`,
                    topicTags: ['tag1', 'tag2', 'tag3'],
                    dominantIntent: ['Informational', 'Commercial', 'Transactional'][idx % 3],
                    funnelStages: ['Awareness', 'Consideration']
                }));
                
                urls.forEach((url, idx) => {
                    const clusterIdx = Math.floor(idx / Math.ceil(urls.length / clusters.length)) % clusters.length;
                    const cluster = clusterLabels[clusterIdx];
                    
                    resultsByUrl[url] = {
                        url,
                        rawContent: `Sample content for ${url}`,
                        summary: `This is a sample summary for ${url} covering sample topic ${clusterIdx + 1}`,
                        embedding: Array(1536).fill(0).map(() => Math.random()),
                        llmDefinedTopic: `Sample Topic ${clusterIdx + 1}`,
                        contentCluster: cluster.clusterName,
                        primaryIntent: cluster.dominantIntent,
                        audience: ['Marketing Professionals', 'Small Business Owners', 'SEO Experts'][idx % 3],
                        expertiseLevel: ['Beginner', 'Intermediate', 'Advanced'][idx % 3],
                        topicTags: cluster.topicTags,
                        errors: []
                    };
                });
                
                return {
                    urls,
                    scope: params.scope || 'url',
                    contentClusters: params.contentClusters || null,
                    resultsByUrl,
                    clusterLabels,
                    clusters
                };
            }
            
            async function handleFormSubmit(e) {
                e.preventDefault();

                // Prevent double submissions
                if (inFlightRequest) {
                    inFlightRequest.abort();
                }
                inFlightRequest = new AbortController();


                allDOMElements.errorMessage.classList.add('hidden');
                allDOMElements.resultsContainer.classList.add('hidden');
                allDOMElements.submitBtn.disabled = true;
                allDOMElements.submitBtn.setAttribute('aria-busy', 'true');
                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Processing...</span>';
                const selectedMethod = allDOMElements.methodSelector.value;
                if (!selectedMethod) {
                    displayError('Please select a method.');
                    resetSubmitButton(); return;
                }
                
                // Check if test mode is enabled for beta methods
                const testModeEnabled = 
                    (selectedMethod === 'competitiveAnalysis' && document.getElementById('caTestMode')?.checked) ||
                    (selectedMethod === 'keywordTargetingAnalysis' && document.getElementById('ktaTestMode')?.checked) ||
                    (selectedMethod === 'contentClusterAnalysis' && document.getElementById('ccaTestMode')?.checked) ||
                    (selectedMethod === 'contentClustersIdentification' && document.getElementById('cciTestMode')?.checked);
                
                const apiKey = allDOMElements.apiKeyInput.value.trim();
                if (!testModeEnabled && !apiKey) {
                    displayError('Please provide an API Key and select a method.');
                    resetSubmitButton(); return;
                }
                let payload;
                try {
                    payload = buildPayload(apiKey, selectedMethod);
                } catch (error) {
                    displayError(error.message);
                    resetSubmitButton(); return;
                }
                const PROXY_URL = document.body.dataset.proxy;
                
                // Special handling for multi-endpoint dashboards
                if (selectedMethod === 'competitiveAnalysis') {
                    try {
                        const testMode = document.getElementById('caTestMode')?.checked || false;
                        let competitiveData;
                        if (testMode) {
                            // Use sample data
                            competitiveData = generateSampleCompetitiveAnalysis(payload.params);
                            allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Loading test data...</span>';
                            await new Promise(resolve => setTimeout(resolve, 500)); // Simulate loading
                        } else {
                            competitiveData = await runCompetitiveAnalysis(apiKey, payload.params, PROXY_URL, inFlightRequest);
                            fetchQuota(apiKey);
                        }
                        currentResultsData = competitiveData;
                        currentOriginalParams = payload.params;
                        currentMethod = selectedMethod;
                        showCompetitiveDashboard(competitiveData);
                        updateSaveButtonVisibility();
                        autoSaveToHistory();
                    } catch (error) {
                        if (error.name !== 'AbortError') {
                            displayError(error.message);
                        }
                    } finally {
                        resetSubmitButton();
                        inFlightRequest = null;
                    }
                    return;
                }
                if (selectedMethod === 'keywordTargetingAnalysis') {
                    try {
                        const testMode = document.getElementById('ktaTestMode')?.checked || false;
                        let ktaData;
                        if (testMode) {
                            // Use sample data
                            ktaData = generateSampleKeywordTargetingAnalysis(payload.params);
                            allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Loading test data...</span>';
                            await new Promise(resolve => setTimeout(resolve, 500)); // Simulate loading
                        } else {
                            ktaData = await runKeywordTargetingAnalysis(apiKey, payload.params, PROXY_URL, inFlightRequest);
                            fetchQuota(apiKey);
                        }
                        currentResultsData = ktaData;
                        currentOriginalParams = payload.params;
                        currentMethod = selectedMethod;
                        showKeywordTargetingDashboard(ktaData);
                        updateSaveButtonVisibility();
                        autoSaveToHistory();
                    } catch (error) {
                        if (error.name !== 'AbortError') {
                            displayError(error.message);
                        }
                    } finally {
                        resetSubmitButton();
                        inFlightRequest = null;
                    }
                    return;
                }
                if (selectedMethod === 'contentClusterAnalysis') {
                    try {
                        const testMode = document.getElementById('ccaTestMode')?.checked || false;
                        let ccaData;
                        if (testMode) {
                            // Use sample data
                            ccaData = generateSampleContentClusterAnalysis(payload.params);
                            allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Loading test data...</span>';
                            await new Promise(resolve => setTimeout(resolve, 500)); // Simulate loading
                        } else {
                            const openaiApiKey = allDOMElements.openaiApiKeyInput.value.trim();
                            if (!openaiApiKey) {
                                displayError('Please provide an OpenAI API Key for Content Cluster Analysis.');
                                resetSubmitButton();
                                return;
                            }
                            ccaData = await runContentClusterAnalysis(apiKey, openaiApiKey, payload.params, PROXY_URL, inFlightRequest);
                            fetchQuota(apiKey);
                        }
                        currentResultsData = ccaData;
                        currentOriginalParams = payload.params;
                        currentMethod = selectedMethod;
                        showContentClusterDashboard(ccaData);
                        updateSaveButtonVisibility();
                        autoSaveToHistory();
                    } catch (error) {
                        if (error.name !== 'AbortError') {
                            displayError(error.message);
                        }
                    } finally {
                        resetSubmitButton();
                        inFlightRequest = null;
                    }
                    return;
                }
                if (selectedMethod === 'contentClustersIdentification') {
                    try {
                        const testMode = document.getElementById('cciTestMode')?.checked || false;
                        let cciData;
                        if (testMode) {
                            // Use sample data
                            cciData = generateSampleContentClustersIdentification(payload.params);
                            allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Loading test data...</span>';
                            await new Promise(resolve => setTimeout(resolve, 500)); // Simulate loading
                        } else {
                            const openaiApiKey = allDOMElements.openaiApiKeyInput.value.trim();
                            if (!openaiApiKey) {
                                displayError('Please provide an OpenAI API Key for Content Clusters Identification.');
                                resetSubmitButton();
                                return;
                            }
                            cciData = await runContentClustersIdentification(openaiApiKey, payload.params, PROXY_URL, inFlightRequest);
                        }
                        currentResultsData = cciData;
                        currentOriginalParams = payload.params;
                        currentMethod = selectedMethod;
                        showContentClustersIdentificationDashboard(cciData);
                        updateSaveButtonVisibility();
                        autoSaveToHistory();
                    } catch (error) {
                        if (error.name !== 'AbortError') {
                            displayError(error.message);
                        }
                    } finally {
                        resetSubmitButton();
                        inFlightRequest = null;
                    }
                    return;
                }
                
                // For non-dashboard methods, ensure dashboards are cleared
                const existingCompetitive = document.getElementById('competitive-dashboard');
                if (existingCompetitive) existingCompetitive.remove();
                const existingKta = document.getElementById('keyword-targeting-dashboard');
                if (existingKta) existingKta.remove();
                const existingCca = document.getElementById('content-cluster-dashboard');
                if (existingCca) existingCca.remove();
                const existingCci = document.getElementById('content-clusters-identification-dashboard');
                if (existingCci) existingCci.remove();
                
                try {
                    const response = await fetch(PROXY_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        signal: inFlightRequest.signal
                    });
                    const data = await response.json();
                    if (!response.ok) throw new Error(data.error || `Request failed with status ${response.status}`);
                    currentResultsData = data;
                    currentOriginalParams = payload.params;
                    currentMethod = selectedMethod;
                    showRawJsonResults(data);
                    updateSaveButtonVisibility();
                    fetchQuota(apiKey);
                    
                    // Auto-save successful search to history
                    autoSaveToHistory();
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        displayError(error.message);
                    }
                } finally {
                    resetSubmitButton();
                    inFlightRequest = null;
                }
            }

            async function runCompetitiveAnalysis(apiKey, params, proxyUrl, opensignal) {
                const allDomains = [params.yourDomain, ...params.competitors];
                const results = {};
                
                // Update progress
                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Fetching data for ' + allDomains.length + ' domains...</span>';
                
                // For each domain, make 3 API calls: siteMetrics, brandAuthority, rankingKeywords
                for (let i = 0; i < allDomains.length; i++) {
                    const domain = allDomains[i];
                    const domainLabel = i === 0 ? 'Your Domain' : `Competitor ${i}`;
                    
                    allDOMElements.submitBtn.innerHTML = `<div class="spinner"></div><span class="ml-2">Processing ${domainLabel} (${i + 1}/${allDomains.length})...</span>`;
                    
                    results[domain] = {
                        domain,
                        label: domainLabel,
                        siteMetrics: null,
                        brandAuthority: null,
                        rankingKeywords: null,
                        keywordCount: null,
                        errors: []
                    };
                    
                    // Fetch Site Metrics
                    try {
                        const smResponse = await fetch(proxyUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                apiKey,
                                method: 'siteMetrics',
                                params: { scope: 'domain', targets: [domain] }
                            }),
                            signal: opensignal.signal
                        });
                        const smData = await smResponse.json();
                        if (smResponse.ok && Array.isArray(smData) && smData[0]?.status === 'success') {
                            results[domain].siteMetrics = smData[0];
                        } else {
                            results[domain].errors.push('Site Metrics: ' + (smData[0]?.reason || 'Failed'));
                        }
                    } catch (e) {
                        results[domain].errors.push('Site Metrics: ' + e.message);
                    }
                    
                    // Fetch Brand Authority
                    try {
                        const baResponse = await fetch(proxyUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                apiKey,
                                method: 'brandAuthority',
                                params: { targets: [domain] }
                            }),
                            signal: opensignal.signal
                        });
                        const baData = await baResponse.json();
                        if (baResponse.ok && Array.isArray(baData) && baData[0]?.status === 'success') {
                            results[domain].brandAuthority = baData[0];
                        } else {
                            results[domain].errors.push('Brand Authority: ' + (baData[0]?.reason || 'Failed'));
                        }
                    } catch (e) {
                        results[domain].errors.push('Brand Authority: ' + e.message);
                    }
                    
                    // Fetch Ranking Keywords
                    try {
                        const rkResponse = await fetch(proxyUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                apiKey,
                                method: 'rankingKeywords',
                                params: { 
                                    scope: 'domain', 
                                    locale: params.locale || 'en-US',
                                    targets: [domain],
                                    limit: params.limit || 25
                                }
                            }),
                            signal: opensignal.signal
                        });
                        const rkData = await rkResponse.json();
                        if (rkResponse.ok && Array.isArray(rkData) && rkData[0]?.status === 'success') {
                            results[domain].rankingKeywords = rkData[0];
                        } else {
                            results[domain].errors.push('Ranking Keywords: ' + (rkData[0]?.reason || 'Failed'));
                        }
                    } catch (e) {
                        results[domain].errors.push('Ranking Keywords: ' + e.message);
                    }
                    
                    // Fetch Keyword Count
                    try {
                        const kcResponse = await fetch(proxyUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                apiKey,
                                method: 'keywordCount',
                                params: { 
                                    scope: 'domain', 
                                    locale: params.locale || 'en-US',
                                    targets: [domain]
                                }
                            }),
                            signal: opensignal.signal
                        });
                        const kcData = await kcResponse.json();
                        if (kcResponse.ok && Array.isArray(kcData) && kcData[0]?.status === 'success') {
                            results[domain].keywordCount = kcData[0];
                        } else {
                            results[domain].errors.push('Keyword Count: ' + (kcData[0]?.reason || 'Failed'));
                        }
                    } catch (e) {
                        results[domain].errors.push('Keyword Count: ' + e.message);
                    }
                }
                
                return results;
            }

            async function runKeywordTargetingAnalysis(apiKey, params, proxyUrl, opensignal) {
                const urls = Array.isArray(params.urls) ? params.urls : [params.url].filter(Boolean);
                const locale = params.locale || 'en-US';
                const limit = params.limit || 25;
                const resultsByUrl = {};

                // Kick off per-URL requests in parallel
                const perUrlPromises = urls.map(async (u) => {
                    resultsByUrl[u] = {
                        url: u,
                        siteMetrics: null,
                        rankingKeywords: [],
                        topAnchors: [],
                        searchIntent: {},
                        intentDistribution: {},
                        errors: []
                    };

                    // Site Metrics, Ranking Keywords, Anchor Text concurrently per URL
                    const sm = (async () => {
                        try {
                            const resp = await fetch(proxyUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ apiKey, method: 'siteMetrics', params: { scope: 'url', targets: [u] } }), signal: opensignal.signal });
                            const data = await resp.json();
                            if (resp.ok && Array.isArray(data) && data[0]?.status === 'success') resultsByUrl[u].siteMetrics = data[0];
                            else resultsByUrl[u].errors.push('Site Metrics: ' + (data[0]?.reason || 'Failed'));
                        } catch (e) { resultsByUrl[u].errors.push('Site Metrics: ' + e.message); }
                    })();
                    const rk = (async () => {
                        try {
                            const resp = await fetch(proxyUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ apiKey, method: 'rankingKeywords', params: { scope: 'url', locale, targets: [u], limit } }), signal: opensignal.signal });
                            const data = await resp.json();
                            if (resp.ok && Array.isArray(data) && data[0]?.status === 'success') resultsByUrl[u].rankingKeywords = data[0]?.data?.ranking_keywords || [];
                            else resultsByUrl[u].errors.push('Ranking Keywords: ' + (data[0]?.reason || 'Failed'));
                        } catch (e) { resultsByUrl[u].errors.push('Ranking Keywords: ' + e.message); }
                    })();
                    const at = (async () => {
                        try {
                            const resp = await fetch(proxyUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ apiKey, method: 'anchorText', params: { scope: 'url', targets: [u], limit: 50 } }), signal: opensignal.signal });
                            const data = await resp.json();
                            if (resp.ok && Array.isArray(data) && data[0]?.status === 'success') {
                                const anchors = data[0]?.data?.anchor_texts || [];
                                anchors.sort((a, b) => (b.external_root_domains || 0) - (a.external_root_domains || 0));
                                resultsByUrl[u].topAnchors = anchors.slice(0, 10);
                            } else resultsByUrl[u].errors.push('Anchor Text: ' + (data[0]?.reason || 'Failed'));
                        } catch (e) { resultsByUrl[u].errors.push('Anchor Text: ' + e.message); }
                    })();
                    await Promise.all([sm, rk, at]);
                });

                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Fetching data for ' + urls.length + ' URLs...</span>';
                await Promise.all(perUrlPromises);

                // Build unique keyword list across URLs
                const allKeywords = [];
                urls.forEach(u => {
                    (resultsByUrl[u].rankingKeywords || []).forEach(k => { if (k?.keyword) allKeywords.push(k.keyword); });
                });
                const uniqueKeywords = Array.from(new Set(allKeywords));

                // Fetch intent in batches if needed
                const titleCase = (s) => (s ? s.charAt(0).toUpperCase() + s.slice(1).toLowerCase() : 'Unknown');
                const normalizeIntent = (val) => {
                    const t = titleCase(val);
                    return ['Informational','Transactional','Commercial','Navigational','Unknown'].includes(t) ? t : 'Unknown';
                };

                const intentMapGlobal = {};
                if (uniqueKeywords.length > 0) {
                    allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Fetching search intent...</span>';
                    try {
                        const siResp = await fetch(proxyUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ apiKey, method: 'searchIntent', params: { locale, keywords: uniqueKeywords } }), signal: opensignal.signal });
                        const siData = await siResp.json();
                        if (siResp.ok && Array.isArray(siData)) {
                            siData.forEach(entry => {
                                if (entry.status === 'success') {
                                    const kw = entry?.data?.serp_query?.keyword;
                                    const primary = (entry?.data?.keyword_intent?.primary_intents || [])[0] || 'Unknown';
                                    intentMapGlobal[kw] = normalizeIntent(primary);
                                }
                            });
                        }
                    } catch (e) {
                        // Non-fatal; leave intents empty
                    }
                }

                // Attach per-URL intent maps and distributions
                urls.forEach(u => {
                    const map = {};
                    const counts = { Informational: 0, Transactional: 0, Commercial: 0, Navigational: 0, Unknown: 0 };
                    (resultsByUrl[u].rankingKeywords || []).forEach(k => {
                        const intent = intentMapGlobal[k.keyword] || 'Unknown';
                        map[k.keyword] = intent;
                        counts[intent]++;
                    });
                    const total = Math.max(1, (resultsByUrl[u].rankingKeywords || []).length);
                    resultsByUrl[u].searchIntent = map;
                    resultsByUrl[u].intentDistribution = {
                        Informational: Math.round((counts.Informational / total) * 100),
                        Transactional: Math.round((counts.Transactional / total) * 100),
                        Commercial: Math.round((counts.Commercial / total) * 100),
                        Navigational: Math.round((counts.Navigational / total) * 100),
                        Unknown: Math.round((counts.Unknown / total) * 100)
                    };
                });

                // Compute keyword overlap across URLs
                const keywordToUrls = {};
                urls.forEach(u => {
                    (resultsByUrl[u].rankingKeywords || []).forEach(k => {
                        const key = (k.keyword || '').toLowerCase();
                        if (!key) return;
                        if (!keywordToUrls[key]) keywordToUrls[key] = [];
                        if (!keywordToUrls[key].includes(u)) keywordToUrls[key].push(u);
                    });
                });
                const overlaps = Object.entries(keywordToUrls)
                    .filter(([_, arr]) => arr.length > 1)
                    .map(([kwLower, urlList]) => {
                        const perUrl = {};
                        urlList.forEach(u => {
                            const match = (resultsByUrl[u].rankingKeywords || []).find(k => (k.keyword || '').toLowerCase() === kwLower);
                            if (match) perUrl[u] = { rank: match.rank_position };
                        });
                        return { keyword: kwLower, urls: urlList, data: perUrl };
                    })
                    .sort((a, b) => b.urls.length - a.urls.length || a.keyword.localeCompare(b.keyword));

                return { urls, locale, limit, resultsByUrl, overlaps };
            }

            // Content extraction helper function (via proxy)
            async function extractPageContent(url, proxyUrl) {
                try {
                    const response = await fetch(proxyUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            method: 'extractContent',
                            params: { url }
                        })
                    });
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to extract content');
                    }
                    const data = await response.json();
                    return data.content || '';
                } catch (error) {
                    console.warn(`Failed to extract content from ${url}:`, error);
                    return '';
                }
            }

            // Get embeddings from OpenAI (via proxy)
            async function getEmbeddings(text, openaiApiKey, proxyUrl) {
                try {
                    return await getEmbeddingsWithRateLimit(text, openaiApiKey, proxyUrl);
                } catch (error) {
                    console.error('Embeddings error:', error);
                    throw error;
                }
            }

            // Calculate cosine similarity
            function cosineSimilarity(vecA, vecB) {
                if (vecA.length !== vecB.length) return 0;
                let dotProduct = 0;
                let normA = 0;
                let normB = 0;
                for (let i = 0; i < vecA.length; i++) {
                    dotProduct += vecA[i] * vecB[i];
                    normA += vecA[i] * vecA[i];
                    normB += vecB[i] * vecB[i];
                }
                return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
            }

            // Rate-limited OpenAI API call with retry logic
            async function rateLimitedOpenAICall(apiCallFn, maxRetries = 5, baseDelay = 1000) {
                for (let attempt = 0; attempt < maxRetries; attempt++) {
                    try {
                        return await apiCallFn();
                    } catch (error) {
                        const errorMessage = error.message || '';
                        const isRateLimit = /rate limit|429|TPM|RPM/i.test(errorMessage);
                        
                        if (isRateLimit && attempt < maxRetries - 1) {
                            // Extract retry-after time if available (OpenAI provides this in seconds)
                            let retryAfter = baseDelay;
                            const retryAfterMatch = errorMessage.match(/try again in ([\d.]+)s/i);
                            if (retryAfterMatch) {
                                // Add 10% buffer to the retry time to be safe
                                retryAfter = parseFloat(retryAfterMatch[1]) * 1000 * 1.1;
                            } else {
                                // Exponential backoff: 2s, 4s, 8s, 16s, 32s
                                retryAfter = baseDelay * Math.pow(2, attempt);
                            }
                            
                            // Ensure minimum delay of 2 seconds for rate limits
                            retryAfter = Math.max(retryAfter, 2000);
                            
                            // Add some jitter to avoid thundering herd (10% random variation)
                            retryAfter += Math.random() * retryAfter * 0.1;
                            
                            console.log(`Rate limit hit. Retrying in ${(retryAfter / 1000).toFixed(1)}s... (attempt ${attempt + 1}/${maxRetries})`);
                            await new Promise(resolve => setTimeout(resolve, retryAfter));
                            continue;
                        }
                        
                        // If not a rate limit error or out of retries, throw
                        throw error;
                    }
                }
            }

            // Analyze with OpenAI GPT (via proxy) with rate limiting
            // model: 'gpt-3.5-turbo' (default, cheaper), 'gpt-4o-mini' (affordable, better quality), or 'gpt-4o' (best quality, more expensive)
            // Master system prompt for all SEO/cluster analysis tasks
            function getSEOSystemPrompt() {
                const currentYear = new Date().getFullYear();
                return `You are an expert in SEO strategy, information architecture, content clustering, and keyword intent classification.

Follow these universal rules for EVERY task:
- Base all reasoning strictly on the provided data.
- Never hallucinate URLs, keywords, competitors, or topical details.
- If data is missing, state clearly what is missing instead of inventing it.
- Prefer concise, factual analysis over vague generalizations.
- Return JSON EXACTLY as requested when a schema is provided.
- Never include extra fields, comments, or explanations outside JSON.
- All year references must use the current year: ${currentYear}.
- All cluster names must be 2‚Äì5 words and human-readable.
- All topic tags must be canonical SEO topics (not branded, not duplicated).
- Use only the following search intents: Informational, Commercial, Navigational, Transactional, Local.
- When summarizing content, do NOT add any information not present in the text.

Refer to these definitions (use strictly):
- Informational: user seeks knowledge or education.
- Commercial: user compares solutions or research options.
- Navigational: user wants a specific brand or page.
- Transactional: user intends to act (buy, sign up, download).
- Local: tied to geographic/near-me queries.

If outputting natural language (not JSON), keep it under 3 sentences unless otherwise stated.`;
            }

            async function analyzeWithOpenAI(analysisData, openaiApiKey, proxyUrl, model = 'gpt-3.5-turbo', systemPrompt = null) {
                return rateLimitedOpenAICall(async () => {
                    // Debug: Log the model being sent
                    console.log('[OpenAI API] Requesting model:', model);
                    
                    // Use provided system prompt or default SEO system prompt
                    const finalSystemPrompt = systemPrompt || getSEOSystemPrompt();
                    
                    const requestBody = {
                        method: 'analyzeWithOpenAI',
                        openaiApiKey,
                        params: { 
                            analysisData: {
                                ...analysisData,
                                systemPrompt: finalSystemPrompt
                            },
                            model: model // Specify model for cost control
                        }
                    };
                    console.log('[OpenAI API] Request payload:', JSON.stringify(requestBody, null, 2));
                    const response = await fetch(proxyUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to analyze with OpenAI');
                    }
                    const data = await response.json();
                    return data.analysis;
                });
            }

            // Get embeddings with rate limiting
            async function getEmbeddingsWithRateLimit(text, openaiApiKey, proxyUrl) {
                return rateLimitedOpenAICall(async () => {
                    const response = await fetch(proxyUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            method: 'getEmbeddings',
                            openaiApiKey,
                            params: { text }
                        })
                    });
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to get embeddings');
                    }
                    const data = await response.json();
                    return data.embedding;
                });
            }

            // Process items in batches with delays
            async function processInBatches(items, batchSize, delayMs, processFn, progressCallback) {
                const results = [];
                // Process items sequentially to avoid rate limits, not in parallel
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    const result = await processFn(item, i);
                    results.push(result);
                    
                    // Update progress
                    if (progressCallback && (i + 1) % batchSize === 0 || i === items.length - 1) {
                        progressCallback(i + 1, items.length);
                    }
                    
                    // Add delay between items (except for the last item)
                    // Use longer delays for larger batches to avoid rate limits
                    if (i < items.length - 1) {
                        const delay = items.length > 20 ? Math.max(delayMs, 2000) : delayMs; // Minimum 2s delay for large batches
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                return results;
            }

            async function runContentClusterAnalysis(apiKey, openaiApiKey, params, proxyUrl, opensignal) {
                const { seedTopic, urls, locale, similarityThreshold, limit, model = 'gpt-3.5-turbo' } = params;
                const resultsByUrl = {};

                // Step 1: Get related keywords for seed topic
                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Fetching related keywords...</span>';
                let relatedKeywords = [];
                try {
                    const rkResp = await fetch(proxyUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            apiKey,
                            method: 'relatedKeywords',
                            params: { locale, keywords: [seedTopic] }
                        }),
                        signal: opensignal.signal
                    });
                    const rkData = await rkResp.json();
                    if (rkResp.ok && Array.isArray(rkData)) {
                        rkData.forEach(entry => {
                            if (entry.status === 'success' && entry.data?.related_keywords) {
                                relatedKeywords.push(...entry.data.related_keywords.map(k => k.keyword));
                            }
                        });
                    }
                } catch (e) {
                    console.warn('Failed to fetch related keywords:', e);
                }

                // Step 2: Fetch Moz data for each URL (similar to Keyword Targeting Analysis)
                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Fetching Moz data for ' + urls.length + ' URLs...</span>';
                const perUrlPromises = urls.map(async (u) => {
                    resultsByUrl[u] = {
                        url: u,
                        siteMetrics: null,
                        rankingKeywords: [],
                        topAnchors: [],
                        searchIntent: {},
                        intentDistribution: {},
                        content: '',
                        embedding: null,
                        errors: []
                    };

                    const sm = (async () => {
                        try {
                            const resp = await fetch(proxyUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ apiKey, method: 'siteMetrics', params: { scope: 'url', targets: [u] } }),
                                signal: opensignal.signal
                            });
                            const data = await resp.json();
                            if (resp.ok && Array.isArray(data) && data[0]?.status === 'success') {
                                resultsByUrl[u].siteMetrics = data[0];
                            } else {
                                resultsByUrl[u].errors.push('Site Metrics: ' + (data[0]?.reason || 'Failed'));
                            }
                        } catch (e) {
                            resultsByUrl[u].errors.push('Site Metrics: ' + e.message);
                        }
                    })();

                    const rk = (async () => {
                        try {
                            const resp = await fetch(proxyUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ apiKey, method: 'rankingKeywords', params: { scope: 'url', locale, targets: [u], limit } }),
                                signal: opensignal.signal
                            });
                            const data = await resp.json();
                            if (resp.ok && Array.isArray(data) && data[0]?.status === 'success') {
                                resultsByUrl[u].rankingKeywords = data[0]?.data?.ranking_keywords || [];
                            } else {
                                resultsByUrl[u].errors.push('Ranking Keywords: ' + (data[0]?.reason || 'Failed'));
                            }
                        } catch (e) {
                            resultsByUrl[u].errors.push('Ranking Keywords: ' + e.message);
                        }
                    })();

                    await Promise.all([sm, rk]);
                });

                await Promise.all(perUrlPromises);

                // Step 3: Fetch anchor text data for value calculation
                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Fetching anchor text data...</span>';
                const anchorPromises = urls.map(async (u) => {
                    try {
                        const resp = await fetch(proxyUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ apiKey, method: 'anchorText', params: { scope: 'url', targets: [u], limit: 50 } }),
                            signal: opensignal.signal
                        });
                        const data = await resp.json();
                        if (resp.ok && Array.isArray(data) && data[0]?.status === 'success') {
                            resultsByUrl[u].topAnchors = data[0]?.data?.anchor_texts || [];
                        }
                    } catch (e) {
                        // Non-fatal
                    }
                });
                await Promise.all(anchorPromises);

                // Step 4: Extract content and generate embeddings
                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Extracting content and generating embeddings...</span>';
                for (const url of urls) {
                    try {
                        resultsByUrl[url].content = await extractPageContent(url, proxyUrl);
                        if (resultsByUrl[url].content) {
                            resultsByUrl[url].embedding = await getEmbeddings(resultsByUrl[url].content, openaiApiKey, proxyUrl);
                        }
                    } catch (e) {
                        resultsByUrl[url].errors.push('Content Extraction: ' + e.message);
                    }
                }

                // Step 5: Get embedding for seed topic and calculate similarity to each URL
                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Calculating semantic similarity to seed topic...</span>';
                let seedTopicEmbedding = null;
                try {
                    seedTopicEmbedding = await getEmbeddings(seedTopic, openaiApiKey, proxyUrl);
                } catch (e) {
                    console.warn('Failed to get seed topic embedding:', e);
                }

                const seedTopicSimilarities = {};
                if (seedTopicEmbedding) {
                    urls.forEach(url => {
                        if (resultsByUrl[url].embedding) {
                            const similarity = cosineSimilarity(seedTopicEmbedding, resultsByUrl[url].embedding);
                            seedTopicSimilarities[url] = Math.round(similarity * 100) / 100;
                            resultsByUrl[url].seedTopicSimilarity = seedTopicSimilarities[url];
                        }
                    });
                }

                // Step 6: Get search intent for ranking keywords
                const allKeywords = [];
                urls.forEach(u => {
                    (resultsByUrl[u].rankingKeywords || []).forEach(k => {
                        if (k?.keyword) allKeywords.push(k.keyword);
                    });
                });
                const uniqueKeywords = Array.from(new Set(allKeywords));
                const intentMapGlobal = {};
                if (uniqueKeywords.length > 0) {
                    try {
                        const siResp = await fetch(proxyUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ apiKey, method: 'searchIntent', params: { locale, keywords: uniqueKeywords } }),
                            signal: opensignal.signal
                        });
                        const siData = await siResp.json();
                        if (siResp.ok && Array.isArray(siData)) {
                            siData.forEach(entry => {
                                if (entry.status === 'success') {
                                    const kw = entry?.data?.serp_query?.keyword;
                                    const primary = (entry?.data?.keyword_intent?.primary_intents || [])[0] || 'Unknown';
                                    intentMapGlobal[kw] = primary.charAt(0).toUpperCase() + primary.slice(1).toLowerCase();
                                }
                            });
                        }
                    } catch (e) {
                        console.warn('Failed to fetch search intent:', e);
                    }
                }

                // Attach intent maps and determine primary intent
                urls.forEach(u => {
                    const map = {};
                    const counts = { Informational: 0, Transactional: 0, Commercial: 0, Navigational: 0, Unknown: 0 };
                    (resultsByUrl[u].rankingKeywords || []).forEach(k => {
                        const intent = intentMapGlobal[k.keyword] || 'Unknown';
                        map[k.keyword] = intent;
                        counts[intent]++;
                    });
                    const total = Math.max(1, (resultsByUrl[u].rankingKeywords || []).length);
                    resultsByUrl[u].searchIntent = map;
                    resultsByUrl[u].intentDistribution = {
                        Informational: Math.round((counts.Informational / total) * 100),
                        Transactional: Math.round((counts.Transactional / total) * 100),
                        Commercial: Math.round((counts.Commercial / total) * 100),
                        Navigational: Math.round((counts.Navigational / total) * 100),
                        Unknown: Math.round((counts.Unknown / total) * 100)
                    };
                    
                    // Determine primary intent (highest percentage from ranking keywords)
                    let primaryIntent = 'Other';
                    let maxCount = 0;
                    Object.entries(counts).forEach(([intent, count]) => {
                        if (count > maxCount && intent !== 'Unknown') {
                            maxCount = count;
                            primaryIntent = intent;
                        }
                    });
                    if (maxCount === 0) primaryIntent = 'Other';
                    resultsByUrl[u].primaryIntent = primaryIntent;
                    resultsByUrl[u].primaryIntentSource = 'ranking_keywords';
                });

                // Step 6b: Use OpenAI to determine primary intent for URLs without ranking keywords
                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Analyzing content for intent classification...</span>';
                const urlsNeedingIntentAnalysis = urls.filter(u => {
                    const rkCount = (resultsByUrl[u].rankingKeywords || []).length;
                    return rkCount === 0 && resultsByUrl[u].content && resultsByUrl[u].content.length > 100;
                });

                if (urlsNeedingIntentAnalysis.length > 0) {
                    // Process intent analysis in batches with delays to avoid rate limits
                    await processInBatches(
                        urlsNeedingIntentAnalysis,
                        3, // Process 3 at a time (smaller batch for intent analysis)
                        3000, // 3 second delay between batches
                        async (url, index) => {
                            try {
                                allDOMElements.submitBtn.innerHTML = `<div class="spinner"></div><span class="ml-2">Analyzing intent... ${index + 1}/${urlsNeedingIntentAnalysis.length}</span>`;
                                const contentPreview = resultsByUrl[url].content.substring(0, 2000);
                                const analysisPrompt = `Classify the PRIMARY search intent of the content below.

Choose exactly ONE intent: Informational, Commercial, Navigational, Transactional.

Return ONLY the intent name.

Content:
${contentPreview}`;
                                
                                const response = await analyzeWithOpenAI({ analysisData: { prompt: analysisPrompt } }, openaiApiKey, proxyUrl, model);
                                const intentFromAI = response.trim().split('\n')[0].trim();
                                const validIntents = ['Informational', 'Commercial', 'Navigational', 'Transactional'];
                                if (validIntents.includes(intentFromAI)) {
                                    resultsByUrl[url].primaryIntent = intentFromAI;
                                    resultsByUrl[url].primaryIntentSource = 'openai_content_analysis';
                                }
                            } catch (e) {
                                console.warn(`Failed to analyze intent for ${url}:`, e);
                                resultsByUrl[url].errors = resultsByUrl[url].errors || [];
                                resultsByUrl[url].errors.push('Intent Analysis: ' + e.message);
                            }
                        },
                        (processed, total) => {
                            allDOMElements.submitBtn.innerHTML = `<div class="spinner"></div><span class="ml-2">Analyzing intent... ${processed}/${total}</span>`;
                        }
                    );
                }

                // Step 7: Group URLs by primary intent
                const intentGroups = {
                    Informational: [],
                    Commercial: [],
                    Navigational: [],
                    Transactional: [],
                    Other: []
                };
                urls.forEach(u => {
                    const intent = resultsByUrl[u].primaryIntent || 'Other';
                    intentGroups[intent].push(u);
                });

                // Step 8: Calculate URL value scores based on Moz metrics
                // Value Score Formula:
                // (Ranking Keywords Count √ó 2.0) + (Linking Domains √ó 1.5) + (Inbound Links √ó 0.5) + (Page Authority √ó 0.1) + (Anchor Text Diversity √ó 0.3)
                // This weighted formula prioritizes ranking keywords and linking domains as indicators of page value
                urls.forEach(u => {
                    const sm = resultsByUrl[u].siteMetrics?.data?.site_metrics || {};
                    const rankingKeywordsCount = (resultsByUrl[u].rankingKeywords || []).length;
                    const inboundLinks = typeof sm.external_pages_to_page === 'number' ? sm.external_pages_to_page : 0;
                    const linkingDomains = typeof sm.root_domains_to_page === 'number' ? sm.root_domains_to_page : 0;
                    const pageAuthority = typeof sm.page_authority === 'number' ? sm.page_authority : 0;
                    const anchorTextsCount = (resultsByUrl[u].topAnchors || []).length;
                    
                    // Calculate value score (weighted)
                    const valueScore = (
                        (rankingKeywordsCount * 2) +           // Ranking keywords are most important
                        (linkingDomains * 1.5) +               // Linking domains
                        (inboundLinks * 0.5) +                  // Total links
                        (pageAuthority * 0.1) +                 // Page authority
                        (anchorTextsCount * 0.3)                // Anchor text diversity
                    );
                    
                    resultsByUrl[u].valueScore = Math.round(valueScore * 10) / 10;
                    resultsByUrl[u].mozMetrics = {
                        rankingKeywordsCount,
                        inboundLinks,
                        linkingDomains,
                        pageAuthority,
                        anchorTextsCount
                    };
                });

                // Step 9: Identify consolidation clusters
                // Only consolidate if: VERY similar to each other (>0.9) AND have keyword overlaps
                const consolidationClusters = [];
                const processedUrls = new Set();
                
                // Calculate URL-to-URL similarity matrix for consolidation
                const urlSimilarityMatrix = {};
                for (let i = 0; i < urls.length; i++) {
                    for (let j = i + 1; j < urls.length; j++) {
                        const url1 = urls[i];
                        const url2 = urls[j];
                        if (resultsByUrl[url1].embedding && resultsByUrl[url2].embedding) {
                            const similarity = cosineSimilarity(resultsByUrl[url1].embedding, resultsByUrl[url2].embedding);
                            if (!urlSimilarityMatrix[url1]) urlSimilarityMatrix[url1] = {};
                            if (!urlSimilarityMatrix[url2]) urlSimilarityMatrix[url2] = {};
                            urlSimilarityMatrix[url1][url2] = similarity;
                            urlSimilarityMatrix[url2][url1] = similarity;
                        }
                    }
                }
                
                // Find keyword overlaps between URLs
                const keywordOverlaps = {};
                urls.forEach(u1 => {
                    urls.forEach(u2 => {
                        if (u1 === u2) return;
                        const keywords1 = new Set((resultsByUrl[u1].rankingKeywords || []).map(k => k.keyword?.toLowerCase()).filter(Boolean));
                        const keywords2 = new Set((resultsByUrl[u2].rankingKeywords || []).map(k => k.keyword?.toLowerCase()).filter(Boolean));
                        const overlap = [...keywords1].filter(k => keywords2.has(k));
                        if (overlap.length > 0) {
                            if (!keywordOverlaps[u1]) keywordOverlaps[u1] = {};
                            keywordOverlaps[u1][u2] = overlap;
                        }
                    });
                });
                
                urls.forEach(u => {
                    if (processedUrls.has(u)) return;
                    
                    const cluster = [u];
                    const uIntent = resultsByUrl[u].primaryIntent;
                    
                    urls.forEach(v => {
                        if (u === v || processedUrls.has(v)) return;
                        
                        const vIntent = resultsByUrl[v].primaryIntent;
                        const urlToUrlSimilarity = urlSimilarityMatrix[u]?.[v] || 0;
                        const hasKeywordOverlap = keywordOverlaps[u]?.[v] && keywordOverlaps[u][v].length > 0;
                        
                        // VERY similar (>0.9) AND same intent AND have keyword overlaps
                        if (uIntent === vIntent && urlToUrlSimilarity >= 0.9 && hasKeywordOverlap) {
                            cluster.push(v);
                            processedUrls.add(v);
                        }
                    });
                    
                    if (cluster.length > 1) {
                        processedUrls.add(u);
                        // Collect all overlapping keywords for the cluster
                        const clusterKeywords = new Set();
                        cluster.forEach(url1 => {
                            cluster.forEach(url2 => {
                                if (url1 !== url2 && keywordOverlaps[url1]?.[url2]) {
                                    keywordOverlaps[url1][url2].forEach(kw => clusterKeywords.add(kw));
                                }
                            });
                        });
                        
                        const clusterLength = cluster.length || 1; // Prevent division by zero
                        const totalVal = cluster.reduce((sum, url) => sum + (resultsByUrl[url]?.valueScore || 0), 0);
                        consolidationClusters.push({
                            urls: cluster,
                            intent: uIntent,
                            avgSimilarity: cluster.reduce((sum, url) => sum + (seedTopicSimilarities[url] || 0), 0) / clusterLength,
                            avgValue: totalVal / clusterLength,
                            totalValue: totalVal,
                            urlToUrlSimilarity: urlSimilarityMatrix[cluster[0]]?.[cluster[1]] || 0,
                            overlappingKeywords: Array.from(clusterKeywords)
                        });
                    }
                });

                // Step 9b: Analyze consolidation clusters with OpenAI
                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Analyzing consolidation opportunities...</span>';
                if (consolidationClusters.length > 0) {
                    for (const cluster of consolidationClusters) {
                        try {
                            const clusterData = cluster.urls.map(url => ({
                                url,
                                contentPreview: (resultsByUrl[url].content || '').substring(0, 500),
                                rankingKeywords: (resultsByUrl[url].rankingKeywords || []).slice(0, 10).map(k => k.keyword),
                                valueScore: resultsByUrl[url].valueScore || 0,
                                linkingDomains: resultsByUrl[url].mozMetrics?.linkingDomains || 0,
                                rankingKeywordsCount: resultsByUrl[url].mozMetrics?.rankingKeywordsCount || 0
                            }));

                            // Find the best keyword to optimize for based on overlaps and opportunities
                            const overlappingKeywords = cluster.overlappingKeywords || [];
                            const allKeywords = new Set();
                            cluster.urls.forEach(url => {
                                (resultsByUrl[url].rankingKeywords || []).forEach(k => {
                                    if (k.keyword) allKeywords.add(k.keyword.toLowerCase());
                                });
                            });
                            
                            // Find most common overlapping keyword, or highest volume keyword
                            let optimizeForKeyword = seedTopic;
                            if (overlappingKeywords.length > 0) {
                                // Use the most common overlapping keyword
                                optimizeForKeyword = overlappingKeywords[0];
                            } else {
                                // Find highest volume keyword from cluster
                                let maxVolume = 0;
                                cluster.urls.forEach(url => {
                                    (resultsByUrl[url].rankingKeywords || []).forEach(k => {
                                        if (k.volume && k.volume > maxVolume) {
                                            maxVolume = k.volume;
                                            optimizeForKeyword = k.keyword;
                                        }
                                    });
                                });
                            }
                            
                            // Determine which URL to keep (highest value score)
                            let urlToKeep = cluster.urls[0];
                            let maxValue = resultsByUrl[cluster.urls[0]].valueScore || 0;
                            cluster.urls.forEach(url => {
                                const value = resultsByUrl[url].valueScore || 0;
                                if (value > maxValue) {
                                    maxValue = value;
                                    urlToKeep = url;
                                }
                            });

                            const analysisPrompt = `Explain why the pages in this cluster should be consolidated into a single page. Base your reasoning strictly on overlap in topics, keywords, search intent, or user value.

Return ONLY this JSON:
{
  "consolidationReason": "text"
}

Cluster Data:
${JSON.stringify(clusterData, null, 2)}`;

                            const response = await analyzeWithOpenAI({ analysisData: { prompt: analysisPrompt } }, openaiApiKey, proxyUrl, model);
                            try {
                                // Extract JSON from markdown code blocks if present
                                let jsonStr = response.trim();
                                if (jsonStr.includes('```json')) {
                                    jsonStr = jsonStr.split('```json')[1].split('```')[0].trim();
                                } else if (jsonStr.includes('```')) {
                                    jsonStr = jsonStr.split('```')[1].split('```')[0].trim();
                                }
                                const analysis = JSON.parse(jsonStr);
                                cluster.aiAnalysis = {
                                    ...analysis,
                                    urlToKeep: urlToKeep,
                                    subtopicToOptimize: optimizeForKeyword
                                };
                            } catch {
                                // If not JSON, use defaults
                                cluster.aiAnalysis = {
                                    consolidationReason: response.substring(0, 500),
                                    urlToKeep: urlToKeep,
                                    subtopicToOptimize: optimizeForKeyword
                                };
                            }
                        } catch (e) {
                            console.warn(`Failed to analyze cluster:`, e);
                            cluster.aiAnalysis = {
                                consolidationReason: 'Analysis unavailable',
                                urlToKeep: cluster.urls[0],
                                subtopicToOptimize: seedTopic
                            };
                        }
                    }
                }

                // Step 10: Identify MAIN topic page
                // Prioritize value score first, then use similarity as tiebreaker
                // Only consider URLs with ranking keywords (value score > 0)
                let mainTopicPage = null;
                let mainTopicScore = -1;
                urls.forEach(u => {
                    const value = resultsByUrl[u].valueScore || 0;
                    const similarity = seedTopicSimilarities[u] || 0;
                    const rankingKeywordsCount = resultsByUrl[u].mozMetrics?.rankingKeywordsCount || 0;
                    
                    // Only consider URLs with ranking keywords
                    if (rankingKeywordsCount === 0) return;
                    
                    // Primary sort: value score, Secondary sort: similarity
                    const combinedScore = (value * 1000) + similarity; // Value score weighted 1000x more
                    if (combinedScore > mainTopicScore) {
                        mainTopicScore = combinedScore;
                        mainTopicPage = u;
                    }
                });

                // Internal linking strategy removed per user request

                // Step 12: Generate Content Recommendations
                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Generating content recommendations...</span>';
                let contentRecommendations = null;
                try {
                    const recommendationsData = {
                        seedTopic,
                        urls: urls.map(u => ({
                            url: u,
                            rankingKeywords: (resultsByUrl[u].rankingKeywords || []).slice(0, 15).map(k => k.keyword),
                            primaryIntent: resultsByUrl[u].primaryIntent,
                            contentPreview: (resultsByUrl[u].content || '').substring(0, 300)
                        })),
                        relatedKeywords: relatedKeywords.slice(0, 30)
                    };

                    const currentYear = new Date().getFullYear();
                    const recommendationsPrompt = `You are an SEO content strategist. Analyze the URLs and their ranking keywords for the seed topic "${seedTopic}".

Your task is to provide DETAILED, SPECIFIC content improvement recommendations.

For each URL, your recommendations MUST include:
1. Subtopic gaps: specific sections, angles, or themes missing from the page.
2. SERP-aligned enhancements: what competing top-ranking pages commonly include (structures, examples, comparison tables, FAQs, data visuals).
3. Content depth improvements: additional explanations, definitions, step-by-step guidance, use cases, or real-world examples.
4. Asset opportunities: templates, calculators, checklists, visuals, diagrams, or downloadable resources that should be added.
5. Keyword-targeting improvements: semantically related terms the page should incorporate based strictly on the provided keyword data.
6. Internal linking ideas: which topics or pages could be linked to strengthen topical authority.

IMPORTANT:
- All recommendations must strictly relate to the seed topic. 
- Do NOT invent unrelated SEO themes like Local SEO unless it appears in the data.
- When referencing years, ALWAYS use: ${currentYear}.
- Be specific. Avoid vague suggestions like "improve content."

Return ONLY this JSON structure:
{
  "recommendations": [
    {
      "url": "url",
      "recommendations": ["specific recommendation 1", "specific recommendation 2"]
    }
  ],
  "generalRecommendations": ["specific general recommendation 1", "specific general recommendation 2"]
}

Data:
${JSON.stringify(recommendationsData, null, 2)}`;

                    const recommendationsResponse = await analyzeWithOpenAI({ analysisData: { prompt: recommendationsPrompt } }, openaiApiKey, proxyUrl, model);
                    try {
                        // Extract JSON from markdown code blocks if present
                        let jsonStr = recommendationsResponse.trim();
                        if (jsonStr.includes('```json')) {
                            jsonStr = jsonStr.split('```json')[1].split('```')[0].trim();
                        } else if (jsonStr.includes('```')) {
                            jsonStr = jsonStr.split('```')[1].split('```')[0].trim();
                        }
                        contentRecommendations = JSON.parse(jsonStr);
                    } catch {
                        // If parsing fails, try to extract recommendations from text
                        const lines = recommendationsResponse.split('\n').filter(l => l.trim());
                        contentRecommendations = { 
                            generalRecommendations: lines.length > 0 ? lines : [recommendationsResponse] 
                        };
                    }
                } catch (e) {
                    console.warn('Failed to generate content recommendations:', e);
                    contentRecommendations = { error: e.message };
                }

                // Step 13: Generate New Content to Create
                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Identifying new content opportunities...</span>';
                let newContentToCreate = null;
                try {
                    const newContentData = {
                        seedTopic,
                        existingUrls: urls.map(u => ({
                            url: u,
                            rankingKeywords: (resultsByUrl[u].rankingKeywords || []).slice(0, 10).map(k => k.keyword),
                            primaryIntent: resultsByUrl[u].primaryIntent
                        })),
                        relatedKeywords: relatedKeywords.slice(0, 50),
                        intentGroups: Object.entries(intentGroups).map(([intent, urls]) => ({ intent, count: urls.length }))
                    };

                    const newContentPrompt = `You are an SEO content strategist. Based on the seed topic "${seedTopic}" and the existing content, identify new content opportunities.

Your ideas must follow these rules:
- All ideas must be subtopics or expansions of the seed topic.
- Do NOT suggest unrelated SEO themes (e.g., Local SEO, link building) unless directly supported by the data.
- Do NOT infer Local intent unless geographic modifiers are explicitly present.
- Ideas must fill actual gaps in the existing content set.
- Each content idea must represent a unique angle, not a duplicate of existing pages.

IMPORTANT:
Do NOT suggest "local" topics, "near me" content, or Local intent pages unless the seed topic explicitly contains local/geographic language. You must NOT infer a Local intent unless it is directly present in the seed topic or keyword set.

You must NOT propose content related to "Local SEO", "local search", geographic modifiers, "near me" keywords, or local intent unless the seed topic itself directly includes local modifiers. If the seed topic is not local, exclude any local-related ideas.

All new content ideas must be strictly based on subtopics directly related to the seed topic. Do NOT propose unrelated SEO themes (e.g., Local SEO, link building, social media, analytics, etc.) unless explicitly present in the provided data.

For each idea, provide:
- A clear content title
- One valid intent: Informational, Commercial, Navigational, or Transactional
- 2‚Äì6 target keywords aligned with the seed topic
- A rationale explaining *why* this is a meaningful gap based on the provided URLs, keywords, and intent distribution

Return ONLY this JSON:
{
  "newContentIdeas": [
    {
      "title": "Content title",
      "intent": "Informational|Commercial|Navigational|Transactional",
      "targetKeywords": ["keyword1", "keyword2"],
      "rationale": "text"
    }
  ]
}

Data:
${JSON.stringify(newContentData, null, 2)}`;

                    const newContentResponse = await analyzeWithOpenAI({ analysisData: { prompt: newContentPrompt } }, openaiApiKey, proxyUrl, model);
                    try {
                        // Extract JSON from markdown code blocks if present
                        let jsonStr = newContentResponse.trim();
                        if (jsonStr.includes('```json')) {
                            jsonStr = jsonStr.split('```json')[1].split('```')[0].trim();
                        } else if (jsonStr.includes('```')) {
                            jsonStr = jsonStr.split('```')[1].split('```')[0].trim();
                        }
                        newContentToCreate = JSON.parse(jsonStr);
                        
                        // Enhance target keywords: fetch related keywords, get metrics, and select best (relevance + volume)
                        if (newContentToCreate.newContentIdeas && Array.isArray(newContentToCreate.newContentIdeas)) {
                            for (const idea of newContentToCreate.newContentIdeas) {
                                if (idea.targetKeywords && Array.isArray(idea.targetKeywords) && idea.targetKeywords.length > 0) {
                                    idea.keywordMetrics = {};
                                    const originalKeywords = idea.targetKeywords.slice(0, 5); // Limit to 5 original keywords per idea
                                    const allCandidateKeywords = new Map(); // keyword -> { relevance, volume, difficulty, opportunity_ctr, source }
                                    
                                    // Step 1: Get metrics for original keywords and add them as candidates
                                    for (const keyword of originalKeywords) {
                                        try {
                                            const kmResp = await fetch(proxyUrl, {
                                                method: 'POST',
                                                headers: { 'Content-Type': 'application/json' },
                                                body: JSON.stringify({ 
                                                    apiKey, 
                                                    method: 'keywordMetrics', 
                                                    params: { 
                                                        metricType: 'all',
                                                        locale: locale,
                                                        keywords: [keyword]
                                                    } 
                                                }),
                                                signal: opensignal.signal
                                            });
                                            const kmData = await kmResp.json();
                                            if (kmResp.ok && Array.isArray(kmData) && kmData[0]?.status === 'success') {
                                                const volume = kmData[0]?.data?.keyword_metrics?.volume ?? null;
                                                const difficulty = kmData[0]?.data?.keyword_metrics?.difficulty ?? null;
                                                const opportunity_ctr = kmData[0]?.data?.keyword_metrics?.organic_ctr ?? null;
                                                
                                                allCandidateKeywords.set(keyword, {
                                                    relevance: 100, // Original keywords get max relevance
                                                    volume: volume,
                                                    difficulty: difficulty,
                                                    opportunity_ctr: opportunity_ctr,
                                                    source: 'original'
                                                });
                                            }
                                        } catch (e) {
                                            // Non-fatal, continue
                                        }
                                    }
                                    
                                    // Step 2: For each original keyword, fetch related keywords
                                    for (const keyword of originalKeywords) {
                                        try {
                                            const rkResp = await fetch(proxyUrl, {
                                                method: 'POST',
                                                headers: { 'Content-Type': 'application/json' },
                                                body: JSON.stringify({ 
                                                    apiKey, 
                                                    method: 'relatedKeywords', 
                                                    params: { 
                                                        locale: locale,
                                                        keywords: [keyword]
                                                    } 
                                                }),
                                                signal: opensignal.signal
                                            });
                                            const rkData = await rkResp.json();
                                            if (rkResp.ok && Array.isArray(rkData) && rkData[0]?.status === 'success' && rkData[0]?.data?.suggestions) {
                                                const suggestions = rkData[0].data.suggestions.slice(0, 10); // Limit to top 10 related keywords
                                                
                                                // Step 3: Get metrics for related keywords
                                                for (const suggestion of suggestions) {
                                                    const relatedKw = suggestion.keyword;
                                                    const relevance = suggestion.relevance || 0;
                                                    
                                                    // Skip if we already have this keyword
                                                    if (allCandidateKeywords.has(relatedKw)) {
                                                        // Update relevance if higher
                                                        const existing = allCandidateKeywords.get(relatedKw);
                                                        if (relevance > existing.relevance) {
                                                            existing.relevance = relevance;
                                                        }
                                                        continue;
                                                    }
                                                    
                                                    try {
                                                        const kmResp = await fetch(proxyUrl, {
                                                            method: 'POST',
                                                            headers: { 'Content-Type': 'application/json' },
                                                            body: JSON.stringify({ 
                                                                apiKey, 
                                                                method: 'keywordMetrics', 
                                                                params: { 
                                                                    metricType: 'all',
                                                                    locale: locale,
                                                                    keywords: [relatedKw]
                                                                } 
                                                            }),
                                                            signal: opensignal.signal
                                                        });
                                                        const kmData = await kmResp.json();
                                                        if (kmResp.ok && Array.isArray(kmData) && kmData[0]?.status === 'success') {
                                                            const volume = kmData[0]?.data?.keyword_metrics?.volume ?? null;
                                                            const difficulty = kmData[0]?.data?.keyword_metrics?.difficulty ?? null;
                                                            const opportunity_ctr = kmData[0]?.data?.keyword_metrics?.organic_ctr ?? null;
                                                            
                                                            allCandidateKeywords.set(relatedKw, {
                                                                relevance: relevance,
                                                                volume: volume,
                                                                difficulty: difficulty,
                                                                opportunity_ctr: opportunity_ctr,
                                                                source: 'related'
                                                            });
                                                        }
                                                    } catch (e) {
                                                        // Non-fatal, continue
                                                    }
                                                }
                                            }
                                        } catch (e) {
                                            // Non-fatal, continue
                                        }
                                    }
                                    
                                    // Step 4: Sort candidates by combined score (relevance + volume)
                                    // Score = (relevance * 0.4) + (normalized_volume * 0.6)
                                    const candidatesArray = Array.from(allCandidateKeywords.entries()).map(([kw, data]) => ({
                                        keyword: kw,
                                        ...data
                                    }));
                                    
                                    // Normalize volume (0-100 scale) and calculate score
                                    const volumes = candidatesArray.map(c => c.volume || 0).filter(v => v > 0);
                                    const maxVolume = volumes.length > 0 ? Math.max(...volumes) : 1;
                                    
                                    candidatesArray.forEach(c => {
                                        const normalizedVolume = c.volume ? (c.volume / maxVolume) * 100 : 0;
                                        c.score = (c.relevance * 0.4) + (normalizedVolume * 0.6);
                                    });
                                    
                                    // Sort by score (descending) and take top 5 keywords
                                    candidatesArray.sort((a, b) => b.score - a.score);
                                    const bestKeywords = candidatesArray.slice(0, 5).map(c => c.keyword);
                                    
                                    // Update idea with enhanced keywords
                                    idea.targetKeywords = bestKeywords;
                                    
                                    // Store metrics for all selected keywords
                                    bestKeywords.forEach(kw => {
                                        const candidate = candidatesArray.find(c => c.keyword === kw);
                                        if (candidate) {
                                            idea.keywordMetrics[kw] = {
                                                volume: candidate.volume,
                                                difficulty: candidate.difficulty,
                                                opportunity_ctr: candidate.opportunity_ctr
                                            };
                                        }
                                    });
                                }
                            }
                        }
                    } catch {
                        // If parsing fails, create a single idea from the response
                        newContentToCreate = { 
                            newContentIdeas: [{ 
                                title: newContentResponse.substring(0, 100), 
                                intent: 'Informational', 
                                targetKeywords: [], 
                                rationale: newContentResponse 
                            }] 
                        };
                    }
                } catch (e) {
                    console.warn('Failed to generate new content ideas:', e);
                    newContentToCreate = { error: e.message };
                }

                return {
                    seedTopic,
                    urls,
                    locale,
                    limit,
                    similarityThreshold,
                    resultsByUrl,
                    seedTopicSimilarities,
                    intentGroups,
                    consolidationClusters,
                    mainTopicPage,
                    relatedKeywords: relatedKeywords.slice(0, 50),
                    contentRecommendations,
                    newContentToCreate
                };
            }

            // K-means clustering implementation
            function kMeansClustering(embeddings, k, maxIterations = 100) {
                const n = embeddings.length;
                if (n === 0) return [];
                if (n <= k) {
                    // Each point is its own cluster
                    return embeddings.map((_, i) => [i]);
                }

                // Initialize centroids randomly
                const centroids = [];
                const indices = Array.from({ length: n }, (_, i) => i);
                for (let i = 0; i < k; i++) {
                    const randomIdx = indices[Math.floor(Math.random() * indices.length)];
                    centroids.push([...embeddings[randomIdx]]);
                    indices.splice(indices.indexOf(randomIdx), 1);
                }

                let clusters = Array(k).fill(null).map(() => []);
                let prevClusters = null;
                let iterations = 0;

                while (iterations < maxIterations) {
                    // Assign points to nearest centroid (using cosine similarity - higher is better)
                    clusters = Array(k).fill(null).map(() => []);
                    embeddings.forEach((embedding, idx) => {
                        let maxSimilarity = -Infinity;
                        let nearestCentroid = 0;
                        centroids.forEach((centroid, cIdx) => {
                            const similarity = cosineSimilarity(embedding, centroid);
                            if (similarity > maxSimilarity) {
                                maxSimilarity = similarity;
                                nearestCentroid = cIdx;
                            }
                        });
                        clusters[nearestCentroid].push(idx);
                    });

                    // Check for convergence
                    if (prevClusters && JSON.stringify(clusters) === JSON.stringify(prevClusters)) {
                        break;
                    }
                    prevClusters = JSON.parse(JSON.stringify(clusters));

                    // Update centroids
                    centroids.forEach((centroid, cIdx) => {
                        if (clusters[cIdx].length === 0) return;
                        const dim = centroid.length;
                        for (let d = 0; d < dim; d++) {
                            let sum = 0;
                            clusters[cIdx].forEach(idx => {
                                sum += embeddings[idx][d];
                            });
                            centroid[d] = sum / clusters[cIdx].length;
                        }
                    });

                    iterations++;
                }

                return clusters.filter(c => c.length > 0);
            }

            // Determine optimal number of clusters using elbow method (simplified)
            function determineOptimalClusters(embeddings, maxK = 10) {
                const n = embeddings.length;
                if (n <= 3) return n;
                const actualMaxK = Math.min(maxK, Math.floor(n / 2));
                if (actualMaxK < 2) return 2;

                // Use a simple heuristic: sqrt(n/2) or between 3-10
                const k = Math.max(3, Math.min(actualMaxK, Math.ceil(Math.sqrt(n / 2))));
                return k;
            }

            async function runContentClustersIdentification(openaiApiKey, params, proxyUrl, opensignal) {
                const { urls, scope, contentClusters, model = 'gpt-3.5-turbo' } = params;
                const resultsByUrl = {};

                // Step 1: Fetch and clean HTML content for each URL
                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Fetching content from ' + urls.length + ' URLs...</span>';
                const contentPromises = urls.map(async (url) => {
                    try {
                        const content = await extractPageContent(url, proxyUrl);
                        resultsByUrl[url] = {
                            url,
                            rawContent: content,
                            summary: '',
                            embedding: null,
                            llmDefinedTopic: '',
                            llmCluster: '',
                            contentCluster: '',
                            primaryIntent: '',
                            audience: '',
                            expertiseLevel: '',
                            topicTags: [],
                            errors: []
                        };
                    } catch (error) {
                        resultsByUrl[url] = {
                            url,
                            rawContent: '',
                            summary: '',
                            embedding: null,
                            llmDefinedTopic: '',
                            llmCluster: '',
                            contentCluster: '',
                            primaryIntent: '',
                            audience: '',
                            expertiseLevel: '',
                            topicTags: [],
                            errors: [error.message]
                        };
                    }
                });
                await Promise.all(contentPromises);

                // Step 2: Summarize each page (optional but recommended) - Process in batches to avoid rate limits
                const urlsToSummarize = urls.filter(url => resultsByUrl[url].errors.length === 0 && resultsByUrl[url].rawContent);
                await processInBatches(
                    urlsToSummarize,
                    3, // Process 3 at a time (reduced for rate limit safety)
                    3000, // 3 second delay between items (increased for rate limit safety)
                    async (url, index) => {
                        try {
                            allDOMElements.submitBtn.innerHTML = `<div class="spinner"></div><span class="ml-2">Summarizing pages... ${index + 1}/${urls.length}</span>`;
                            const summaryPrompt = `Summarize the webpage in 2‚Äì3 concise sentences focusing only on the main subject and core points. Do not include assumptions.

Content:
${resultsByUrl[url].rawContent.substring(0, 4000)}

Return summary only.`;
                            // Use selected model for summaries
                            const summary = await analyzeWithOpenAI({ analysisData: { prompt: summaryPrompt } }, openaiApiKey, proxyUrl, model);
                            resultsByUrl[url].summary = summary.trim();
                        } catch (error) {
                            resultsByUrl[url].errors.push('Summary: ' + error.message);
                            resultsByUrl[url].summary = resultsByUrl[url].rawContent.substring(0, 500);
                        }
                    },
                    (processed, total) => {
                        allDOMElements.submitBtn.innerHTML = `<div class="spinner"></div><span class="ml-2">Summarizing pages... ${processed}/${total}</span>`;
                    }
                );
                
                // Set empty summaries for URLs that were skipped
                urls.forEach(url => {
                    if (!resultsByUrl[url].summary && resultsByUrl[url].errors.length === 0) {
                        resultsByUrl[url].summary = '';
                    }
                });

                // Step 3: Create embeddings for each page summary - Process in batches to avoid rate limits
                const urlsToEmbed = urls.filter(url => resultsByUrl[url].errors.length === 0 && resultsByUrl[url].summary);
                await processInBatches(
                    urlsToEmbed,
                    10, // Process 10 at a time (embeddings are faster)
                    1500, // 1.5 second delay between batches
                    async (url, index) => {
                        try {
                            allDOMElements.submitBtn.innerHTML = `<div class="spinner"></div><span class="ml-2">Creating embeddings... ${index + 1}/${urls.length}</span>`;
                            const embedding = await getEmbeddings(resultsByUrl[url].summary, openaiApiKey, proxyUrl);
                            resultsByUrl[url].embedding = embedding;
                        } catch (error) {
                            resultsByUrl[url].errors.push('Embedding: ' + error.message);
                        }
                    },
                    (processed, total) => {
                        allDOMElements.submitBtn.innerHTML = `<div class="spinner"></div><span class="ml-2">Creating embeddings... ${processed}/${total}</span>`;
                    }
                );

                // Step 4: Cluster embeddings
                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Clustering content...</span>';
                const validUrls = urls.filter(url => resultsByUrl[url].embedding && resultsByUrl[url].embedding.length > 0);
                const embeddings = validUrls.map(url => resultsByUrl[url].embedding);
                let clusters = [];
                
                if (embeddings.length > 0) {
                    const k = determineOptimalClusters(embeddings);
                    clusters = kMeansClustering(embeddings, k);
                }

                // Step 5: Label clusters using GPT - Process sequentially with delays
                allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Labeling clusters...</span>';
                const clusterLabels = [];
                for (let i = 0; i < clusters.length; i++) {
                    allDOMElements.submitBtn.innerHTML = `<div class="spinner"></div><span class="ml-2">Labeling clusters... ${i + 1}/${clusters.length}</span>`;
                    
                    const clusterUrls = clusters[i].map(idx => validUrls[idx]);
                    const clusterPages = clusterUrls.map(url => ({
                        url,
                        title: url.split('/').pop() || url,
                        summary: resultsByUrl[url].summary || 'No summary available'
                    }));

                    try {
                        const clusterPrompt = `Analyze the pages in this cluster and produce content cluster metadata.

Return ONLY this JSON:
{
  "clusterName": "short name (2-5 words)",
  "description": "1‚Äì2 sentence description",
  "topicTags": ["tag1", "tag2", "tag3"],
  "dominantIntent": "Informational | Commercial | Transactional | Navigational | Local",
  "funnelStages": ["Awareness", "Consideration"]
}

Pages:
${JSON.stringify(clusterPages, null, 2)}`;

                        // Use selected model for cluster labeling
                        const clusterLabelResponse = await analyzeWithOpenAI({ analysisData: { prompt: clusterPrompt } }, openaiApiKey, proxyUrl, model);
                        let clusterLabel;
                        try {
                            let jsonStr = clusterLabelResponse.trim();
                            if (jsonStr.includes('```json')) {
                                jsonStr = jsonStr.split('```json')[1].split('```')[0].trim();
                            } else if (jsonStr.includes('```')) {
                                jsonStr = jsonStr.split('```')[1].split('```')[0].trim();
                            }
                            clusterLabel = JSON.parse(jsonStr);
                        } catch {
                            // Fallback parsing
                            clusterLabel = {
                                clusterName: `Cluster ${i + 1}`,
                                description: clusterLabelResponse.substring(0, 200),
                                topicTags: [],
                                dominantIntent: 'Informational',
                                funnelStages: ['Awareness']
                            };
                        }
                        clusterLabels.push({ clusterIndex: i, ...clusterLabel });
                    } catch (error) {
                        clusterLabels.push({
                            clusterIndex: i,
                            clusterName: `Cluster ${i + 1}`,
                            description: 'Unable to generate description',
                            topicTags: [],
                            dominantIntent: 'Informational',
                            funnelStages: ['Awareness']
                        });
                    }
                    
                    // Add delay between cluster labeling calls (except for the last one)
                    if (i < clusters.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                }

                // Step 6: Map pages to clusters and assign cluster info
                const urlToClusterIndex = {};
                clusters.forEach((cluster, clusterIdx) => {
                    cluster.forEach(urlIdx => {
                        const url = validUrls[urlIdx];
                        urlToClusterIndex[url] = clusterIdx;
                    });
                });

                // Step 7: For each page, get LLM-defined topic and map to content clusters - Process in batches
                const urlsToAnalyze = urls.filter(url => resultsByUrl[url].errors.length === 0 && resultsByUrl[url].summary);
                await processInBatches(
                    urlsToAnalyze,
                    3, // Process 3 at a time (reduced for rate limit safety)
                    3000, // 3 second delay between items (increased for rate limit safety)
                    async (url, index) => {
                        try {
                            allDOMElements.submitBtn.innerHTML = `<div class="spinner"></div><span class="ml-2">Analyzing pages... ${index + 1}/${urls.length}</span>`;
                            
                            const topicPrompt = `Analyze the page summary and extract:

1. Topic (1‚Äì3 words)
2. Primary intent
3. Audience
4. Expertise level

Return ONLY this JSON:
{
  "topic": "text",
  "primaryIntent": "Informational | Commercial | Transactional | Navigational | Local",
  "audience": "text",
  "expertiseLevel": "Beginner | Intermediate | Advanced"
}

Summary:
${resultsByUrl[url].summary}`;

                            // Use selected model for page analysis
                            const topicResponse = await analyzeWithOpenAI({ analysisData: { prompt: topicPrompt } }, openaiApiKey, proxyUrl, model);
                            let pageAnalysis;
                            try {
                                let jsonStr = topicResponse.trim();
                                if (jsonStr.includes('```json')) {
                                    jsonStr = jsonStr.split('```json')[1].split('```')[0].trim();
                                } else if (jsonStr.includes('```')) {
                                    jsonStr = jsonStr.split('```')[1].split('```')[0].trim();
                                }
                                pageAnalysis = JSON.parse(jsonStr);
                            } catch {
                                pageAnalysis = {
                                    topic: 'Unknown',
                                    primaryIntent: 'Informational',
                                    audience: 'General',
                                    expertiseLevel: 'Intermediate'
                                };
                            }

                            resultsByUrl[url].llmDefinedTopic = pageAnalysis.topic || 'Unknown';
                            resultsByUrl[url].primaryIntent = pageAnalysis.primaryIntent || 'Informational';
                            resultsByUrl[url].audience = pageAnalysis.audience || 'General';
                            resultsByUrl[url].expertiseLevel = pageAnalysis.expertiseLevel || 'Intermediate';

                            // Assign cluster info
                            const clusterIdx = urlToClusterIndex[url];
                            if (clusterIdx !== undefined && clusterLabels[clusterIdx]) {
                                const clusterLabel = clusterLabels[clusterIdx];
                                resultsByUrl[url].llmCluster = clusterLabel.clusterName || `Cluster ${clusterIdx + 1}`;
                                resultsByUrl[url].contentCluster = clusterLabel.clusterName || `Cluster ${clusterIdx + 1}`;
                                resultsByUrl[url].topicTags = clusterLabel.topicTags || [];
                            } else {
                                resultsByUrl[url].llmCluster = 'Unassigned';
                                resultsByUrl[url].contentCluster = 'Unassigned';
                                resultsByUrl[url].topicTags = [];
                            }
                        } catch (error) {
                            resultsByUrl[url].errors.push('Page Analysis: ' + error.message);
                            resultsByUrl[url].llmDefinedTopic = 'Unknown';
                            resultsByUrl[url].primaryIntent = 'Informational';
                            resultsByUrl[url].audience = 'General';
                            resultsByUrl[url].expertiseLevel = 'Intermediate';
                        }
                    },
                    (processed, total) => {
                        allDOMElements.submitBtn.innerHTML = `<div class="spinner"></div><span class="ml-2">Analyzing pages... ${processed}/${total}</span>`;
                    }
                );
                
                // Set default values for URLs that were skipped
                urls.forEach(url => {
                    if (!resultsByUrl[url].llmDefinedTopic && resultsByUrl[url].errors.length === 0) {
                        resultsByUrl[url].llmDefinedTopic = 'Unknown';
                        resultsByUrl[url].primaryIntent = 'Informational';
                        resultsByUrl[url].audience = 'General';
                        resultsByUrl[url].expertiseLevel = 'Intermediate';
                        const clusterIdx = urlToClusterIndex[url];
                        if (clusterIdx !== undefined && clusterLabels[clusterIdx]) {
                            const clusterLabel = clusterLabels[clusterIdx];
                            resultsByUrl[url].llmCluster = clusterLabel.clusterName || `Cluster ${clusterIdx + 1}`;
                            resultsByUrl[url].contentCluster = clusterLabel.clusterName || `Cluster ${clusterIdx + 1}`;
                            resultsByUrl[url].topicTags = clusterLabel.topicTags || [];
                        } else {
                            resultsByUrl[url].llmCluster = 'Unassigned';
                            resultsByUrl[url].contentCluster = 'Unassigned';
                            resultsByUrl[url].topicTags = [];
                        }
                    }
                });

                // Step 8: If user provided content clusters, map pages to them
                if (contentClusters && contentClusters.length > 0) {
                    allDOMElements.submitBtn.innerHTML = '<div class="spinner"></div><span class="ml-2">Mapping to user-defined clusters...</span>';
                    
                    // Create embeddings for user-provided clusters - Process sequentially with delays
                    const clusterEmbeddings = {};
                    for (let i = 0; i < contentClusters.length; i++) {
                        const cluster = contentClusters[i];
                        try {
                            allDOMElements.submitBtn.innerHTML = `<div class="spinner"></div><span class="ml-2">Creating cluster embeddings... ${i + 1}/${contentClusters.length}</span>`;
                            const embedding = await getEmbeddings(cluster, openaiApiKey, proxyUrl);
                            clusterEmbeddings[cluster] = embedding;
                            // Small delay between cluster embeddings
                            if (i < contentClusters.length - 1) {
                                await new Promise(resolve => setTimeout(resolve, 1000));
                            }
                        } catch (error) {
                            console.warn(`Failed to create embedding for cluster "${cluster}":`, error);
                        }
                    }

                    // Map each page to the closest user-defined cluster (no API calls needed here)
                    urls.forEach(url => {
                        if (!resultsByUrl[url].embedding || resultsByUrl[url].errors.length > 0) return;

                        let maxSimilarity = -1;
                        let bestCluster = null;
                        Object.entries(clusterEmbeddings).forEach(([clusterName, clusterEmbedding]) => {
                            const similarity = cosineSimilarity(resultsByUrl[url].embedding, clusterEmbedding);
                            if (similarity > maxSimilarity) {
                                maxSimilarity = similarity;
                                bestCluster = clusterName;
                            }
                        });

                        if (bestCluster) {
                            resultsByUrl[url].contentCluster = bestCluster;
                        }
                    });
                }

                return {
                    urls,
                    scope,
                    contentClusters: contentClusters || null,
                    resultsByUrl,
                    clusterLabels,
                    clusters: clusters.map((cluster, idx) => ({
                        clusterIndex: idx,
                        urls: cluster.map(urlIdx => validUrls[urlIdx]),
                        label: clusterLabels[idx] || null
                    }))
                };
            }

            function showKeywordTargetingDashboard(payload) {
                // Hide regular view elements
                allDOMElements.tableWrapper.classList.add('hidden');
                allDOMElements.filterBtn.classList.add('hidden');
                allDOMElements.resultsContainer.classList.remove('hidden');
                try {
                const { urls, locale, limit, resultsByUrl, overlaps } = payload;
                const formatNumber = (num) => {
                    if (typeof num !== 'number' || num === 'N/A') return num;
                    if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
                    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                    return num.toLocaleString();
                };

                let html = '<div id="keyword-targeting-dashboard" class="space-y-6">';
                html += '<div class="flex items-start justify-between gap-3">';
                html += '<div>';
                html += '<h3 class="text-xl font-bold text-[var(--text-heading)] mb-1">Keyword Targeting Analysis</h3>';
                html += `<p class="text-sm text-[var(--text-secondary)]">URLs: <span class="text-[var(--text-primary)]">${urls.length}</span> ‚Ä¢ Locale: ${locale}</p>`;
                html += '</div>';
                html += '<div class="shrink-0">';
                html += '<button type="button" class="compare-all-btn text-xs px-3 py-1 rounded-md border border-[var(--border-primary)] text-[var(--text-primary)] hover:bg-[var(--bg-hover)]" data-target="#keyword-metrics-grid">Compare All</button>';
                html += '</div>';
                // Export handled by global "Export to CSV" button
                html += '</div>';

                // Determine winners for mini-summary badges
                let __maxInbound = -Infinity, __maxInboundIdx = -1;
                let __maxPA = -Infinity, __maxPAIdx = -1;
                urls.forEach((u0, i0) => {
                    const sm0 = resultsByUrl[u0].siteMetrics?.data?.site_metrics || {};
                    const inbound0 = (typeof sm0.external_pages_to_page === 'number') ? sm0.external_pages_to_page : -Infinity;
                    const pa0 = (typeof sm0.page_authority === 'number') ? sm0.page_authority : -Infinity;
                    if (inbound0 > __maxInbound) { __maxInbound = inbound0; __maxInboundIdx = i0; }
                    if (pa0 > __maxPA) { __maxPA = pa0; __maxPAIdx = i0; }
                });

                // Cards per URL
                html += '<div id="keyword-metrics-grid" class="metrics-grid-container">';
                urls.forEach((u, idx) => {
                    const sm = resultsByUrl[u].siteMetrics?.data?.site_metrics || {};
                    const linkingDomains = sm.root_domains_to_page ?? 'N/A';
                    const inboundLinks = sm.external_pages_to_page ?? 'N/A';
                    const pageAuthority = sm.page_authority ?? 'N/A';
                    const idist = resultsByUrl[u].intentDistribution || {};
                    const anchorsInline = (resultsByUrl[u].topAnchors || []).slice(0, 5);
                    let cardClasses = '';
                    let gradientBar = '';
                    if (idx === 0) {
                        cardClasses = 'bg-gradient-to-br from-[var(--text-accent)]/10 to-[var(--bg-container)] border-2 border-[var(--text-accent)] rounded-lg p-4 shadow-lg relative';
                        gradientBar = '<div class="absolute top-0 left-0 right-0 h-1 bg-gradient-to-r from-[var(--text-accent)] to-transparent rounded-t-lg"></div>';
                    } else {
                        const competitorBorders = [
                            'border-2 border-fuchsia-400',
                            'border-2 border-emerald-400',
                            'border-2 border-violet-400'
                        ];
                        const gradientColors = ['from-fuchsia-400 via-fuchsia-500 to-transparent', 'from-emerald-400 via-emerald-500 to-transparent', 'from-violet-400 via-violet-500 to-transparent'];
                        const gi = (idx - 1) % competitorBorders.length;
                        cardClasses = 'bg-[var(--bg-container)] ' + competitorBorders[gi] + ' rounded-lg p-4 shadow-md relative';
                        gradientBar = `<div class=\"absolute top-0 left-0 right-0 h-1 bg-gradient-to-r ${gradientColors[gi]} rounded-t-lg\"></div>`;
                    }
                html += `<div class="${cardClasses} metric-card">`;
                    html += gradientBar;
                html += `<h4 class="font-semibold text-[var(--text-primary)] mb-1">URL ${idx + 1}</h4>`;
                html += `<p class="text-xs text-[var(--text-secondary)] break-all">${u}</p>`;
                // Mini-summary bar (only on winners)
                const __summaries = [];
                if (idx === __maxPAIdx) __summaries.push(`üèÜ Highest Page Authority: <span class=\\\"text-[var(--text-primary)]\\\">${pageAuthority}</span>`);
                if (idx === __maxInboundIdx) __summaries.push(`üìà Most Inbound Links: <span class=\\\"text-[var(--text-primary)]\\\">${typeof inboundLinks === 'number' ? formatNumber(inboundLinks) : inboundLinks}</span>`);
                if (__summaries.length) {
                    html += `<div class=\\\"mt-2 mb-3 text-[11px] text-[var(--text-secondary)]\\\">${__summaries.join(' ‚Ä¢ ')}</div>`;
                }
                    // Page Metrics section (vertical, like Competitive Analysis)
                    html += '<div class="mb-3 pb-3 border-b border-[var(--border-primary)]">';
                    html += '<div class="text-xs font-semibold text-[var(--text-secondary)] mb-2 uppercase tracking-wide">Page Metrics</div>';
                    html += '<div class="space-y-1 text-sm">';
                    html += `<div>Linking Domains: <span class=\"font-bold text-[var(--text-primary)]\">${typeof linkingDomains === 'number' ? formatNumber(linkingDomains) : linkingDomains}</span></div>`;
                    html += `<div>Inbound Links: <span class=\"font-bold text-[var(--text-primary)]\">${typeof inboundLinks === 'number' ? formatNumber(inboundLinks) : inboundLinks}</span></div>`;
                    html += `<div>Page Authority: <span class=\"font-bold text-[var(--text-primary)]\">${pageAuthority}</span></div>`;
                    html += '</div>';

                    // Ranking Keywords Metrics
                    const __rkList = Array.isArray(resultsByUrl[u].rankingKeywords) ? resultsByUrl[u].rankingKeywords : [];
                    const __num = __rkList.filter(k => typeof k.volume === 'number' && typeof k.rank_position === 'number');
                    const __aggVolume = __num.reduce((s, k) => s + (k.volume || 0), 0);
                    const __avgRank = __num.length ? (__num.reduce((s, k) => s + (k.rank_position || 0), 0) / __num.length) : 0;
                    const __top3 = [...__rkList].sort((a, b) => (b.volume || 0) - (a.volume || 0)).slice(0, 3);
                    html += '<div class="mt-3">';
                    html += `<div class="text-xs font-semibold text-[var(--text-secondary)] mb-2 uppercase tracking-wide">Ranking Keywords Metrics (top ${limit})</div>`;
                    html += '<div class="space-y-1 text-sm">';
                    html += `<div>Keyword Volume (aggregate): <span class=\"font-bold text-[var(--text-primary)]\">${formatNumber(__aggVolume)}</span></div>`;
                    html += `<div>Average Position: <span class=\"font-bold text-[var(--text-primary)]\">${__avgRank ? __avgRank.toFixed(1) : 'N/A'}</span></div>`;
                    if (__top3.length) {
                        html += '<div class="text-[var(--text-secondary)] text-xs mt-1">Top Keywords:</div>';
                        __top3.forEach(k => {
                            const v = typeof k.volume === 'number' ? formatNumber(k.volume) : (k.volume ?? 'N/A');
                            html += `<div class=\"text-sm\"><span class=\"text-[var(--text-primary)]\">${k.keyword || 'N/A'}</span> <span class=\"text-[var(--text-secondary)]\">‚Ä¢ Vol:</span> <span class=\"text-[var(--text-primary)]\">${v}</span></div>`;
                        });
                    }
                    html += '</div>';
                    html += '</div>';

                    html += '</div>';

                    // Ranking Keywords Intent section with donut chart
                    const intents = [
                        { label: 'Informational', color: '#60a5fa', value: Number(idist.Informational || 0) },
                        { label: 'Transactional', color: '#34d399', value: Number(idist.Transactional || 0) },
                        { label: 'Commercial', color: '#fbbf24', value: Number(idist.Commercial || 0) },
                        { label: 'Navigational', color: '#a78bfa', value: Number(idist.Navigational || 0) },
                        { label: 'Unknown', color: '#94a3b8', value: Number(idist.Unknown || 0) },
                    ];
                    const totalIntent = intents.reduce((s, x) => s + x.value, 0) || 1;
                    let offset = 0;
                    const r = 16, c = 2 * Math.PI * r;
                    const slices = intents.map((seg) => {
                        const frac = seg.value / totalIntent;
                        const dash = (c * frac).toFixed(2);
                        const gap = (c - Number(dash)).toFixed(2);
                        const rot = ((offset / totalIntent) * 360).toFixed(2);
                        offset += seg.value;
                        return `<circle r=\"${r}\" cx=\"20\" cy=\"20\" fill=\"transparent\" stroke=\"${seg.color}\" stroke-width=\"8\" stroke-dasharray=\"${dash} ${gap}\" transform=\"rotate(-90 20 20) rotate(${rot} 20 20)\"></circle>`;
                    }).join('');
                    html += '<div class="mb-3 pb-3 border-b border-[var(--border-primary)]">';
                    html += '<div class="text-xs font-semibold text-[var(--text-secondary)] mb-2 uppercase tracking-wide">Ranking Keywords Intent</div>';
                    html += '<div class="flex items-center gap-3">';
                    html += `<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\">${slices}</svg>`;
                    html += '<div class="grid grid-cols-2 gap-x-4 gap-y-1 text-[11px]">';
                    intents.forEach(seg => {
                        html += `<div class=\"flex items-center gap-1\"><span style=\"background:${seg.color};width:8px;height:8px;border-radius:9999px;display:inline-block\"></span><span class=\"text-[var(--text-secondary)]\">${seg.label}:</span><span class=\"text-[var(--text-primary)]\">${seg.value}%</span></div>`;
                    });
                    html += '</div>';
                    html += '</div>';
                    html += '</div>';

                    // Inbound Anchor Texts section with preview + modal trigger
                    const __allAnchors = (resultsByUrl[u].topAnchors || []);
                    const anchorsCount = __allAnchors.length;
                    const __preview = __allAnchors.slice(0, 3);
                    html += '<div class="">';
                    html += '<div class="flex items-center justify-between mb-2">';
                    html += '<div class="text-xs font-semibold text-[var(--text-secondary)] uppercase tracking-wide">Inbound Anchor Texts</div>';
                    html += `<button type=\"button\" class=\"kta-anchors-toggle text-[11px] text-[var(--text-accent)] hover:text-[var(--text-accent-hover)]\" data-url-idx=\"${idx}\">View More (${anchorsCount})</button>`;
                    html += '</div>';
                    if (__preview.length === 0) {
                        html += '<div class="text-[var(--text-secondary)] text-xs">No anchor texts found.</div>';
                    } else {
                        html += '<div class="space-y-2">';
                        __preview.forEach((a) => {
                            const domainsP = (typeof a.external_root_domains === 'number') ? formatNumber(a.external_root_domains) : (a.external_root_domains ?? 'N/A');
                            const pagesP = (typeof a.external_pages === 'number') ? formatNumber(a.external_pages) : (a.external_pages ?? 'N/A');
                            html += '<div class="text-sm">';
                            html += `<div class=\"font-semibold text-[var(--text-primary)] truncate\">${a.text || 'N/A'}</div>`;
                            html += `<div class=\"text-[var(--text-secondary)] text-xs\">Linking Domains: <span class=\"text-[var(--text-primary)]\">${domainsP}</span> ‚Ä¢ Inbound Links: <span class=\"text-[var(--text-primary)]\">${pagesP}</span></div>`;
                            html += '</div>';
                        });
                        html += '</div>';
                    }
                    html += '</div>';
                    html += '</div>';
                });
                html += '</div>';

                // Overlapping keywords across URLs (moved above Ranking Keywords)
                html += '<div id="url-overlap-section" class="mt-6">';
                html += '<div class="flex items-center justify-between mb-4">';
                html += '<h4 class="font-bold text-lg text-[var(--text-primary)]">Keyword Overlap Across URLs</h4>';
                html += '</div>';
                if ((overlaps || []).length > 0) {
                    // Legend for URL mappings
                    html += '<div class="mb-3 p-3 bg-[var(--bg-input)] rounded-md border border-[var(--border-primary)]">';
                    html += '<div class="text-xs font-semibold text-[var(--text-secondary)] uppercase tracking-wide mb-2">URL Legend</div>';
                    html += '<div class="flex flex-wrap gap-x-4 gap-y-1">';
                    urls.forEach((u, idx) => {
                        html += `<div class="text-sm text-[var(--text-primary)]">URL ${idx + 1}: <span class="text-[var(--text-secondary)] font-mono text-xs">${u}</span></div>`;
                    });
                    html += '</div></div>';
                    
                    // Collapse/Expand button
                    html += '<div class="mb-2">';
                    html += '<button id="kta-overlap-toggle" class="px-3 py-1 text-sm rounded-md border border-[var(--border-primary)] bg-[var(--bg-input)] text-[var(--text-primary)] hover:bg-[var(--bg-container)]">Collapse Table</button>';
                    html += '</div>';
                    
                    html += '<div id="kta-overlap-table-wrapper">';
                    html += '<div id="kta-overlap-table"></div>';
                    html += '</div>';
                } else {
                    html += '<p class="text-[var(--text-secondary)]">No overlapping keywords found across the selected URLs.</p>';
                }
                html += '</div>';

                // Unified Ranking Keywords section with selector
                html += '<div id="kta-keywords-section" class="mt-6">';
                html += '<div class="flex items-center justify-between mb-4">';
                html += '<h4 class="font-bold text-lg text-[var(--text-primary)]">Ranking Keywords</h4>';
                html += '<div><label for="kta-url-selector" class="inline-block text-sm font-medium text-[var(--text-secondary)] mr-2">View Details For:</label>';
                html += '<select id="kta-url-selector" class="inline-block bg-[var(--bg-input)] border border-[var(--border-secondary)] rounded-md px-3 py-2 text-sm text-[var(--text-primary)]">';
                urls.forEach((u, idx) => { html += `<option value=\"${idx}\">URL ${idx + 1}: ${u}</option>`; });
                html += '</select></div></div>';
                urls.forEach((u, idx) => {
                    const res = resultsByUrl[u] || {};
                    const rkArray = Array.isArray(res.rankingKeywords)
                        ? res.rankingKeywords
                        : (res.rankingKeywords && res.rankingKeywords.data && Array.isArray(res.rankingKeywords.data.ranking_keywords)
                            ? res.rankingKeywords.data.ranking_keywords
                            : []);
                    html += `<div id=\"kta-keywords-panel-${idx}\" class=\"${idx === 0 ? '' : 'hidden'}\">`;
                    html += `<div id="kta-keywords-table-${idx}"></div>`;
                    html += '</div>';
                });
                html += '</div>';

                // (Overlap section moved above Ranking Keywords)

                // (Keyword Gap removed per request)

                html += '</div>';

                allDOMElements.rawCode.textContent = JSON.stringify(payload, null, 2);
                allDOMElements.rawWrapper.innerHTML = html;
                // Ensure a global, body-level modal exists for anchors
                let bodyModal = document.getElementById('kta-anchor-modal');
                if (!bodyModal) {
                    bodyModal = document.createElement('div');
                    bodyModal.id = 'kta-anchor-modal';
                    bodyModal.className = 'hidden';
                    bodyModal.innerHTML = `
                        <div class="fixed inset-0 z-[9998] bg-black/50" data-overlay></div>
                        <div class="fixed z-[9999] left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 bg-[var(--bg-container)] text-[var(--text-primary)] w-[min(92vw,800px)] max-h-[80vh] rounded-lg shadow-xl border border-[var(--border-primary)] p-4 overflow-auto" role="dialog" aria-modal="true">
                            <div class="flex items-center justify-between mb-3">
                                <h5 class="font-semibold">Inbound Anchor Texts</h5>
                                <button type="button" class="kta-modal-close text-sm px-2 py-1 border border-[var(--border-primary)] rounded-md">Close</button>
                            </div>
                            <div class="kta-modal-body space-y-2 text-sm"></div>
                        </div>`;
                    document.body.appendChild(bodyModal);
                }
                // Attach compare-all toggle handler
                const compareBtnKta = allDOMElements.rawWrapper.querySelector('.compare-all-btn[data-target="#keyword-metrics-grid"]');
                if (compareBtnKta) {
                    compareBtnKta.addEventListener('click', () => {
                        const target = allDOMElements.rawWrapper.querySelector('#keyword-metrics-grid');
                        if (!target) return;
                        const isWide = target.classList.toggle('wide');
                        compareBtnKta.textContent = isWide ? 'Collapse' : 'Compare All';
                    });
                }
                // Modal handlers for anchors
                const modal = document.getElementById('kta-anchor-modal');
                const modalBody = modal && modal.querySelector('.kta-modal-body');
                const closeBtn = modal && modal.querySelector('.kta-modal-close');
                const overlay = modal && modal.querySelector('[data-overlay]');
                const hideModal = () => {
                    modal.classList.add('hidden');
                    document.body.style.overflow = '';
                };
                const showModal = () => {
                    modal.classList.remove('hidden');
                    document.body.style.overflow = 'hidden';
                };
                if (closeBtn) closeBtn.addEventListener('click', hideModal);
                if (overlay) overlay.addEventListener('click', hideModal);
                allDOMElements.rawWrapper.querySelectorAll('.kta-anchors-toggle').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const i = Number(btn.getAttribute('data-url-idx'));
                        const url = urls[i];
                        const fullAnchors = (resultsByUrl[url].topAnchors || []);
                        if (!modal || !modalBody) return;
                        modalBody.innerHTML = fullAnchors.length === 0 ? '<div class="text-[var(--text-secondary)]">No anchor texts found.</div>' : fullAnchors.map(a => {
                            const domains = (typeof a.external_root_domains === 'number') ? formatNumber(a.external_root_domains) : (a.external_root_domains ?? 'N/A');
                            const pages = (typeof a.external_pages === 'number') ? formatNumber(a.external_pages) : (a.external_pages ?? 'N/A');
                            return `<div class=\"border-b border-[var(--border-primary)] pb-2\">`
                                + `<div class=\"font-semibold text-[var(--text-primary)]\">${a.text || 'N/A'}</div>`
                                + `<div class=\"text-[var(--text-secondary)] text-xs\">Linking Domains: <span class=\"text-[var(--text-primary)]\">${domains}</span></div>`
                                + `<div class=\"text-[var(--text-secondary)] text-xs\">Inbound Links: <span class=\"text-[var(--text-primary)]\">${pages}</span></div>`
                                + `</div>`;
                        }).join('');
                        showModal();
                    });
                });
                allDOMElements.rawWrapper.classList.remove('hidden');
                allDOMElements.viewDataBtn.textContent = 'View JSON';
                allDOMElements.exportPdfBtn.classList.add('hidden');

                // Initialize Tabulator for ranking keywords tables
                urls.forEach((u, idx) => {
                    const res = resultsByUrl[u] || {};
                    const rkArray = Array.isArray(res.rankingKeywords)
                        ? res.rankingKeywords
                        : (res.rankingKeywords && res.rankingKeywords.data && Array.isArray(res.rankingKeywords.data.ranking_keywords)
                            ? res.rankingKeywords.data.ranking_keywords
                            : []);
                    
                    if (rkArray.length > 0) {
                        setTimeout(() => {
                            if (typeof Tabulator !== 'undefined' && document.getElementById(`kta-keywords-table-${idx}`)) {
                                const tableData = rkArray.map(kw => {
                                    const intent = (res.searchIntent && (res.searchIntent[kw.keyword] || res.searchIntent[(kw.keyword || '').toLowerCase()])) || 'Unknown';
                                    return {
                                        keyword: kw.keyword || 'N/A',
                                        intent: intent,
                                        rank: kw.rank_position ?? 'N/A',
                                        page: kw.ranking_page || 'N/A',
                                        difficulty: kw.difficulty ?? 'N/A',
                                        volume: kw.volume ?? 'N/A'
                                    };
                                });
                                
                                new Tabulator(`#kta-keywords-table-${idx}`, {
                                    data: tableData,
                                    columns: [
                                        { title: 'Keyword', field: 'keyword', sorter: 'string' },
                                        { title: 'Intent', field: 'intent', sorter: 'string' },
                                        { title: 'Rank', field: 'rank', sorter: 'number' },
                                        { title: 'Page', field: 'page', sorter: 'string' },
                                        { title: 'Difficulty', field: 'difficulty', sorter: 'number' },
                                        { title: 'Volume', field: 'volume', sorter: 'number' }
                                    ],
                                    layout: "fitDataStretch",
                                    pagination: "local",
                                    paginationSize: 25,
                                    movableColumns: true,
                                    resizableColumns: true
                                });
                            }
                        }, 100);
                    }
                });

                // Wire URL selector for unified Ranking Keywords panels
                const ktaSelector = document.getElementById('kta-url-selector');
                if (ktaSelector) {
                    ktaSelector.addEventListener('change', (e) => {
                        const selected = parseInt(e.target.value);
                        urls.forEach((_, idx) => {
                            const panel = document.getElementById(`kta-keywords-panel-${idx}`);
                            if (panel) panel.classList.toggle('hidden', idx !== selected);
                        });
                    });
                }

                // Wire anchor text expand/collapse toggles (per card)
                document.querySelectorAll('.kta-anchors-toggle').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const urlIdx = btn.getAttribute('data-url-idx');
                        const spans = document.querySelectorAll(`.kta-anchor-text-${urlIdx}`);
                        if (spans.length > 0) {
                            const anyTruncated = Array.from(spans).some(s => s.classList.contains('truncate'));
                            if (anyTruncated) {
                                spans.forEach(s => s.classList.remove('truncate'));
                                btn.textContent = 'Collapse Anchors';
                            } else {
                                spans.forEach(s => s.classList.add('truncate'));
                                btn.textContent = 'Expand Anchors';
                            }
                        }
                    });
                });

                // Initialize Tabulator for overlap table
                if ((overlaps || []).length > 0) {
                    setTimeout(() => {
                        if (typeof Tabulator !== 'undefined' && document.getElementById('kta-overlap-table')) {
                            const tableData = overlaps.map(row => {
                                const obj = {
                                    keyword: row.keyword,
                                    sharedBy: `${row.urls.length} URLs`
                                };
                                urls.forEach((u, idx) => {
                                    const data = row.data[u];
                                    obj[`url${idx + 1}`] = data ? (data.rank ?? 'N/A') : 'Not ranking';
                                });
                                return obj;
                            });
                            
                            const columns = [
                                { title: 'Keyword', field: 'keyword', sorter: 'string' },
                                { title: 'Shared By', field: 'sharedBy', sorter: 'string' }
                            ];
                            urls.forEach((u, idx) => {
                                columns.push({ title: `URL ${idx + 1}`, field: `url${idx + 1}`, sorter: 'number' });
                            });
                            
                            new Tabulator("#kta-overlap-table", {
                                data: tableData,
                                columns: columns,
                                layout: "fitDataStretch",
                                pagination: "local",
                                paginationSize: 25,
                                movableColumns: true,
                                resizableColumns: true
                            });
                        }
                    }, 100);
                }

                // Wire overlap table collapse/expand toggle
                const overlapToggle = document.getElementById('kta-overlap-toggle');
                if (overlapToggle) {
                    overlapToggle.addEventListener('click', () => {
                        const wrapper = document.getElementById('kta-overlap-table-wrapper');
                        if (wrapper) {
                            if (wrapper.classList.contains('hidden')) {
                                wrapper.classList.remove('hidden');
                                overlapToggle.textContent = 'Collapse Table';
                            } else {
                                wrapper.classList.add('hidden');
                                overlapToggle.textContent = 'Expand Table';
                            }
                        }
                    });
                }

                // (Export handled by global button)
                } catch (err) {
                    displayError('Render error in Keyword Targeting Analysis: ' + (err && err.message ? err.message : err));
                }

                // Post-render validation: ensure both panels exist
                try {
                    const missing = urls
                        .map((_, idx) => ({ idx, el: document.getElementById(`kta-panel-${idx}`) }))
                        .filter(x => !x.el)
                        .map(x => x.idx + 1);
                    if (missing.length > 0) {
                        displayError('Missing URL panels: ' + missing.join(', '));
                        // Fallback: create missing panels with a minimal list renderer
                        const dash = document.getElementById('keyword-targeting-dashboard') || allDOMElements.rawWrapper;
                        urls.forEach((u, idx) => {
                            if (!document.getElementById(`kta-panel-${idx}`)) {
                                const res = resultsByUrl[u] || {};
                                const rkArray = Array.isArray(res.rankingKeywords)
                                    ? res.rankingKeywords
                                    : (res.rankingKeywords && res.rankingKeywords.data && Array.isArray(res.rankingKeywords.data.ranking_keywords)
                                        ? res.rankingKeywords.data.ranking_keywords
                                        : []);
                                const container = document.createElement('div');
                                container.id = `kta-panel-${idx}`;
                                container.className = 'space-y-4';
                                container.innerHTML = `
                                    <div class="bg-[var(--bg-container)] border border-[var(--border-primary)] rounded-lg p-4">
                                        <div class="text-sm font-semibold text-[var(--text-secondary)] mb-2 uppercase tracking-wide">Fallback Panel (URL ${idx + 1})</div>
                                        <div class="text-xs text-[var(--text-secondary)] mb-2">Keywords rendered in this panel: <span class="text-[var(--text-primary)]">${rkArray.length}</span></div>
                                        <ul class="list-disc pl-5 text-sm text-[var(--text-primary)]">${rkArray.slice(0, 25).map(k => `<li>${(k && k.keyword) || 'N/A'}</li>`).join('')}</ul>
                                    </div>
                                `;
                                dash.appendChild(container);
                            }
                        });
                    }
                } catch (_) {}
            }

            function showContentClusterDashboard(payload) {
                allDOMElements.tableWrapper.classList.add('hidden');
                allDOMElements.filterBtn.classList.add('hidden');
                allDOMElements.resultsContainer.classList.remove('hidden');
                try {
                const { seedTopic, urls, locale, limit, similarityThreshold, resultsByUrl, seedTopicSimilarities, intentGroups, consolidationClusters, mainTopicPage, relatedKeywords, contentRecommendations, newContentToCreate } = payload;
                const formatNumber = (num) => {
                    if (typeof num !== 'number' || num === 'N/A') return num;
                    if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
                    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                    return num.toLocaleString();
                };

                let html = '<div id="content-cluster-dashboard" class="space-y-6">';
                html += '<div class="flex items-start justify-between gap-3">';
                html += '<div>';
                html += '<h3 class="text-xl font-bold text-[var(--text-heading)] mb-1">Content Cluster Analysis</h3>';
                html += `<p class="text-sm text-[var(--text-secondary)]">Seed Topic: <span class="text-[var(--text-primary)] font-semibold">${seedTopic}</span> ‚Ä¢ URLs: <span class="text-[var(--text-primary)]">${urls.length}</span> ‚Ä¢ Locale: ${locale} ‚Ä¢ Threshold: ${similarityThreshold}</p>`;
                html += '</div>';
                html += '</div>';

                // Main Topic Page
                if (mainTopicPage) {
                    html += '<div id="main-topic-section" class="mt-6 bg-gradient-to-r from-[var(--text-accent)]/20 to-[var(--bg-container)] border-2 border-[var(--text-accent)] rounded-lg p-4">';
                    html += '<h4 class="font-bold text-lg text-[var(--text-primary)] mb-2">üèÜ Main Topic Page</h4>';
                    html += `<div class="text-sm text-[var(--text-primary)] break-all mb-2">${mainTopicPage}</div>`;
                    const mainMetrics = resultsByUrl[mainTopicPage]?.mozMetrics || {};
                    const mainSimilarity = typeof seedTopicSimilarities[mainTopicPage] === 'number' && !isNaN(seedTopicSimilarities[mainTopicPage]) ? seedTopicSimilarities[mainTopicPage] : 0;
                    const mainValueScore = typeof resultsByUrl[mainTopicPage]?.valueScore === 'number' && !isNaN(resultsByUrl[mainTopicPage]?.valueScore) ? resultsByUrl[mainTopicPage].valueScore : 0;
                    html += '<div class="grid grid-cols-2 md:grid-cols-5 gap-2 text-xs">';
                    html += `<div>Similarity: <span class="font-bold">${(mainSimilarity * 100).toFixed(1)}%</span></div>`;
                    html += `<div>Value Score: <span class="font-bold">${mainValueScore}</span></div>`;
                    html += `<div>Ranking Keywords: <span class="font-bold">${mainMetrics.rankingKeywordsCount || 0}</span></div>`;
                    html += `<div>Linking Domains: <span class="font-bold">${mainMetrics.linkingDomains || 0}</span></div>`;
                    html += `<div>Page Authority: <span class="font-bold">${mainMetrics.pageAuthority || 0}</span></div>`;
                    html += '</div>';
                    html += '</div>';
                }

                // Seed Topic Similarity Table
                html += '<div id="similarity-table-section" class="mt-6">';
                html += '<h4 class="font-bold text-lg text-[var(--text-primary)] mb-2">Semantic Similarity to Seed Topic</h4>';
                html += '<p class="text-sm text-[var(--text-secondary)] mb-4">This section lets you know how related each page is to your seed topic. The higher the value, the more related this URL is to your seed topic.</p>';
                if (Object.keys(seedTopicSimilarities).length > 0) {
                    html += '<div id="cca-similarity-table"></div>';
                } else {
                    html += '<p class="text-[var(--text-secondary)]">No similarity data available.</p>';
                }
                html += '</div>';

                // Intent Groups - Card Layout
                html += '<div id="intent-groups-section" class="mt-6">';
                html += '<div class="flex items-center justify-between mb-4">';
                html += '<h4 class="font-bold text-lg text-[var(--text-primary)]">Content Segments by Search Intent</h4>';
                html += '<button type="button" class="cca-section-toggle px-3 py-1 text-sm rounded-md border border-[var(--border-primary)] bg-[var(--bg-input)] text-[var(--text-primary)] hover:bg-[var(--bg-container)]" data-section="intent-groups-content">Collapse</button>';
                html += '</div>';
                html += '<div id="intent-groups-content">';
                const intentColors = {
                    Informational: '#60a5fa',
                    Commercial: '#fbbf24',
                    Navigational: '#a78bfa',
                    Transactional: '#34d399',
                    Other: '#94a3b8'
                };
                html += '<div class="metrics-grid-container">';
                Object.entries(intentGroups).forEach(([intent, groupUrls]) => {
                    if (groupUrls.length === 0) return;
                    const intentColor = intentColors[intent] || intentColors.Other;
                    html += `<div class="bg-[var(--bg-container)] border-2 rounded-lg p-4" style="border-color: ${intentColor}">`;
                    html += `<div class="flex items-center gap-2 mb-3 pb-3 border-b border-[var(--border-primary)]">`;
                    html += `<span style="background:${intentColor};width:16px;height:16px;border-radius:9999px;display:inline-block"></span>`;
                    html += `<h5 class="font-semibold text-[var(--text-primary)]">${intent} (${groupUrls.length} URLs)</h5>`;
                    html += '</div>';
                    html += '<div class="space-y-1 max-h-64 overflow-y-auto">';
                    groupUrls.forEach(u => {
                        const similarity = typeof seedTopicSimilarities[u] === 'number' && !isNaN(seedTopicSimilarities[u]) ? seedTopicSimilarities[u] : 0;
                        const valueScore = typeof resultsByUrl[u]?.valueScore === 'number' && !isNaN(resultsByUrl[u]?.valueScore) ? resultsByUrl[u].valueScore : 0;
                        html += `<div class="text-xs p-1.5 bg-[var(--bg-input)] rounded">`;
                        html += `<div class="text-[var(--text-primary)] break-all text-xs">${u}</div>`;
                        html += `<div class="text-[10px] text-[var(--text-secondary)] mt-0.5">Similarity: ${(similarity * 100).toFixed(1)}% ‚Ä¢ Value: ${valueScore.toFixed(1)}</div>`;
                        html += '</div>';
                    });
                    html += '</div>';
                    html += '</div>';
                });
                html += '</div>';
                html += '</div>';

                // Consolidation Clusters
                html += '<div id="consolidation-clusters-section" class="mt-6">';
                html += '<div class="flex items-center justify-between mb-4">';
                html += '<h4 class="font-bold text-lg text-[var(--text-primary)]">Content Consolidation Clusters</h4>';
                html += '<button type="button" class="cca-section-toggle px-3 py-1 text-sm rounded-md border border-[var(--border-primary)] bg-[var(--bg-input)] text-[var(--text-primary)] hover:bg-[var(--bg-container)]" data-section="consolidation-clusters-content">Collapse</button>';
                html += '</div>';
                html += '<div id="consolidation-clusters-content">';
                if (consolidationClusters.length > 0) {
                    html += '<div class="space-y-4">';
                    const consolidationColors = [
                        'border-2 border-[var(--text-accent)]', // blue
                        'border-2 border-fuchsia-400', // pink
                        'border-2 border-emerald-400', // green
                        'border-2 border-violet-400'  // purple
                    ];
                    consolidationClusters.forEach((cluster, idx) => {
                        const aiAnalysis = cluster.aiAnalysis || {};
                        const urlToKeep = aiAnalysis.urlToKeep || cluster.urls[0];
                        const borderClass = consolidationColors[idx % consolidationColors.length];
                        html += `<div class="bg-[var(--bg-container)] ${borderClass} rounded-lg p-4">`;
                        html += `<div class="flex items-start justify-between mb-3">`;
                        html += `<div>`;
                        html += `<div class="text-sm font-semibold text-[var(--text-primary)] mb-1">Cluster ${idx + 1} - ${cluster.intent} Intent</div>`;
                        const clusterUrlSimilarity = typeof cluster.urlToUrlSimilarity === 'number' && !isNaN(cluster.urlToUrlSimilarity) ? cluster.urlToUrlSimilarity : 0;
                        const clusterAvgValue = typeof cluster.avgValue === 'number' && !isNaN(cluster.avgValue) ? cluster.avgValue : 0;
                        const clusterTotalValue = typeof cluster.totalValue === 'number' && !isNaN(cluster.totalValue) ? cluster.totalValue : 0;
                        html += `<div class="text-xs text-[var(--text-secondary)]">URL-to-URL Similarity: ${(clusterUrlSimilarity * 100).toFixed(1)}% ‚Ä¢ Avg Value: ${clusterAvgValue.toFixed(1)} ‚Ä¢ Total Value: ${clusterTotalValue.toFixed(1)}</div>`;
                        if (cluster.overlappingKeywords && cluster.overlappingKeywords.length > 0) {
                            html += `<div class="text-xs text-[var(--text-secondary)] mt-1">Overlapping Keywords: <span class="text-[var(--text-primary)] font-semibold">${cluster.overlappingKeywords.slice(0, 5).join(', ')}${cluster.overlappingKeywords.length > 5 ? ` (+${cluster.overlappingKeywords.length - 5} more)` : ''}</span></div>`;
                        }
                        html += `</div>`;
                        html += `<div class="text-lg font-bold text-[var(--text-accent)]">${cluster.urls.length} URLs</div>`;
                        html += `</div>`;
                        
                        // AI Analysis
                        if (aiAnalysis.consolidationReason) {
                            html += '<div class="mb-3 p-3 bg-[var(--bg-input)] rounded border-l-4 border-[var(--text-accent)]">';
                            html += '<div class="text-xs font-semibold text-[var(--text-secondary)] uppercase mb-1">AI Analysis</div>';
                            html += `<div class="text-sm text-[var(--text-primary)] mb-2">${aiAnalysis.consolidationReason}</div>`;
                            html += `<div class="text-xs text-[var(--text-accent)] font-semibold mb-1">‚úì Keep URL: ${urlToKeep}</div>`;
                            if (aiAnalysis.subtopicToOptimize) {
                                html += `<div class="text-xs text-[var(--text-primary)]">üéØ Optimize for: <span class="font-semibold">${aiAnalysis.subtopicToOptimize}</span></div>`;
                            }
                            html += '</div>';
                        }
                        
                        html += '<div class="space-y-2">';
                        cluster.urls.forEach(u => {
                            const metrics = resultsByUrl[u]?.mozMetrics || {};
                            const isKeepUrl = u === urlToKeep;
                            const bgClass = isKeepUrl ? 'bg-[var(--text-accent)]/10 border-2 border-[var(--text-accent)]' : 'bg-[var(--bg-input)]';
                            html += `<div class="text-sm p-2 ${bgClass} rounded">`;
                            html += `<div class="text-[var(--text-primary)] break-all mb-1">${u}${isKeepUrl ? ' <span class="text-[var(--text-accent)] font-semibold">(Keep This URL)</span>' : ' <span class="text-[var(--text-secondary)] text-xs">(Consolidate into above)</span>'}</div>`;
                            html += `<div class="text-xs text-[var(--text-secondary)] grid grid-cols-4 gap-2">`;
                            html += `<span>Keywords: ${metrics.rankingKeywordsCount || 0}</span>`;
                            html += `<span>Links: ${metrics.inboundLinks || 0}</span>`;
                            html += `<span>Domains: ${metrics.linkingDomains || 0}</span>`;
                            html += `<span>PA: ${metrics.pageAuthority || 0}</span>`;
                            html += '</div>';
                            html += '</div>';
                        });
                        html += '</div>';
                        html += '</div>';
                    });
                    html += '</div>';
                } else {
                    html += `<p class="text-[var(--text-secondary)]">No consolidation clusters identified. URLs are sufficiently distinct.</p>`;
                }
                html += '</div>';
                html += '</div>';

                // Internal Linking Strategy removed per user request

                // Content Recommendations
                if (contentRecommendations && !contentRecommendations.error) {
                    html += '<div id="content-recommendations-section" class="mt-6">';
                    html += '<div class="flex items-center justify-between mb-4">';
                    html += '<h4 class="font-bold text-lg text-[var(--text-primary)]">Recommendations to Update Existing Content</h4>';
                    html += '<button type="button" class="cca-section-toggle px-3 py-1 text-sm rounded-md border border-[var(--border-primary)] bg-[var(--bg-input)] text-[var(--text-primary)] hover:bg-[var(--bg-container)]" data-section="content-recommendations-content">Collapse</button>';
                    html += '</div>';
                    html += '<div id="content-recommendations-content">';
                    html += '<div class="bg-[var(--bg-container)] border-2 border-[var(--text-accent)] rounded-lg p-4">';
                    
                    // Collect URLs that are recommended to be deleted (from consolidation clusters)
                    const urlsToDelete = new Set();
                    if (consolidationClusters && Array.isArray(consolidationClusters)) {
                        consolidationClusters.forEach(cluster => {
                            const aiAnalysis = cluster.aiAnalysis || {};
                            const urlToKeep = aiAnalysis.urlToKeep || cluster.urls[0];
                            cluster.urls.forEach(url => {
                                if (url !== urlToKeep) {
                                    urlsToDelete.add(url);
                                }
                            });
                        });
                    }
                    
                    // General Recommendations at the top
                    if (contentRecommendations.generalRecommendations && Array.isArray(contentRecommendations.generalRecommendations)) {
                        html += '<div class="mb-4 pb-4 border-b border-[var(--border-primary)]">';
                        html += '<div class="text-sm font-semibold text-[var(--text-primary)] mb-2">General Recommendations</div>';
                        html += '<ul class="list-disc list-inside space-y-1 text-sm text-[var(--text-secondary)]">';
                        contentRecommendations.generalRecommendations.forEach(r => {
                            // Replace any year references with current year (2025)
                            const currentYear = new Date().getFullYear();
                            const yearRegex = /\b(20\d{2})\b/g;
                            const updatedRec = r.replace(yearRegex, currentYear.toString());
                            html += `<li>${updatedRec}</li>`;
                        });
                        html += '</ul>';
                        html += '</div>';
                    }
                    
                    // Recommendations by URL (excluding deleted URLs)
                    if (contentRecommendations.recommendations && Array.isArray(contentRecommendations.recommendations)) {
                        const validRecommendations = contentRecommendations.recommendations.filter(rec => !urlsToDelete.has(rec.url));
                        if (validRecommendations.length > 0) {
                            html += '<div class="mt-4">';
                            html += '<div class="text-sm font-semibold text-[var(--text-primary)] mb-3">Recommendations by URL</div>';
                            validRecommendations.forEach(rec => {
                                html += `<div class="mb-4 pb-4 border-b border-[var(--border-primary)] last:border-0">`;
                                html += `<div class="text-sm font-semibold text-[var(--text-primary)] mb-2 break-all">${rec.url}</div>`;
                                if (Array.isArray(rec.recommendations)) {
                                    html += '<ul class="list-disc list-inside space-y-1 text-sm text-[var(--text-secondary)]">';
                                    rec.recommendations.forEach(r => {
                                        // Replace any year references with current year (2025)
                                        const currentYear = new Date().getFullYear();
                                        const yearRegex = /\b(20\d{2})\b/g;
                                        const updatedRec = r.replace(yearRegex, currentYear.toString());
                                        html += `<li>${updatedRec}</li>`;
                                    });
                                    html += '</ul>';
                                }
                                html += '</div>';
                            });
                            html += '</div>';
                        }
                    }
                    html += '</div>';
                    html += '</div>';
                    html += '</div>';
                }

                // New Content to Create
                if (newContentToCreate && !newContentToCreate.error && newContentToCreate.newContentIdeas) {
                    html += '<div id="new-content-section" class="mt-6">';
                    html += '<div class="flex items-center justify-between mb-4">';
                    html += '<h4 class="font-bold text-lg text-[var(--text-primary)]">New Content to Create</h4>';
                    html += '<button type="button" class="cca-section-toggle px-3 py-1 text-sm rounded-md border border-[var(--border-primary)] bg-[var(--bg-input)] text-[var(--text-primary)] hover:bg-[var(--bg-container)]" data-section="new-content-content">Collapse</button>';
                    html += '</div>';
                    html += '<div id="new-content-content">';
                    html += '<div class="space-y-3">';
                    const intentColors = {
                        Informational: '#60a5fa',
                        Commercial: '#fbbf24',
                        Navigational: '#a78bfa',
                        Transactional: '#34d399',
                        Other: '#94a3b8'
                    };
                    newContentToCreate.newContentIdeas.forEach((idea, idx) => {
                        const ideaIntent = idea.intent || 'Informational';
                        const intentColor = intentColors[ideaIntent] || intentColors.Other;
                        html += `<div class="bg-[var(--bg-container)] border-2 rounded-lg p-4" style="border-color: ${intentColor}">`;
                        html += `<div class="flex items-start justify-between mb-2">`;
                        html += `<div class="flex-1">`;
                        // Replace years in title
                        const currentYear = new Date().getFullYear();
                        const yearRegex = /\b(20\d{2})\b/g;
                        const titleWithYear = idea.title || `Content Idea ${idx + 1}`;
                        const updatedTitle = titleWithYear.replace(yearRegex, currentYear.toString());
                        html += `<div class="text-sm font-semibold text-[var(--text-primary)] mb-2">${updatedTitle}</div>`;
                        html += `<div class="text-xs mb-2">`;
                        html += `<span class="font-bold text-[var(--text-secondary)]">Intent:</span> `;
                        html += `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-semibold" style="background-color: ${intentColor}20; color: ${intentColor};">`;
                        html += `<span style="background:${intentColor};width:8px;height:8px;border-radius:9999px;display:inline-block"></span>${ideaIntent}</span>`;
                        html += `</div>`;
                        if (idea.targetKeywords && Array.isArray(idea.targetKeywords) && idea.targetKeywords.length > 0) {
                            html += `<div class="text-xs mb-2">`;
                            html += `<span class="font-bold text-[var(--text-secondary)]">Target Keywords:</span> `;
                            html += `<div class="mt-1 space-y-1">`;
                            idea.targetKeywords.forEach(kw => {
                                const metrics = idea.keywordMetrics?.[kw] || {};
                                html += `<div class="text-xs">`;
                                html += `<span class="text-[var(--text-primary)] font-semibold">${kw}</span>`;
                                if (metrics.volume !== null || metrics.difficulty !== null || (metrics.opportunity_ctr !== null && metrics.opportunity_ctr !== undefined)) {
                                    html += `<span class="text-[var(--text-secondary)] ml-2">‚Ä¢ `;
                                    const metricsParts = [];
                                    if (metrics.volume !== null) metricsParts.push(`Volume: ${typeof metrics.volume === 'number' ? metrics.volume.toLocaleString() : metrics.volume}`);
                                    if (metrics.difficulty !== null) metricsParts.push(`Difficulty: ${metrics.difficulty}`);
                                    if (metrics.opportunity_ctr !== null && metrics.opportunity_ctr !== undefined && typeof metrics.opportunity_ctr === 'number' && !isNaN(metrics.opportunity_ctr)) {
                                        metricsParts.push(`Organic CTR: ${metrics.opportunity_ctr.toFixed(1)}%`);
                                    }
                                    html += metricsParts.join(' ‚Ä¢ ');
                                    html += `</span>`;
                                }
                                html += `</div>`;
                            });
                            html += `</div>`;
                            html += `</div>`;
                        }
                        if (idea.rationale) {
                            // Replace any year references with current year (2025)
                            const currentYear = new Date().getFullYear();
                            const yearRegex = /\b(20\d{2})\b/g;
                            const updatedRationale = idea.rationale.replace(yearRegex, currentYear.toString());
                            html += `<div class="text-sm text-[var(--text-secondary)] mt-2">${updatedRationale}</div>`;
                        }
                        if (idea.title) {
                            // Also replace years in title
                            const currentYear = new Date().getFullYear();
                            const yearRegex = /\b(20\d{2})\b/g;
                            const updatedTitle = idea.title.replace(yearRegex, currentYear.toString());
                            if (updatedTitle !== idea.title) {
                                // Update title if it had a year
                                html = html.replace(`>${idea.title || `Content Idea ${idx + 1}`}<`, `>${updatedTitle}<`);
                            }
                        }
                        html += `</div>`;
                        html += `</div>`;
                        html += `</div>`;
                    });
                    html += '</div>';
                    html += '</div>';
                    html += '</div>';
                }

                // Related Keywords
                if (relatedKeywords && relatedKeywords.length > 0) {
                    html += '<div id="related-keywords-section" class="mt-6">';
                    html += '<h4 class="font-bold text-lg text-[var(--text-primary)] mb-4">Related Keywords</h4>';
                    html += '<div class="flex flex-wrap gap-2">';
                    relatedKeywords.slice(0, 30).forEach(kw => {
                        html += `<span class="px-3 py-1 bg-[var(--bg-input)] border border-[var(--border-primary)] rounded-md text-sm text-[var(--text-primary)]">${kw}</span>`;
                    });
                    html += '</div>';
                    html += '</div>';
                }

                // Individual URL Summaries with Anchor Text
                html += '<div id="url-metrics-grid" class="metrics-grid-container mt-6">';
                html += '<h4 class="font-bold text-lg text-[var(--text-primary)] mb-4 w-full col-span-full">Individual URL Summaries</h4>';
                const urlSummaryColors = [
                    'border-2 border-[var(--text-accent)]', // blue
                    'border-2 border-fuchsia-400', // pink
                    'border-2 border-emerald-400', // green
                    'border-2 border-violet-400'  // purple
                ];
                urls.forEach((u, idx) => {
                    const sm = resultsByUrl[u].siteMetrics?.data?.site_metrics || {};
                    const linkingDomains = sm.root_domains_to_page ?? 'N/A';
                    const inboundLinks = sm.external_pages_to_page ?? 'N/A';
                    const pageAuthority = sm.page_authority ?? 'N/A';
                    const idist = resultsByUrl[u].intentDistribution || {};
                    const similarity = typeof seedTopicSimilarities[u] === 'number' && !isNaN(seedTopicSimilarities[u]) ? seedTopicSimilarities[u] : 0;
                    const valueScore = typeof resultsByUrl[u]?.valueScore === 'number' && !isNaN(resultsByUrl[u]?.valueScore) ? resultsByUrl[u].valueScore : 0;
                    const topAnchors = resultsByUrl[u].topAnchors || [];
                    const borderClass = urlSummaryColors[idx % urlSummaryColors.length];
                    
                    html += `<div class="bg-[var(--bg-container)] ${borderClass} rounded-lg p-4 min-w-0 overflow-hidden" style="max-width: 100%; box-sizing: border-box; word-wrap: break-word;">`;
                    html += `<h4 class="font-semibold text-[var(--text-primary)] mb-1 truncate min-w-0">URL ${idx + 1}</h4>`;
                    html += `<p class="text-xs text-[var(--text-secondary)] break-all mb-3 min-w-0 overflow-wrap-anywhere">${u}</p>`;
                    
                    html += '<div class="mb-3 pb-3 border-b border-[var(--border-primary)]">';
                    html += '<div class="text-xs font-semibold text-[var(--text-secondary)] mb-2 uppercase tracking-wide">Cluster Analysis Metrics</div>';
                    html += '<div class="space-y-1 text-sm">';
                    html += `<div>Semantic Similarity: <span class="font-bold text-[var(--text-primary)]">${(similarity * 100).toFixed(1)}%</span></div>`;
                    html += `<div>Value Score: <span class="font-bold text-[var(--text-primary)]">${valueScore.toFixed(1)}</span></div>`;
                    html += '</div>';
                    html += '</div>';
                    
                    html += '<div class="mb-3 pb-3 border-b border-[var(--border-primary)]">';
                    html += '<div class="text-xs font-semibold text-[var(--text-secondary)] mb-2 uppercase tracking-wide">Page Metrics</div>';
                    html += '<div class="space-y-1 text-sm">';
                    html += `<div>Linking Domains: <span class="font-bold text-[var(--text-primary)]">${typeof linkingDomains === 'number' ? formatNumber(linkingDomains) : linkingDomains}</span></div>`;
                    html += `<div>Inbound Links: <span class="font-bold text-[var(--text-primary)]">${typeof inboundLinks === 'number' ? formatNumber(inboundLinks) : inboundLinks}</span></div>`;
                    html += `<div>Page Authority: <span class="font-bold text-[var(--text-primary)]">${pageAuthority}</span></div>`;
                    html += '</div>';
                    html += '</div>';
                    
                    // Inbound Anchor Texts (matching Keyword Targeting Analysis style with modal)
                    const allAnchors = topAnchors || [];
                    const anchorsCount = allAnchors.length;
                    const previewAnchors = allAnchors.slice(0, 3);
                    html += '<div class="mb-3 pb-3 border-b border-[var(--border-primary)]">';
                    html += '<div class="flex items-center justify-between mb-2">';
                    html += '<div class="text-xs font-semibold text-[var(--text-secondary)] uppercase tracking-wide">Inbound Anchor Texts</div>';
                    if (anchorsCount > 0) {
                        html += `<button type="button" class="cca-anchors-toggle text-[11px] text-[var(--text-accent)] hover:text-[var(--text-accent-hover)]" data-url-idx="${idx}">View More (${anchorsCount})</button>`;
                    }
                    html += '</div>';
                    if (anchorsCount === 0) {
                        html += '<div class="text-[var(--text-secondary)] text-xs">No inbound anchor texts found.</div>';
                    } else {
                        html += '<div class="space-y-2">';
                        previewAnchors.forEach((anchor) => {
                            const domainsP = (typeof anchor.external_root_domains === 'number') ? formatNumber(anchor.external_root_domains) : (anchor.external_root_domains ?? 'N/A');
                            const pagesP = (typeof anchor.external_pages === 'number') ? formatNumber(anchor.external_pages) : (anchor.external_pages ?? 'N/A');
                            html += '<div class="text-sm min-w-0">';
                            html += `<div class="font-semibold text-[var(--text-primary)] truncate min-w-0">${anchor.text || 'N/A'}</div>`;
                            html += `<div class="text-[var(--text-secondary)] text-xs">Linking Domains: <span class="text-[var(--text-primary)]">${domainsP}</span> ‚Ä¢ Inbound Links: <span class="text-[var(--text-primary)]">${pagesP}</span></div>`;
                            html += '</div>';
                        });
                        html += '</div>';
                    }
                    html += '</div>';

                    const rkList = Array.isArray(resultsByUrl[u].rankingKeywords) ? resultsByUrl[u].rankingKeywords : [];
                    html += '<div class="mt-3">';
                    html += `<div class="text-xs font-semibold text-[var(--text-secondary)] mb-2 uppercase tracking-wide">Ranking Keywords (${rkList.length})</div>`;
                    if (rkList.length === 0) {
                        html += '<div class="text-sm text-[var(--text-secondary)]">No keywords ranking in the top 50 positions</div>';
                    } else {
                        html += '<div class="text-sm text-[var(--text-secondary)]">Top 5:</div>';
                        html += '<div class="space-y-1 text-sm mt-1 min-w-0">';
                        rkList.slice(0, 5).forEach(k => {
                            const keyword = k.keyword || 'N/A';
                            html += `<div class="min-w-0 break-words"><span class="text-[var(--text-primary)] break-words">${keyword}</span> <span class="text-[var(--text-secondary)]">‚Ä¢ Rank:</span> <span class="text-[var(--text-primary)]">${k.rank_position ?? 'N/A'}</span></div>`;
                        });
                        html += '</div>';
                        
                        // Intent distribution (only show if there are ranking keywords)
                    const intents = [
                        { label: 'Informational', color: '#60a5fa', value: Number(idist.Informational || 0) },
                        { label: 'Transactional', color: '#34d399', value: Number(idist.Transactional || 0) },
                        { label: 'Commercial', color: '#fbbf24', value: Number(idist.Commercial || 0) },
                        { label: 'Navigational', color: '#a78bfa', value: Number(idist.Navigational || 0) },
                        { label: 'Unknown', color: '#94a3b8', value: Number(idist.Unknown || 0) },
                    ];
                    const totalIntent = intents.reduce((s, x) => s + x.value, 0) || 1;
                    let offset = 0;
                    const r = 16, c = 2 * Math.PI * r;
                    const slices = intents.map((seg) => {
                        const frac = seg.value / totalIntent;
                        const dash = (c * frac).toFixed(2);
                        const gap = (c - Number(dash)).toFixed(2);
                        const rot = ((offset / totalIntent) * 360).toFixed(2);
                        offset += seg.value;
                        return `<circle r="${r}" cx="20" cy="20" fill="transparent" stroke="${seg.color}" stroke-width="8" stroke-dasharray="${dash} ${gap}" transform="rotate(-90 20 20) rotate(${rot} 20 20)"></circle>`;
                    }).join('');
                        html += '<div class="mt-3 pb-3 border-b border-[var(--border-primary)]">';
                        html += '<div class="text-xs font-semibold text-[var(--text-secondary)] mb-2 uppercase tracking-wide">Search Intent</div>';
                        html += '<div class="flex items-center gap-3">';
                        html += `<svg width="40" height="40" viewBox="0 0 40 40">${slices}</svg>`;
                        html += '<div class="grid grid-cols-2 gap-x-4 gap-y-1 text-[11px]">';
                        intents.forEach(seg => {
                            html += `<div class="flex items-center gap-1"><span style="background:${seg.color};width:8px;height:8px;border-radius:9999px;display:inline-block"></span><span class="text-[var(--text-secondary)]">${seg.label}:</span><span class="text-[var(--text-primary)]">${seg.value}%</span></div>`;
                        });
                        html += '</div>';
                        html += '</div>';
                    }
                    html += '</div>';
                    html += '</div>';
                    html += '</div>';
                });
                html += '</div>';

                html += '</div>';

                allDOMElements.rawCode.textContent = JSON.stringify(payload, null, 2);
                allDOMElements.rawWrapper.innerHTML = html;
                
                // Set up anchor text modal for Content Cluster Analysis (similar to Keyword Targeting Analysis)
                let ccaAnchorModal = document.getElementById('cca-anchor-modal');
                if (!ccaAnchorModal) {
                    ccaAnchorModal = document.createElement('div');
                    ccaAnchorModal.id = 'cca-anchor-modal';
                    ccaAnchorModal.className = 'hidden';
                    ccaAnchorModal.innerHTML = `
                        <div class="fixed inset-0 z-[9998] bg-black/50" data-overlay></div>
                        <div class="fixed z-[9999] left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 bg-[var(--bg-container)] text-[var(--text-primary)] w-[min(92vw,800px)] max-h-[80vh] rounded-lg shadow-xl border border-[var(--border-primary)] p-4 overflow-auto" role="dialog" aria-modal="true">
                            <div class="flex items-center justify-between mb-3">
                                <h5 class="font-semibold">Inbound Anchor Texts</h5>
                                <button type="button" class="cca-modal-close text-sm px-2 py-1 border border-[var(--border-primary)] rounded-md">Close</button>
                            </div>
                            <div class="cca-modal-body space-y-2 text-sm"></div>
                        </div>`;
                    document.body.appendChild(ccaAnchorModal);
                }
                const ccaModal = document.getElementById('cca-anchor-modal');
                const ccaModalBody = ccaModal && ccaModal.querySelector('.cca-modal-body');
                const ccaCloseBtn = ccaModal && ccaModal.querySelector('.cca-modal-close');
                const ccaOverlay = ccaModal && ccaModal.querySelector('[data-overlay]');
                const hideCcaModal = () => {
                    ccaModal.classList.add('hidden');
                    document.body.style.overflow = '';
                };
                const showCcaModal = () => {
                    ccaModal.classList.remove('hidden');
                    document.body.style.overflow = 'hidden';
                };
                if (ccaCloseBtn) ccaCloseBtn.addEventListener('click', hideCcaModal);
                if (ccaOverlay) ccaOverlay.addEventListener('click', hideCcaModal);
                allDOMElements.rawWrapper.querySelectorAll('.cca-anchors-toggle').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const i = Number(btn.getAttribute('data-url-idx'));
                        const url = urls[i];
                        const fullAnchors = (resultsByUrl[url].topAnchors || []);
                        if (!ccaModal || !ccaModalBody) return;
                        ccaModalBody.innerHTML = fullAnchors.length === 0 ? '<div class="text-[var(--text-secondary)]">No anchor texts found.</div>' : fullAnchors.map(a => {
                            const domains = (typeof a.external_root_domains === 'number') ? formatNumber(a.external_root_domains) : (a.external_root_domains ?? 'N/A');
                            const pages = (typeof a.external_pages === 'number') ? formatNumber(a.external_pages) : (a.external_pages ?? 'N/A');
                            return `<div class="border-b border-[var(--border-primary)] pb-2">`
                                + `<div class="font-semibold text-[var(--text-primary)]">${a.text || 'N/A'}</div>`
                                + `<div class="text-[var(--text-secondary)] text-xs">Linking Domains: <span class="text-[var(--text-primary)]">${domains}</span></div>`
                                + `<div class="text-[var(--text-secondary)] text-xs">Inbound Links: <span class="text-[var(--text-primary)]">${pages}</span></div>`
                                + `</div>`;
                        }).join('');
                        showCcaModal();
                    });
                });
                
                // Initialize Tabulator for Semantic Similarity table
                setTimeout(() => {
                    if (typeof Tabulator !== 'undefined' && document.getElementById('cca-similarity-table') && Object.keys(seedTopicSimilarities).length > 0) {
                        const sortedUrls = [...urls].sort((a, b) => (seedTopicSimilarities[b] || 0) - (seedTopicSimilarities[a] || 0));
                        const intentColors = {
                            Informational: '#60a5fa',
                            Commercial: '#fbbf24',
                            Navigational: '#a78bfa',
                            Transactional: '#34d399',
                            Other: '#94a3b8'
                        };
                        
                        const tableData = sortedUrls.map((u, idx) => {
                            const similarity = typeof seedTopicSimilarities[u] === 'number' && !isNaN(seedTopicSimilarities[u]) ? seedTopicSimilarities[u] : 0;
                            const valueScore = typeof resultsByUrl[u]?.valueScore === 'number' && !isNaN(resultsByUrl[u]?.valueScore) ? resultsByUrl[u].valueScore : 0;
                            const primaryIntent = resultsByUrl[u]?.primaryIntent || 'Other';
                            const metrics = resultsByUrl[u]?.mozMetrics || {};
                            const isMain = u === mainTopicPage;
                            const valueFormula = `(${metrics.rankingKeywordsCount || 0}√ó2) + (${metrics.linkingDomains || 0}√ó1.5) + (${metrics.inboundLinks || 0}√ó0.5) + (${metrics.pageAuthority || 0}√ó0.1) + (${metrics.anchorTextsCount || 0}√ó0.3) = ${valueScore.toFixed(1)}`;
                            
                            return {
                                rank: idx + 1,
                                url: u + (isMain ? ' (Main)' : ''),
                                similarityScore: (similarity * 100).toFixed(1) + '%',
                                valueScore: valueScore.toFixed(1),
                                valueScoreTooltip: valueFormula,
                                primaryIntent: primaryIntent,
                                intentColor: intentColors[primaryIntent] || intentColors.Other,
                                isMain: isMain,
                                similarityRaw: similarity
                            };
                        });
                        
                        new Tabulator("#cca-similarity-table", {
                            data: tableData,
                            columns: [
                                { title: 'Rank', field: 'rank', sorter: 'number', width: 80 },
                                { title: 'URL', field: 'url', sorter: 'string', widthGrow: 3, formatter: (cell) => {
                                    const value = cell.getValue();
                                    const isMain = cell.getRow().getData().isMain;
                                    if (isMain) {
                                        return `<span class="break-all">${value.replace(' (Main)', '')} <span class="text-[var(--text-accent)] font-semibold">(Main)</span></span>`;
                                    }
                                    return `<span class="break-all">${value}</span>`;
                                }},
                                { title: 'Similarity Score', field: 'similarityScore', sorter: (a, b) => {
                                    const aData = a.getRow().getData();
                                    const bData = b.getRow().getData();
                                    return (aData.similarityRaw || 0) - (bData.similarityRaw || 0);
                                }, width: 150, formatter: (cell) => {
                                    const similarity = cell.getRow().getData().similarityRaw || 0;
                                    // Green-to-yellow scale: green (high similarity) to yellow (low similarity)
                                    // Similarity ranges from 0 to 1, so:
                                    // High similarity (1.0) = green (rgb(34, 197, 94))
                                    // Low similarity (0.0) = yellow (rgb(234, 179, 8))
                                    const green = Math.round(34 + (234 - 34) * (1 - similarity));
                                    const blue = Math.round(94 + (8 - 94) * (1 - similarity));
                                    const red = Math.round(197 + (234 - 197) * (1 - similarity));
                                    const bgColor = `rgb(${red}, ${green}, ${blue})`;
                                    return `<div style="background-color: ${bgColor}; padding: 4px; border-radius: 4px; font-weight: 600; text-align: center; color: ${similarity > 0.5 ? '#ffffff' : '#000000'};">${cell.getValue()}</div>`;
                                }},
                                { title: 'Value Score', field: 'valueScore', sorter: 'number', width: 120, formatter: (cell) => {
                                    const tooltip = cell.getRow().getData().valueScoreTooltip || '';
                                    return `<span title="${tooltip}">${cell.getValue()}</span>`;
                                }},
                                { title: 'Primary Intent', field: 'primaryIntent', sorter: 'string', width: 150, formatter: (cell) => {
                                    const intent = cell.getValue();
                                    const intentColor = cell.getRow().getData().intentColor;
                                    return `<div style="background-color: ${intentColor}20; color: ${intentColor}; font-weight: 600; padding: 4px; border-radius: 4px; text-align: center; display: flex; align-items: center; justify-content: center; gap: 4px; cursor: help;" title="${intent}"><span style="background:${intentColor};width:8px;height:8px;border-radius:9999px;display:inline-block"></span><span class="truncate">${intent}</span></div>`;
                                }, tooltip: (cell) => {
                                    return cell.getValue();
                                }}
                            ],
                            layout: "fitDataStretch",
                            pagination: "local",
                            paginationSize: 25,
                            movableColumns: true,
                            resizableColumns: true
                        });
                    }
                }, 100);
                
                // Set up collapse/expand handlers for all sections
                allDOMElements.rawWrapper.querySelectorAll('.cca-section-toggle').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const sectionId = btn.getAttribute('data-section');
                        const section = document.getElementById(sectionId);
                        if (section) {
                            const isHidden = section.classList.contains('hidden');
                            section.classList.toggle('hidden');
                            btn.textContent = isHidden ? 'Collapse' : 'Expand';
                        }
                    });
                });
                
                allDOMElements.rawWrapper.classList.remove('hidden');
                allDOMElements.viewDataBtn.textContent = 'View JSON';
                allDOMElements.exportPdfBtn.classList.add('hidden');
                } catch (err) {
                    displayError('Render error in Content Cluster Analysis: ' + (err && err.message ? err.message : err));
                }
            }

            function showContentClustersIdentificationDashboard(data) {
                allDOMElements.tableWrapper.classList.add('hidden');
                allDOMElements.filterBtn.classList.add('hidden');
                allDOMElements.resultsContainer.classList.remove('hidden');
                
                try {
                    const { urls, scope, contentClusters, resultsByUrl, clusterLabels, clusters } = data;
                    
                    let html = '<div id="content-clusters-identification-dashboard" class="space-y-6">';
                    
                    // Header
                    html += '<div class="flex items-start justify-between gap-3 mb-6">';
                    html += '<div>';
                    html += '<h3 class="text-xl font-bold text-[var(--text-heading)] mb-1">Content Clusters Identification</h3>';
                    html += `<p class="text-sm text-[var(--text-secondary)]">URLs Analyzed: <span class="text-[var(--text-primary)]">${urls.length}</span> ‚Ä¢ Scope: ${scope} ‚Ä¢ Clusters Found: ${clusters.length}</p>`;
                    if (contentClusters && contentClusters.length > 0) {
                        html += `<p class="text-xs text-[var(--text-secondary)] mt-1">User-Defined Clusters: ${contentClusters.join(', ')}</p>`;
                    }
                    html += '</div>';
                    html += '</div>';

                    // Summary Statistics
                    html += '<div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">';
                    const intentCounts = {};
                    const clusterCounts = {};
                    urls.forEach(url => {
                        const result = resultsByUrl[url];
                        if (result) {
                            intentCounts[result.primaryIntent] = (intentCounts[result.primaryIntent] || 0) + 1;
                            clusterCounts[result.contentCluster] = (clusterCounts[result.contentCluster] || 0) + 1;
                        }
                    });
                    html += `<div class="bg-[var(--bg-container)] border border-[var(--border-primary)] rounded-lg p-4">`;
                    html += `<div class="text-xs text-[var(--text-secondary)] uppercase mb-1">Total URLs</div>`;
                    html += `<div class="text-2xl font-bold text-[var(--text-primary)]">${urls.length}</div>`;
                    html += `</div>`;
                    html += `<div class="bg-[var(--bg-container)] border border-[var(--border-primary)] rounded-lg p-4">`;
                    html += `<div class="text-xs text-[var(--text-secondary)] uppercase mb-1">Clusters</div>`;
                    html += `<div class="text-2xl font-bold text-[var(--text-primary)]">${clusters.length}</div>`;
                    html += `</div>`;
                    html += `<div class="bg-[var(--bg-container)] border border-[var(--border-primary)] rounded-lg p-4">`;
                    html += `<div class="text-xs text-[var(--text-secondary)] uppercase mb-1">Successfully Analyzed</div>`;
                    html += `<div class="text-2xl font-bold text-[var(--text-primary)]">${urls.filter(url => !resultsByUrl[url]?.errors?.length || resultsByUrl[url]?.errors?.length === 0).length}</div>`;
                    html += `</div>`;
                    html += `<div class="bg-[var(--bg-container)] border border-[var(--border-primary)] rounded-lg p-4">`;
                    html += `<div class="text-xs text-[var(--text-secondary)] uppercase mb-1">With Errors</div>`;
                    html += `<div class="text-2xl font-bold text-[var(--text-error)]">${urls.filter(url => resultsByUrl[url]?.errors?.length > 0).length}</div>`;
                    html += `</div>`;
                    html += '</div>';

                    // Clusters Overview
                    if (clusters.length > 0 || (contentClusters && contentClusters.length > 0)) {
                        html += '<div class="mb-6">';
                        html += '<div class="flex items-center justify-between mb-4">';
                        html += '<h4 class="font-bold text-lg text-[var(--text-primary)]">Content Clusters Overview</h4>';
                        html += '<div class="flex gap-2">';
                        html += '<button type="button" id="cci-filter-all" class="cci-filter-btn px-3 py-1 text-sm rounded-md border border-[var(--border-primary)] bg-[var(--text-accent)] text-white hover:opacity-90">All</button>';
                        html += '<button type="button" id="cci-filter-llm" class="cci-filter-btn px-3 py-1 text-sm rounded-md border border-[var(--border-primary)] bg-[var(--bg-input)] text-[var(--text-primary)] hover:bg-[var(--bg-container)]">LLM-Defined</button>';
                        if (contentClusters && contentClusters.length > 0) {
                            html += '<button type="button" id="cci-filter-user" class="cci-filter-btn px-3 py-1 text-sm rounded-md border border-[var(--border-primary)] bg-[var(--bg-input)] text-[var(--text-primary)] hover:bg-[var(--bg-container)]">User Content Cluster</button>';
                        }
                        html += '</div>';
                        html += '</div>';
                        html += '<div id="cci-clusters-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">';
                        
                        // LLM-Defined Clusters
                        clusters.forEach((cluster, idx) => {
                            const label = clusterLabels.find(cl => cl.clusterIndex === idx);
                            const clusterName = label?.clusterName || `Cluster ${idx + 1}`;
                            // Color palette: blue (idx 0), pink (idx 1), green (idx 2), purple (idx 3), then cycle
                            const colorBorders = [
                                'border-2 border-[var(--text-accent)]', // blue
                                'border-2 border-fuchsia-400', // pink
                                'border-2 border-emerald-400', // green
                                'border-2 border-violet-400'  // purple
                            ];
                            const borderClass = colorBorders[idx % colorBorders.length];
                            
                            html += `<div class="cci-cluster-box bg-[var(--bg-container)] ${borderClass} rounded-lg p-4" data-cluster-type="llm" data-cluster-name="${clusterName}">`;
                            html += `<div class="text-sm font-semibold text-[var(--text-primary)] mb-2">${clusterName}</div>`;
                            if (label?.description) {
                                html += `<div class="text-xs text-[var(--text-secondary)] mb-2">${label.description}</div>`;
                            }
                            html += `<div class="text-xs text-[var(--text-secondary)] mb-2">URLs: <span class="text-[var(--text-primary)] font-semibold">${cluster.urls.length}</span></div>`;
                            if (label?.dominantIntent) {
                                html += `<div class="text-xs text-[var(--text-secondary)] mb-2">Intent: <span class="text-[var(--text-primary)]">${label.dominantIntent}</span></div>`;
                            }
                            if (label?.topicTags && label.topicTags.length > 0) {
                                html += `<div class="text-xs text-[var(--text-secondary)] mb-1">Tags:</div>`;
                                html += `<div class="flex flex-wrap gap-1">`;
                                label.topicTags.slice(0, 5).forEach(tag => {
                                    html += `<span class="px-2 py-1 bg-[var(--bg-input)] text-[var(--text-primary)] text-xs rounded">${tag}</span>`;
                                });
                                if (label.topicTags.length > 5) {
                                    html += `<span class="text-xs text-[var(--text-secondary)]">+${label.topicTags.length - 5} more</span>`;
                                }
                                html += `</div>`;
                            }
                            html += '</div>';
                        });
                        
                        // User-Defined Clusters (if any)
                        if (contentClusters && contentClusters.length > 0) {
                            // Get unique user-defined clusters from results
                            const userClusterNames = [...new Set(contentClusters)];
                            const userClusterStats = {};
                            urls.forEach(url => {
                                const result = resultsByUrl[url];
                                if (result && result.contentCluster && userClusterNames.includes(result.contentCluster)) {
                                    if (!userClusterStats[result.contentCluster]) {
                                        userClusterStats[result.contentCluster] = { count: 0, urls: [] };
                                    }
                                    userClusterStats[result.contentCluster].count++;
                                    userClusterStats[result.contentCluster].urls.push(url);
                                }
                            });
                            
                            userClusterNames.forEach((clusterName, idx) => {
                                const stats = userClusterStats[clusterName] || { count: 0, urls: [] };
                                // Use same color palette, starting from where LLM clusters left off
                                const colorBorders = [
                                    'border-2 border-[var(--text-accent)]', // blue
                                    'border-2 border-fuchsia-400', // pink
                                    'border-2 border-emerald-400', // green
                                    'border-2 border-violet-400'  // purple
                                ];
                                const borderClass = colorBorders[(clusters.length + idx) % colorBorders.length];
                                
                                html += `<div class="cci-cluster-box bg-[var(--bg-container)] ${borderClass} rounded-lg p-4" data-cluster-type="user" data-cluster-name="${clusterName}">`;
                                html += `<div class="text-sm font-semibold text-[var(--text-primary)] mb-2">${clusterName}</div>`;
                                html += `<div class="text-xs text-[var(--text-secondary)] mb-2 italic">User-Defined Cluster</div>`;
                                html += `<div class="text-xs text-[var(--text-secondary)] mb-2">URLs: <span class="text-[var(--text-primary)] font-semibold">${stats.count}</span></div>`;
                                html += '</div>';
                            });
                        }
                        
                        html += '</div>';
                        html += '</div>';
                    }

                    // Pages Table (Tabulator)
                    html += '<div class="mb-6">';
                    html += '<h4 class="font-bold text-lg text-[var(--text-primary)] mb-4">Page Analysis Results</h4>';
                    html += '<div id="cci-page-analysis-table"></div>';
                    html += '</div>';

                    // Errors section (if any)
                    const urlsWithErrors = urls.filter(url => resultsByUrl[url]?.errors?.length > 0);
                    if (urlsWithErrors.length > 0) {
                        html += '<div class="mb-6">';
                        html += '<h4 class="font-bold text-lg text-[var(--text-error)] mb-4">Errors</h4>';
                        html += '<div class="space-y-2">';
                        urlsWithErrors.forEach(url => {
                            html += '<div class="bg-[var(--error-bg)] border border-[var(--error-border)] rounded-lg p-3">';
                            html += `<div class="text-sm font-semibold text-[var(--text-error)] mb-1 break-all">${url}</div>`;
                            html += '<ul class="list-disc list-inside text-xs text-[var(--text-error)]">';
                            resultsByUrl[url].errors.forEach(error => {
                                html += `<li>${error}</li>`;
                            });
                            html += '</ul>';
                            html += '</div>';
                        });
                        html += '</div>';
                        html += '</div>';
                    }

                    html += '</div>';
                    
                    allDOMElements.rawCode.textContent = '';
                    allDOMElements.rawWrapper.innerHTML = html;
                    allDOMElements.rawWrapper.classList.remove('hidden');
                    allDOMElements.viewDataBtn.textContent = 'View JSON';
                    allDOMElements.exportPdfBtn.classList.add('hidden');
                    
                    // Initialize Tabulator for Page Analysis Results
                    setTimeout(() => {
                        if (typeof Tabulator !== 'undefined' && document.getElementById('cci-page-analysis-table')) {
                            const tableData = urls.map(url => {
                                const result = resultsByUrl[url];
                                if (!result) return null;
                                return {
                                    url: url,
                                    llmDefinedTopic: result.llmDefinedTopic || 'N/A',
                                    llmCluster: result.llmCluster || 'Unassigned',
                                    contentCluster: result.contentCluster || 'Unassigned',
                                    primaryIntent: result.primaryIntent || 'N/A',
                                    audience: result.audience || 'N/A',
                                    expertiseLevel: result.expertiseLevel || 'N/A',
                                    topicTags: result.topicTags && result.topicTags.length > 0 ? result.topicTags.join(', ') : 'N/A'
                                };
                            }).filter(row => row !== null);
                            
                            new Tabulator("#cci-page-analysis-table", {
                                data: tableData,
                                columns: [
                                    { title: 'URL', field: 'url', sorter: 'string', widthGrow: 2 },
                                    { title: 'LLM-Defined Topic', field: 'llmDefinedTopic', sorter: 'string' },
                                    { title: 'LLM Cluster', field: 'llmCluster', sorter: 'string' },
                                    { title: 'Content Cluster', field: 'contentCluster', sorter: 'string' },
                                    { title: 'Primary Intent', field: 'primaryIntent', sorter: 'string' },
                                    { title: 'Audience', field: 'audience', sorter: 'string' },
                                    { title: 'Expertise Level', field: 'expertiseLevel', sorter: 'string' },
                                    { title: 'Topic Tags', field: 'topicTags', sorter: 'string', widthGrow: 2 }
                                ],
                                layout: "fitDataStretch",
                                pagination: "local",
                                paginationSize: 25,
                                movableColumns: true,
                                resizableColumns: true
                            });
                        }
                    }, 100);
                    
                    // Initialize cluster filter buttons
                    setTimeout(() => {
                        const filterButtons = document.querySelectorAll('.cci-filter-btn');
                        const clusterBoxes = document.querySelectorAll('.cci-cluster-box');
                        
                        filterButtons.forEach(btn => {
                            btn.addEventListener('click', () => {
                                // Update active state
                                filterButtons.forEach(b => {
                                    b.classList.remove('bg-[var(--text-accent)]', 'text-white');
                                    b.classList.add('bg-[var(--bg-input)]', 'text-[var(--text-primary)]');
                                    b.classList.remove('hover:bg-white', 'hover:text-white');
                                });
                                btn.classList.remove('bg-[var(--bg-input)]', 'text-[var(--text-primary)]');
                                btn.classList.add('bg-[var(--text-accent)]', 'text-white');
                                btn.classList.remove('hover:bg-white', 'hover:text-white');
                                
                                // Filter clusters
                                const filterType = btn.id.replace('cci-filter-', '');
                                clusterBoxes.forEach(box => {
                                    if (filterType === 'all') {
                                        box.classList.remove('hidden');
                                    } else if (filterType === 'llm') {
                                        if (box.getAttribute('data-cluster-type') === 'llm') {
                                            box.classList.remove('hidden');
                                        } else {
                                            box.classList.add('hidden');
                                        }
                                    } else if (filterType === 'user') {
                                        if (box.getAttribute('data-cluster-type') === 'user') {
                                            box.classList.remove('hidden');
                                        } else {
                                            box.classList.add('hidden');
                                        }
                                    }
                                });
                            });
                        });
                    }, 100);
                } catch (err) {
                    displayError('Render error in Content Clusters Identification: ' + (err && err.message ? err.message : err));
                }
            }

            function showCompetitiveDashboard(data) {
                // Hide regular view elements
                allDOMElements.tableWrapper.classList.add('hidden');
                allDOMElements.filterBtn.classList.add('hidden');
                
                // Show results container and raw wrapper (we'll put dashboard in rawWrapper)
                allDOMElements.resultsContainer.classList.remove('hidden');
                
                // Helper function to format numbers with K/M abbreviations
                const formatNumber = (num) => {
                    if (typeof num !== 'number' || num === 'N/A') return num;
                    if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
                    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                    return num.toLocaleString();
                };
                
                // Helper function to create tooltip
                const createTooltip = (text, tooltipText) => {
                    return `<span class="tooltip-container">${text}<span class="tooltip-icon">?</span><span class="tooltip-text">${tooltipText}</span></span>`;
                };
                
                // Create dashboard HTML
                let dashboardHTML = '<div id="competitive-dashboard" class="space-y-6">';
                dashboardHTML += '<div class="flex items-start justify-between gap-3 mb-4">';
                dashboardHTML += '<h3 class="text-xl font-bold text-[var(--text-heading)]">Competitive Analysis Dashboard</h3>';
                dashboardHTML += '<div class="shrink-0">';
                dashboardHTML += '<button type="button" class="compare-all-btn text-xs px-3 py-1 rounded-md border border-[var(--border-primary)] text-[var(--text-primary)] hover:bg-[var(--bg-hover)]" data-target="#competitive-metrics-grid">Compare All</button>';
                dashboardHTML += '</div>';
                dashboardHTML += '</div>';
                
                // Create metrics grid - ensure all boxes in one row
                const domainCount = Object.keys(data).length;
                const initialColumns = domainCount <= 2 ? domainCount : 2; // Start with 2 columns if 2+ domains, else show all
                dashboardHTML += `<div id=\"competitive-metrics-grid\" class=\"metrics-grid-container\">`;
                Object.values(data).forEach((domainData, idx) => {
                    const sm = domainData.siteMetrics?.data?.site_metrics || {};
                    const ba = domainData.brandAuthority?.data?.site_metrics?.brand_authority_score ?? 'N/A';
                    const da = sm.domain_authority ?? 'N/A';
                    const links = sm.external_pages_to_root_domain ?? 'N/A';
                    const linkingDomains = sm.root_domains_to_root_domain ?? 'N/A';
                    const spam = sm.spam_score ?? 'N/A';
                    
                    // Extract domain name from URL
                    const domainName = domainData.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0];
                    
                    // Enhanced styling for "Your Domain" and competitor cards with gradients
                    const isYourDomain = idx === 0;
                    let cardClasses = '';
                    let gradientBar = '';
                    
                    if (isYourDomain) {
                        cardClasses = 'bg-gradient-to-br from-[var(--text-accent)]/10 to-[var(--bg-container)] border-2 border-[var(--text-accent)] rounded-lg p-4 shadow-lg relative';
                        gradientBar = '<div class="absolute top-0 left-0 right-0 h-1 bg-gradient-to-r from-[var(--text-accent)] to-transparent rounded-t-lg"></div>';
                    } else {
                        // Competitor outlines: neon pink (idx 1), neon green (idx 2), neon purple (idx 3)
                        // Only outline/border, no background fill - matching "Your Domain" style
                        const competitorBorders = [
                            'border-2 border-fuchsia-400',
                            'border-2 border-emerald-400',
                            'border-2 border-violet-400'
                        ];
                        const gradientIndex = idx - 1;
                        cardClasses = 'bg-[var(--bg-container)] ' + competitorBorders[gradientIndex] + ' rounded-lg p-4 shadow-md relative';
                        const gradientColors = ['from-fuchsia-400 via-fuchsia-500 to-transparent', 'from-emerald-400 via-emerald-500 to-transparent', 'from-violet-400 via-violet-500 to-transparent'];
                        gradientBar = `<div class="absolute top-0 left-0 right-0 h-1 bg-gradient-to-r ${gradientColors[gradientIndex]} rounded-t-lg"></div>`;
                    }
                    
                    // Ensure grid items are properly constrained
                    dashboardHTML += `<div class="${cardClasses}" style="min-width: 0; max-width: 100%; width: 100%; box-sizing: border-box; overflow: hidden;">`;
                    dashboardHTML += gradientBar;
                    dashboardHTML += `<h4 class="font-bold text-[var(--text-primary)] mb-1 ${isYourDomain ? 'text-lg' : ''}">${isYourDomain ? 'Your Domain' : domainName}</h4>`;
                    dashboardHTML += `<p class="text-xs text-[var(--text-secondary)] mb-3">${domainData.domain}</p>`;
                    
                    // Authority Metrics Group
                    dashboardHTML += `<div class="mb-3 pb-3 border-b border-[var(--border-primary)]">`;
                    dashboardHTML += `<div class="text-xs font-semibold text-[var(--text-secondary)] mb-2 uppercase tracking-wide">Authority Metrics</div>`;
                    dashboardHTML += `<div class="space-y-2 text-sm">`;
                    dashboardHTML += `<div>Brand Authority: <span class="font-semibold text-[var(--text-primary)]">${ba}</span></div>`;
                    dashboardHTML += `<div>Domain Authority: <span class="font-semibold text-[var(--text-primary)]">${da}</span></div>`;
                    dashboardHTML += `</div></div>`;
                    
                    // Link Metrics Group
                    dashboardHTML += `<div class="mb-3 pb-3 border-b border-[var(--border-primary)]">`;
                    dashboardHTML += `<div class="text-xs font-semibold text-[var(--text-secondary)] mb-2 uppercase tracking-wide">Link Metrics</div>`;
                    dashboardHTML += `<div class="space-y-2 text-sm">`;
                    dashboardHTML += `<div>Total Links: <span class="font-semibold text-[var(--text-primary)]">${typeof links === 'number' ? formatNumber(links) : links}</span></div>`;
                    dashboardHTML += `<div>Linking Domains: <span class="font-semibold text-[var(--text-primary)]">${typeof linkingDomains === 'number' ? formatNumber(linkingDomains) : linkingDomains}</span></div>`;
                    dashboardHTML += `<div>Spam Score: <span class="font-semibold text-[var(--text-primary)]">${spam}</span></div>`;
                    dashboardHTML += `</div></div>`;
                    
                    // Add keyword count breakdown
                    const kc = domainData.keywordCount?.data?.ranking_keyword_count;
                    if (kc) {
                        const positions = kc.position || {};
                        const rank1_3 = (positions.rank_1 || 0) + (positions.rank_2 || 0) + (positions.rank_3 || 0);
                        const rank4_10 = [4,5,6,7,8,9,10].reduce((sum, r) => sum + (positions[`rank_${r}`] || 0), 0);
                        const rank11_20 = [11,12,13,14,15,16,17,18,19,20].reduce((sum, r) => sum + (positions[`rank_${r}`] || 0), 0);
                        const rank21_50 = [21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50].reduce((sum, r) => sum + (positions[`rank_${r}`] || 0), 0);
                        
                        dashboardHTML += `<div class="mt-3">`;
                        dashboardHTML += `<div class="text-xs font-semibold text-[var(--text-secondary)] mb-2 uppercase tracking-wide">Keyword Metrics</div>`;
                        dashboardHTML += `<div class="space-y-1 text-xs">`;
                        dashboardHTML += `<div><span class="text-[var(--text-secondary)]">Ranks 1-3:</span> <span class="font-semibold text-[var(--text-primary)]">${formatNumber(rank1_3)}</span></div>`;
                        dashboardHTML += `<div><span class="text-[var(--text-secondary)]">Ranks 4-10:</span> <span class="font-semibold text-[var(--text-primary)]">${formatNumber(rank4_10)}</span></div>`;
                        dashboardHTML += `<div><span class="text-[var(--text-secondary)]">Ranks 11-20:</span> <span class="font-semibold text-[var(--text-primary)]">${formatNumber(rank11_20)}</span></div>`;
                        dashboardHTML += `<div><span class="text-[var(--text-secondary)]">Ranks 21-50:</span> <span class="font-semibold text-[var(--text-primary)]">${formatNumber(rank21_50)}</span></div>`;
                        dashboardHTML += `<div><span class="text-[var(--text-secondary)]">Total:</span> <span class="font-semibold text-[var(--text-primary)]">${formatNumber(kc.total || 0)}</span></div>`;
                        dashboardHTML += `</div></div>`;
                    }
                    
                    dashboardHTML += `</div>`;
                    if (domainData.errors && domainData.errors.length > 0) {
                        dashboardHTML += `<div class="mt-2 text-xs text-[var(--text-error)]">Errors: ${domainData.errors.join(', ')}</div>`;
                    }
                    // Note: Do not close the grid container here; only close the card div above
                });
                dashboardHTML += '</div>';
                
                // Create keywords section (Top Ranking Keywords) - FIRST
                dashboardHTML += '<div id="keywords-section" class="mt-6">';
                dashboardHTML += '<div class="flex items-center justify-between mb-4">';
                dashboardHTML += '<h4 class="font-bold text-lg text-[var(--text-primary)]">Top Ranking Keywords</h4>';
                // Move domain selector here
                dashboardHTML += '<div><label for="domain-selector" class="inline-block text-sm font-medium text-[var(--text-secondary)] mr-2">View Details For:</label>';
                dashboardHTML += '<select id="domain-selector" class="inline-block bg-[var(--bg-input)] border border-[var(--border-secondary)] rounded-md px-3 py-2 text-sm text-[var(--text-primary)]">';
                Object.values(data).forEach((domainData, idx) => {
                    dashboardHTML += `<option value="${idx}">${domainData.label}: ${domainData.domain}</option>`;
                });
                dashboardHTML += '</select></div></div>';
                
                // Render Top Ranking Keywords tables
                Object.values(data).forEach((domainData, idx) => {
                    dashboardHTML += `<div id="keywords-${idx}" class="keywords-panel ${idx === 0 ? '' : 'hidden'}">`;
                    dashboardHTML += `<h5 class="font-semibold text-[var(--text-heading)] mb-2">${domainData.label}</h5>`;
                    
                    const keywords = domainData.rankingKeywords?.data?.ranking_keywords || [];
                    if (keywords.length > 0) {
                        dashboardHTML += '<div id="comp-keywords-table-' + idx + '"></div>';
                    } else {
                        dashboardHTML += '<p class="text-[var(--text-secondary)]">No ranking keywords found.</p>';
                    }
                    dashboardHTML += '</div>';
                });
                dashboardHTML += '</div>';
                
                // Add Keyword Gap Snapshot section - SECOND
                // Get your domain's keywords
                const yourDomainData = Object.values(data)[0];
                const yourDomainName = yourDomainData.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0];
                const yourKeywords = new Set((yourDomainData.rankingKeywords?.data?.ranking_keywords || []).map(kw => kw.keyword?.toLowerCase()).filter(Boolean));
                
                // Find keywords competitors rank for that your domain doesn't
                const gapKeywords = [];
                Object.values(data).slice(1).forEach((competitorData) => {
                    const competitorKeywords = competitorData.rankingKeywords?.data?.ranking_keywords || [];
                    competitorKeywords.forEach(kw => {
                        const kwLower = kw.keyword?.toLowerCase();
                        if (kwLower && !yourKeywords.has(kwLower) && kw.volume) {
                            gapKeywords.push({
                                keyword: kw.keyword,
                                volume: kw.volume || 0,
                                difficulty: kw.difficulty,
                                competitor: competitorData.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0]
                            });
                        }
                    });
                });
                
                // Remove duplicates and sort by volume
                const uniqueGapKeywords = [];
                const seenKeywords = new Set();
                gapKeywords.forEach(kw => {
                    if (!seenKeywords.has(kw.keyword.toLowerCase())) {
                        seenKeywords.add(kw.keyword.toLowerCase());
                        uniqueGapKeywords.push(kw);
                    }
                });
                uniqueGapKeywords.sort((a, b) => (b.volume || 0) - (a.volume || 0));
                
                dashboardHTML += '<div id="keyword-gap-section" class="mt-6">';
                dashboardHTML += '<div class="flex items-center justify-between mb-4">';
                dashboardHTML += '<h4 class="font-bold text-lg text-[var(--text-primary)]">Keyword Gap Snapshot</h4>';
                dashboardHTML += '<button id="toggle-keyword-gap" class="text-sm text-[var(--text-accent)] hover:text-[var(--text-accent-hover)] font-semibold">Collapse</button>';
                dashboardHTML += '</div>';
                dashboardHTML += '<p class="text-sm text-[var(--text-secondary)] mb-4">Here\'s a list of keywords your competitors are ranking for that may be fruitful opportunities to target.</p>';
                dashboardHTML += '<div id="keyword-gap-content">';
                
                if (uniqueGapKeywords.length > 0) {
                    dashboardHTML += '<div id="comp-keyword-gap-table"></div>';
                    if (uniqueGapKeywords.length > 20) {
                        dashboardHTML += `<p class="text-sm text-[var(--text-secondary)] mt-2">Showing top 20 of ${uniqueGapKeywords.length} keyword opportunities</p>`;
                    }
                } else {
                    dashboardHTML += '<p class="text-[var(--text-secondary)]">No keyword gaps found ‚Äî your domain ranks for all competitor keywords.</p>';
                }
                dashboardHTML += '</div>';
                dashboardHTML += '</div>';
                
                // Add overlapping keywords section - THIRD
                dashboardHTML += '<div id="overlapping-keywords-section" class="mt-6">';
                dashboardHTML += '<div class="flex items-center justify-between mb-4">';
                dashboardHTML += '<h4 class="font-bold text-lg text-[var(--text-primary)]">Overlapping Keywords</h4>';
                dashboardHTML += '<button id="toggle-overlapping" class="text-sm text-[var(--text-accent)] hover:text-[var(--text-accent-hover)] font-semibold">Collapse</button>';
                dashboardHTML += '</div>';
                dashboardHTML += '<div id="overlapping-keywords-content">';
                
                // Extract all keywords for each domain
                const domainKeywords = {};
                Object.values(data).forEach((domainData, idx) => {
                    const keywords = domainData.rankingKeywords?.data?.ranking_keywords || [];
                    const domainName = domainData.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0];
                    domainKeywords[domainName] = keywords.map(kw => kw.keyword?.toLowerCase()).filter(Boolean);
                });
                
                // Find overlapping keywords
                const domainNames = Object.keys(domainKeywords);
                if (domainNames.length > 1) {
                    // Create a map of keyword to domains that rank for it
                    const keywordToDomains = {};
                    domainNames.forEach(domain => {
                        domainKeywords[domain].forEach(keyword => {
                            if (!keywordToDomains[keyword]) {
                                keywordToDomains[keyword] = [];
                            }
                            if (!keywordToDomains[keyword].includes(domain)) {
                                keywordToDomains[keyword].push(domain);
                            }
                        });
                    });
                    
                    // Find keywords that appear in 2+ domains
                    const overlappingKeywords = Object.entries(keywordToDomains)
                        .filter(([keyword, domains]) => domains.length > 1)
                        .map(([keyword, domains]) => {
                            const keywordData = {};
                            domainNames.forEach(domain => {
                                // Find the domain data entry that matches this domain name
                                const domainEntry = Object.values(data).find(d => {
                                    const dName = d.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0];
                                    return dName === domain;
                                });
                                const kwData = domainEntry?.rankingKeywords?.data?.ranking_keywords?.find(k => k.keyword?.toLowerCase() === keyword);
                                if (kwData) {
                                    keywordData[domain] = {
                                        rank: kwData.rank_position
                                    };
                                }
                            });
                            return { keyword, domains, data: keywordData };
                        })
                        .sort((a, b) => b.domains.length - a.domains.length || a.keyword.localeCompare(b.keyword));
                    
                    if (overlappingKeywords.length > 0) {
                        dashboardHTML += '<div id="comp-overlapping-keywords-table"></div>';
                    } else {
                        dashboardHTML += '<div class="bg-[var(--bg-input)] border border-[var(--border-primary)] rounded-lg p-6 text-center">';
                        dashboardHTML += '<p class="text-[var(--text-secondary)] mb-2">No overlapping keywords found.</p>';
                        dashboardHTML += '<p class="text-sm text-[var(--text-secondary)]">Try expanding your competitors list or increase ranking keyword counts to get more comparisons.</p>';
                        dashboardHTML += '</div>';
                    }
                } else {
                    dashboardHTML += '<p class="text-[var(--text-secondary)]">Add competitors to see overlapping keywords.</p>';
                }
                dashboardHTML += '</div>';
                dashboardHTML += '</div>';
                dashboardHTML += '</div>';
                
                // Store JSON data and replace raw wrapper with dashboard
                allDOMElements.rawCode.textContent = JSON.stringify(data, null, 2);
                allDOMElements.rawWrapper.innerHTML = dashboardHTML;
                // Attach compare-all toggle handler
                const compareBtnComp = allDOMElements.rawWrapper.querySelector('.compare-all-btn[data-target="#competitive-metrics-grid"]');
                if (compareBtnComp) {
                    compareBtnComp.addEventListener('click', () => {
                        const target = allDOMElements.rawWrapper.querySelector('#competitive-metrics-grid');
                        if (!target) return;
                        const isWide = target.classList.toggle('wide');
                        compareBtnComp.textContent = isWide ? 'Collapse' : 'Compare All';
                    });
                }
                allDOMElements.rawWrapper.classList.remove('hidden');
                allDOMElements.viewDataBtn.textContent = 'View JSON';
                allDOMElements.exportPdfBtn.classList.remove('hidden');
                
                // Initialize Tabulator tables for Competitive Analysis
                setTimeout(() => {
                    if (typeof Tabulator !== 'undefined') {
                        // Initialize ranking keywords tables
                        Object.values(data).forEach((domainData, idx) => {
                            const keywords = domainData.rankingKeywords?.data?.ranking_keywords || [];
                            if (keywords.length > 0 && document.getElementById(`comp-keywords-table-${idx}`)) {
                                const limit = currentOriginalParams?.limit || 25;
                                const tableData = keywords.slice(0, limit).map(kw => ({
                                    keyword: kw.keyword || 'N/A',
                                    rank: kw.rank_position ?? 'N/A',
                                    page: kw.ranking_page || 'N/A',
                                    difficulty: kw.difficulty ?? 'N/A',
                                    volume: kw.volume ? formatNumber(kw.volume) : 'N/A'
                                }));
                                
                                new Tabulator(`#comp-keywords-table-${idx}`, {
                                    data: tableData,
                                    columns: [
                                        { title: 'Keyword', field: 'keyword', sorter: 'string' },
                                        { title: 'Rank', field: 'rank', sorter: 'number' },
                                        { title: 'Page', field: 'page', sorter: 'string' },
                                        { title: 'Difficulty', field: 'difficulty', sorter: 'number' },
                                        { title: 'Volume', field: 'volume', sorter: 'string' }
                                    ],
                                    layout: "fitDataStretch",
                                    pagination: "local",
                                    paginationSize: 25,
                                    movableColumns: true,
                                    resizableColumns: true
                                });
                            }
                        });
                        
                        // Initialize keyword gap table
                        if (uniqueGapKeywords.length > 0 && document.getElementById('comp-keyword-gap-table')) {
                            const gapTableData = uniqueGapKeywords.slice(0, 20).map(kw => ({
                                keyword: kw.keyword,
                                volume: kw.volume ? formatNumber(kw.volume) : 'N/A',
                                difficulty: kw.difficulty ?? 'N/A',
                                competitor: kw.competitor
                            }));
                            
                            new Tabulator('#comp-keyword-gap-table', {
                                data: gapTableData,
                                columns: [
                                    { title: 'Keyword', field: 'keyword', sorter: 'string' },
                                    { title: 'Volume', field: 'volume', sorter: 'string' },
                                    { title: 'Difficulty', field: 'difficulty', sorter: 'number' },
                                    { title: 'Competitor', field: 'competitor', sorter: 'string' }
                                ],
                                layout: "fitDataStretch",
                                pagination: "local",
                                paginationSize: 20,
                                movableColumns: true,
                                resizableColumns: true
                            });
                        }
                        
                        // Initialize overlapping keywords table
                        if (overlappingKeywords && overlappingKeywords.length > 0 && document.getElementById('comp-overlapping-keywords-table')) {
                            const domainNames = Object.keys(domainKeywords);
                            const overlapTableData = overlappingKeywords.map(overlap => {
                                const obj = {
                                    keyword: overlap.keyword,
                                    sharedBy: `${overlap.domains.length} domains`
                                };
                                domainNames.forEach(domain => {
                                    const kwData = overlap.data[domain];
                                    obj[domain] = kwData ? (kwData.rank ?? 'N/A') : 'Not ranking';
                                });
                                return obj;
                            });
                            
                            const columns = [
                                { title: 'Keyword', field: 'keyword', sorter: 'string' },
                                { title: 'Shared By', field: 'sharedBy', sorter: 'string' }
                            ];
                            domainNames.forEach(domain => {
                                columns.push({ title: domain, field: domain, sorter: 'number' });
                            });
                            
                            new Tabulator('#comp-overlapping-keywords-table', {
                                data: overlapTableData,
                                columns: columns,
                                layout: "fitDataStretch",
                                pagination: "local",
                                paginationSize: 25,
                                movableColumns: true,
                                resizableColumns: true
                            });
                        }
                    }
                    
                    // Force grid layout after DOM insertion - always show all domains in one row
                    const gridContainer = document.querySelector('.metrics-grid-container');
                    if (gridContainer) {
                        const updateGrid = () => {
                            const width = window.innerWidth;
                            const domainCount = Object.keys(data).length;
                            
                            // Always try to show all domains in one row
                            if (width >= 1280) {
                                // Large screen: show all domains up to 4 in one row
                                gridContainer.style.gridTemplateColumns = `repeat(${Math.min(domainCount, 4)}, minmax(0, 1fr))`;
                            } else if (width >= 768) {
                                // Tablet: show all domains up to 2 in one row, or 3 if screen is wide enough
                                if (domainCount <= 3 && width >= 900) {
                                    gridContainer.style.gridTemplateColumns = `repeat(${domainCount}, minmax(0, 1fr))`;
                                } else {
                                    gridContainer.style.gridTemplateColumns = domainCount <= 2 
                                        ? `repeat(${domainCount}, minmax(0, 1fr))`
                                        : 'repeat(2, minmax(0, 1fr))';
                                }
                            } else {
                                // Mobile: always 1 column
                                gridContainer.style.gridTemplateColumns = 'repeat(1, minmax(0, 1fr))';
                            }
                            gridContainer.style.display = 'grid';
                        };
                        updateGrid();
                        window.addEventListener('resize', updateGrid);
                    }
                }, 100);
                
                // Change "Clear Data" button to "Reset" for competitive analysis
                const clearBtn = allDOMElements.clearDataBtn;
                if (clearBtn) {
                    clearBtn.textContent = 'Reset';
                    clearBtn.dataset.originalText = 'Clear Data';
                }
                
                // Add event listener for domain selector
                const selector = document.getElementById('domain-selector');
                if (selector) {
                    selector.addEventListener('change', (e) => {
                        const selectedIdx = parseInt(e.target.value);
                        document.querySelectorAll('.keywords-panel').forEach((panel, idx) => {
                            panel.classList.toggle('hidden', idx !== selectedIdx);
                        });
                    });
                }
                
                // Add event listener for keyword gap toggle
                const toggleKeywordGap = document.getElementById('toggle-keyword-gap');
                const keywordGapContent = document.getElementById('keyword-gap-content');
                if (toggleKeywordGap && keywordGapContent) {
                    toggleKeywordGap.addEventListener('click', () => {
                        const isHidden = keywordGapContent.classList.contains('hidden');
                        if (isHidden) {
                            keywordGapContent.classList.remove('hidden');
                            toggleKeywordGap.textContent = 'Collapse';
                        } else {
                            keywordGapContent.classList.add('hidden');
                            toggleKeywordGap.textContent = 'Expand';
                        }
                    });
                }
                
                // Add event listener for overlapping keywords toggle
                const toggleOverlapping = document.getElementById('toggle-overlapping');
                const overlappingContent = document.getElementById('overlapping-keywords-content');
                if (toggleOverlapping && overlappingContent) {
                    toggleOverlapping.addEventListener('click', () => {
                        const isHidden = overlappingContent.classList.contains('hidden');
                        if (isHidden) {
                            overlappingContent.classList.remove('hidden');
                            toggleOverlapping.textContent = 'Collapse';
                        } else {
                            overlappingContent.classList.add('hidden');
                            toggleOverlapping.textContent = 'Expand';
                        }
                    });
                }
                
                // Add sorting functionality for keywords tables
                document.querySelectorAll('.sortable-header').forEach(header => {
                    header.addEventListener('click', function() {
                        const table = this.closest('table');
                        const tbody = table.querySelector('tbody');
                        const rows = Array.from(tbody.querySelectorAll('tr'));
                        const sortBy = this.dataset.sort;
                        const isAsc = this.classList.contains('sort-asc');
                        
                        // Remove all sort classes
                        table.querySelectorAll('.sortable-header').forEach(h => {
                            h.classList.remove('sort-asc', 'sort-desc');
                        });
                        
                        // Add sort class
                        this.classList.add(isAsc ? 'sort-desc' : 'sort-asc');
                        
                        // Sort rows
                        rows.sort((a, b) => {
                            let aVal, bVal;
                            if (sortBy === 'keyword') {
                                aVal = a.dataset.keyword || '';
                                bVal = b.dataset.keyword || '';
                                return isAsc ? bVal.localeCompare(aVal) : aVal.localeCompare(bVal);
                            } else {
                                aVal = parseFloat(a.dataset[sortBy]) || 0;
                                bVal = parseFloat(b.dataset[sortBy]) || 0;
                                return isAsc ? bVal - aVal : aVal - bVal;
                            }
                        });
                        
                        // Reorder rows
                        rows.forEach(row => tbody.appendChild(row));
                    });
                });
                
                // Add copy keyword functionality
                document.querySelectorAll('.copy-keyword-btn').forEach(btn => {
                    btn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const keyword = this.dataset.keyword;
                        if (keyword) {
                            if (navigator.clipboard && navigator.clipboard.writeText) {
                                navigator.clipboard.writeText(keyword).then(() => {
                                    const originalText = this.textContent;
                                    this.textContent = '‚úì';
                                    setTimeout(() => {
                                        this.textContent = originalText;
                                    }, 2000);
                                }).catch(() => {
                                    displayError('Failed to copy keyword.');
                                });
                            } else {
                                // Fallback
                                const textArea = document.createElement('textarea');
                                textArea.value = keyword;
                                document.body.appendChild(textArea);
                                textArea.select();
                                try {
                                    document.execCommand('copy');
                                    const originalText = this.textContent;
                                    this.textContent = '‚úì';
                                    setTimeout(() => {
                                        this.textContent = originalText;
                                    }, 2000);
                                } catch (e) {
                                    displayError('Failed to copy keyword.');
                                }
                                document.body.removeChild(textArea);
                            }
                        }
                    });
                });
            }

            function handleExportPdf() {
                if (currentMethod !== 'competitiveAnalysis' || !currentResultsData) {
                    displayError('PDF export is only available for competitive analysis results.');
                    return;
                }
                
                const dashboard = document.getElementById('competitive-dashboard');
                if (!dashboard) {
                    displayError('Dashboard not found. Please run the analysis again.');
                    return;
                }
                
                // Show loading state
                const originalText = allDOMElements.exportPdfBtn.textContent;
                allDOMElements.exportPdfBtn.textContent = 'Generating PDF...';
                allDOMElements.exportPdfBtn.disabled = true;
                
                // Use html2canvas to capture the dashboard
                html2canvas(dashboard, {
                    backgroundColor: getComputedStyle(document.body).backgroundColor,
                    scale: 2,
                    logging: false
                }).then(canvas => {
                    const imgData = canvas.toDataURL('image/png');
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF('p', 'mm', 'a4');
                    
                    const imgWidth = 210; // A4 width in mm
                    const pageHeight = 297; // A4 height in mm
                    const imgHeight = (canvas.height * imgWidth) / canvas.width;
                    let heightLeft = imgHeight;
                    let position = 0;
                    
                    pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;
                    
                    while (heightLeft > 0) {
                        position = heightLeft - imgHeight;
                        pdf.addPage();
                        pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                        heightLeft -= pageHeight;
                    }
                    
                    const dateStr = new Date().toISOString().split('T')[0];
                    pdf.save(`competitive-analysis-${dateStr}.pdf`);
                    
                    // Reset button
                    allDOMElements.exportPdfBtn.textContent = originalText;
                    allDOMElements.exportPdfBtn.disabled = false;
                }).catch(error => {
                    console.error('PDF export error:', error);
                    displayError('Failed to export PDF. Please try again.');
                    allDOMElements.exportPdfBtn.textContent = originalText;
                    allDOMElements.exportPdfBtn.disabled = false;
                });
            }

            function handleCopyJson() {
                if (allDOMElements.rawCode.textContent) {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(allDOMElements.rawCode.textContent).then(() => {
                            allDOMElements.copyJsonBtn.textContent = 'Copied!';
                            setTimeout(() => { allDOMElements.copyJsonBtn.textContent = 'Copy JSON'; }, 2000);
                        }, () => {
                            displayError('Failed to copy JSON.');
                        });
                    } else {
                        // Fallback for older browsers
                        const textArea = document.createElement('textarea');
                        textArea.value = allDOMElements.rawCode.textContent;
                        document.body.appendChild(textArea);
                        textArea.select();
                        try {
                            document.execCommand('copy');
                            allDOMElements.copyJsonBtn.textContent = 'Copied!';
                            setTimeout(() => { allDOMElements.copyJsonBtn.textContent = 'Copy JSON'; }, 2000);
                        } catch (e) {
                            displayError('Failed to copy JSON.');
                        }
                        document.body.removeChild(textArea);
                    }
                }
            }
            
            function handleExportCsv() {
                if (currentMethod === 'competitiveAnalysis' && currentResultsData) {
                    exportCompetitiveAnalysisToCsv(currentResultsData, currentOriginalParams);
    } else if (currentMethod === 'keywordTargetingAnalysis' && currentResultsData) {
        exportKeywordTargetingToCsv(currentResultsData);
    } else if (currentMethod === 'contentClusterAnalysis' && currentResultsData) {
        exportContentClusterAnalysisToCsv(currentResultsData);
    } else if (currentMethod === 'contentClustersIdentification' && currentResultsData) {
        exportContentClustersIdentificationToCsv(currentResultsData);
    } else if (currentResultsData) {
                    exportDataToCsv(currentResultsData, currentMethod, currentOriginalParams);
                } else {
                    displayError("No data available to export.");
                }
            }
            
            function exportCompetitiveAnalysisToCsv(data, params) {
                // Load SheetJS library dynamically
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                script.onload = () => {
                    try {
                        const workbook = XLSX.utils.book_new();
                        
                        // Sheet 1: Domain Metrics Summary
                        const metricsData = [];
                        metricsData.push(['Domain', 'Brand Authority', 'Domain Authority', 'Total Links', 'Linking Domains', 'Spam Score', 'Ranks 1-3', 'Ranks 4-10', 'Ranks 11-20', 'Ranks 21-50', 'Total Keywords']);
                        
                        Object.values(data).forEach((domainData) => {
                            const sm = domainData.siteMetrics?.data?.site_metrics || {};
                            const ba = domainData.brandAuthority?.data?.site_metrics?.brand_authority_score ?? 'N/A';
                            const da = sm.domain_authority ?? 'N/A';
                            const links = sm.external_pages_to_root_domain ?? 'N/A';
                            const linkingDomains = sm.root_domains_to_root_domain ?? 'N/A';
                            const spam = sm.spam_score ?? 'N/A';
                            
                            const kc = domainData.keywordCount?.data?.ranking_keyword_count;
                            const positions = kc?.position || {};
                            const rank1_3 = (positions.rank_1 || 0) + (positions.rank_2 || 0) + (positions.rank_3 || 0);
                            const rank4_10 = [4,5,6,7,8,9,10].reduce((sum, r) => sum + (positions[`rank_${r}`] || 0), 0);
                            const rank11_20 = [11,12,13,14,15,16,17,18,19,20].reduce((sum, r) => sum + (positions[`rank_${r}`] || 0), 0);
                            const rank21_50 = [21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50].reduce((sum, r) => sum + (positions[`rank_${r}`] || 0), 0);
                            
                            const domainName = domainData.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0];
                            metricsData.push([
                                domainName,
                                ba,
                                da,
                                typeof links === 'number' ? links : links,
                                typeof linkingDomains === 'number' ? linkingDomains : linkingDomains,
                                spam,
                                rank1_3,
                                rank4_10,
                                rank11_20,
                                rank21_50,
                                kc?.total || 0
                            ]);
                        });
                        
                        const metricsSheet = XLSX.utils.aoa_to_sheet(metricsData);
                        XLSX.utils.book_append_sheet(workbook, metricsSheet, 'Domain Metrics');
                        
                        // Sheet 2: Ranking Keywords (one per domain)
                        Object.values(data).forEach((domainData, idx) => {
                            const keywords = domainData.rankingKeywords?.data?.ranking_keywords || [];
                            const domainName = domainData.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0];
                            const sheetName = idx === 0 ? 'Your Domain Keywords' : `${domainName} Keywords`;
                            
                            const keywordsData = [['Keyword', 'Rank', 'Page', 'Difficulty', 'Volume']];
                            keywords.forEach(kw => {
                                keywordsData.push([
                                    kw.keyword || 'N/A',
                                    kw.rank_position ?? 'N/A',
                                    kw.ranking_page || 'N/A',
                                    kw.difficulty ?? 'N/A',
                                    kw.volume || 'N/A'
                                ]);
                            });
                            
                            const keywordsSheet = XLSX.utils.aoa_to_sheet(keywordsData);
                            XLSX.utils.book_append_sheet(workbook, keywordsSheet, sheetName.substring(0, 31)); // Excel sheet name limit
                        });
                        
                        // Sheet 3: Overlapping Keywords
                        const domainKeywords = {};
                        Object.values(data).forEach((domainData) => {
                            const keywords = domainData.rankingKeywords?.data?.ranking_keywords || [];
                            const domainName = domainData.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0];
                            domainKeywords[domainName] = keywords.map(kw => kw.keyword?.toLowerCase()).filter(Boolean);
                        });
                        
                        const domainNames = Object.keys(domainKeywords);
                        if (domainNames.length > 1) {
                            const keywordToDomains = {};
                            domainNames.forEach(domain => {
                                domainKeywords[domain].forEach(keyword => {
                                    if (!keywordToDomains[keyword]) {
                                    keywordToDomains[keyword] = [];
                                }
                                    if (!keywordToDomains[keyword].includes(domain)) {
                                        keywordToDomains[keyword].push(domain);
                                    }
                                });
                            });
                            
                            const overlappingKeywords = Object.entries(keywordToDomains)
                                .filter(([keyword, domains]) => domains.length > 1)
                                .map(([keyword, domains]) => {
                                    const keywordData = {};
                                    domainNames.forEach(domain => {
                                        const domainEntry = Object.values(data).find(d => {
                                            const dName = d.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0];
                                            return dName === domain;
                                        });
                                        const kwData = domainEntry?.rankingKeywords?.data?.ranking_keywords?.find(k => k.keyword?.toLowerCase() === keyword);
                                        if (kwData) {
                                            keywordData[domain] = { rank: kwData.rank_position };
                                        }
                                    });
                                    return { keyword, domains, data: keywordData };
                                })
                                .sort((a, b) => b.domains.length - a.domains.length || a.keyword.localeCompare(b.keyword));
                            
                            if (overlappingKeywords.length > 0) {
                                const overlapData = [['Keyword', 'Shared By', ...domainNames]];
                                overlappingKeywords.forEach(overlap => {
                                    const row = [overlap.keyword, `${overlap.domains.length} domains`];
                                    domainNames.forEach(domain => {
                                        const kwData = overlap.data[domain];
                                        row.push(kwData ? kwData.rank : 'Not ranking');
                                    });
                                    overlapData.push(row);
                                });
                                
                                const overlapSheet = XLSX.utils.aoa_to_sheet(overlapData);
                                XLSX.utils.book_append_sheet(workbook, overlapSheet, 'Overlapping Keywords');
                            }
                        }
                        
                        // Sheet 4: Keyword Gap Snapshot
                        const yourDomainData = Object.values(data)[0];
                        const yourKeywords = new Set((yourDomainData.rankingKeywords?.data?.ranking_keywords || []).map(kw => kw.keyword?.toLowerCase()).filter(Boolean));
                        
                        const gapKeywords = [];
                        Object.values(data).slice(1).forEach((competitorData) => {
                            const competitorKeywords = competitorData.rankingKeywords?.data?.ranking_keywords || [];
                            competitorKeywords.forEach(kw => {
                                const kwLower = kw.keyword?.toLowerCase();
                                if (kwLower && !yourKeywords.has(kwLower) && kw.volume) {
                                    gapKeywords.push({
                                        keyword: kw.keyword,
                                        volume: kw.volume || 0,
                                        difficulty: kw.difficulty,
                                        competitor: competitorData.domain.replace(/^https?:\/\//, '').replace(/\/$/, '').split('/')[0]
                                    });
                                }
                            });
                        });
                        
                        const uniqueGapKeywords = [];
                        const seenKeywords = new Set();
                        gapKeywords.forEach(kw => {
                            if (!seenKeywords.has(kw.keyword.toLowerCase())) {
                                seenKeywords.add(kw.keyword.toLowerCase());
                                uniqueGapKeywords.push(kw);
                            }
                        });
                        uniqueGapKeywords.sort((a, b) => (b.volume || 0) - (a.volume || 0));
                        
                        if (uniqueGapKeywords.length > 0) {
                            const gapData = [['Keyword', 'Volume', 'Difficulty', 'Competitor']];
                            uniqueGapKeywords.forEach(kw => {
                                gapData.push([kw.keyword, kw.volume || 'N/A', kw.difficulty ?? 'N/A', kw.competitor]);
                            });
                            
                            const gapSheet = XLSX.utils.aoa_to_sheet(gapData);
                            XLSX.utils.book_append_sheet(workbook, gapSheet, 'Keyword Gap Opportunities');
                        }
                        
                        // Export the workbook
                        const dateStr = new Date().toISOString().split('T')[0];
                        XLSX.writeFile(workbook, `competitive-analysis-${dateStr}.xlsx`);
                    } catch (error) {
                        console.error('Excel export error:', error);
                        displayError('Failed to export Excel file. Please try again.');
                    }
                };
                script.onerror = () => {
                    displayError('Failed to load Excel export library. Please try again.');
                };
                document.head.appendChild(script);
            }

            function exportKeywordTargetingToCsv(data) {
                // Load SheetJS library dynamically
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                script.onload = () => {
                    try {
                        const workbook = XLSX.utils.book_new();
                        const { urls = [], resultsByUrl = {}, overlaps = [] } = data || {};

                        // Sheet 1: Page Metrics
                        const metrics = [['URL Index','URL','Linking Domains','Inbound Links','Page Authority']];
                        urls.forEach((u, idx) => {
                            const sm = resultsByUrl[u]?.siteMetrics?.data?.site_metrics || {};
                            metrics.push([
                                idx + 1,
                                u,
                                sm.root_domains_to_page ?? 'N/A',
                                sm.external_pages_to_page ?? 'N/A',
                                sm.page_authority ?? 'N/A'
                            ]);
                        });
                        XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(metrics), 'Page Metrics');

                        // Sheets: Ranking Keywords per URL
                        urls.forEach((u, idx) => {
                            const res = resultsByUrl[u] || {};
                            const arr = Array.isArray(res.rankingKeywords)
                                ? res.rankingKeywords
                                : (res.rankingKeywords && res.rankingKeywords.data && Array.isArray(res.rankingKeywords.data.ranking_keywords)
                                    ? res.rankingKeywords.data.ranking_keywords
                                    : []);
                            const rows = [['Keyword','Intent','Rank','Page','Difficulty','Volume']];
                            arr.forEach(kw => {
                                const intent = (res.searchIntent && (res.searchIntent[kw.keyword] || res.searchIntent[(kw.keyword || '').toLowerCase()])) || 'Unknown';
                                rows.push([
                                    kw.keyword || 'N/A',
                                    intent,
                                    kw.rank_position ?? 'N/A',
                                    kw.ranking_page || 'N/A',
                                    kw.difficulty ?? 'N/A',
                                    kw.volume ?? 'N/A'
                                ]);
                            });
                            const sheetName = `URL ${idx + 1} Keywords`.substring(0,31);
                            XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(rows), sheetName);
                        });

                        // Sheet: Overlapping Keywords
                        if (overlaps && overlaps.length > 0) {
                            const header = ['Keyword','Shared By', ...urls.map((_, i) => `URL ${i+1} Rank`)];
                            const rows = [header];
                            overlaps.forEach(row => {
                                const r = [row.keyword, `${row.urls.length} URLs`];
                                urls.forEach(u => {
                                    const d = row.data[u];
                                    r.push(d ? (d.rank ?? 'N/A') : 'Not ranking');
                                });
                                rows.push(r);
                            });
                            XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(rows), 'Overlapping Keywords');
                        }

                        // Sheet: Anchors
                        const anchorRows = [['URL Index','URL','Anchor Text','External Root Domains','External Pages']];
                        urls.forEach((u, idx) => {
                            const anchors = resultsByUrl[u]?.topAnchors || [];
                            anchors.forEach(a => {
                                anchorRows.push([
                                    idx + 1,
                                    u,
                                    a.text || 'N/A',
                                    a.external_root_domains ?? 'N/A',
                                    a.external_pages ?? 'N/A'
                                ]);
                            });
                        });
                        XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(anchorRows), 'Anchors');

                        // Export the workbook
                        const dateStr = new Date().toISOString().split('T')[0];
                        XLSX.writeFile(workbook, `keyword-targeting-${dateStr}.xlsx`);
                    } catch (error) {
                        console.error('Excel export error:', error);
                        displayError('Failed to export Excel file. Please try again.');
                    }
                };
                script.onerror = () => {
                    displayError('Failed to load Excel export library. Please try again.');
                };
                document.head.appendChild(script);
            }

            function exportContentClusterAnalysisToCsv(data) {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                script.onload = () => {
                    try {
                        const workbook = XLSX.utils.book_new();
                        const { seedTopic, urls = [], resultsByUrl = {}, seedTopicSimilarities = {}, intentGroups = {}, consolidationClusters = [], mainTopicPage, relatedKeywords = [] } = data || {};

                        // Sheet 1: Summary
                        const summary = [
                            ['Seed Topic', seedTopic],
                            ['Similarity Threshold', data.similarityThreshold || 'N/A'],
                            ['Total URLs', urls.length],
                            ['Main Topic Page', mainTopicPage || 'N/A'],
                            ['Consolidation Clusters', consolidationClusters.length],
                            ['Related Keywords Found', relatedKeywords.length]
                        ];
                        XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(summary), 'Summary');

                        // Sheet 2: Seed Topic Similarity
                        const simRows = [['Rank', 'URL', 'Similarity Score', 'Value Score', 'Primary Intent', 'Ranking Keywords', 'Linking Domains', 'Inbound Links', 'Page Authority']];
                        const sortedUrls = [...urls].sort((a, b) => (seedTopicSimilarities[b] || 0) - (seedTopicSimilarities[a] || 0));
                        sortedUrls.forEach((u, idx) => {
                            const metrics = resultsByUrl[u]?.mozMetrics || {};
                            simRows.push([
                                idx + 1,
                                u,
                                seedTopicSimilarities[u] || 0,
                                resultsByUrl[u]?.valueScore || 0,
                                resultsByUrl[u]?.primaryIntent || 'Other',
                                metrics.rankingKeywordsCount || 0,
                                metrics.linkingDomains || 0,
                                metrics.inboundLinks || 0,
                                metrics.pageAuthority || 0
                            ]);
                        });
                        XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(simRows), 'Seed Topic Similarity');

                        // Sheet 3: Intent Groups
                        const intentRows = [['Intent', 'URL', 'Similarity Score', 'Value Score']];
                        Object.entries(intentGroups).forEach(([intent, groupUrls]) => {
                            groupUrls.forEach(u => {
                                intentRows.push([
                                    intent,
                                    u,
                                    seedTopicSimilarities[u] || 0,
                                    resultsByUrl[u]?.valueScore || 0
                                ]);
                            });
                        });
                        XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(intentRows), 'Intent Groups');

                        // Sheet 4: Consolidation Clusters
                        const clusterRows = [['Cluster', 'Intent', 'URL', 'Ranking Keywords', 'Linking Domains', 'Inbound Links', 'Page Authority', 'Value Score']];
                        consolidationClusters.forEach((cluster, idx) => {
                            cluster.urls.forEach(u => {
                                const metrics = resultsByUrl[u]?.mozMetrics || {};
                                clusterRows.push([
                                    `Cluster ${idx + 1}`,
                                    cluster.intent,
                                    u,
                                    metrics.rankingKeywordsCount || 0,
                                    metrics.linkingDomains || 0,
                                    metrics.inboundLinks || 0,
                                    metrics.pageAuthority || 0,
                                    resultsByUrl[u]?.valueScore || 0
                                ]);
                            });
                        });
                        XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(clusterRows), 'Consolidation Clusters');

                        // Sheet 5: Related Keywords
                        if (relatedKeywords.length > 0) {
                            const rkRows = [['Related Keyword']];
                            relatedKeywords.forEach(kw => {
                                rkRows.push([kw]);
                            });
                            XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(rkRows), 'Related Keywords');
                        }

                        // Sheets: Ranking Keywords per URL
                        urls.forEach((u, idx) => {
                            const res = resultsByUrl[u] || {};
                            const arr = Array.isArray(res.rankingKeywords)
                                ? res.rankingKeywords
                                : [];
                            const rows = [['Keyword','Intent','Rank','Page','Difficulty','Volume']];
                            arr.forEach(kw => {
                                const intent = (res.searchIntent && (res.searchIntent[kw.keyword] || res.searchIntent[(kw.keyword || '').toLowerCase()])) || 'Unknown';
                                rows.push([
                                    kw.keyword || 'N/A',
                                    intent,
                                    kw.rank_position ?? 'N/A',
                                    kw.ranking_page || 'N/A',
                                    kw.difficulty ?? 'N/A',
                                    kw.volume ?? 'N/A'
                                ]);
                            });
                            const sheetName = `URL ${idx + 1} Keywords`.substring(0,31);
                            XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(rows), sheetName);
                        });

                        // Export the workbook
                        const dateStr = new Date().toISOString().split('T')[0];
                        XLSX.writeFile(workbook, `content-cluster-analysis-${dateStr}.xlsx`);
                    } catch (error) {
                        console.error('Excel export error:', error);
                        displayError('Failed to export Excel file. Please try again.');
                    }
                };
                script.onerror = () => {
                    displayError('Failed to load Excel export library. Please try again.');
                };
                document.head.appendChild(script);
            }

            function exportContentClustersIdentificationToCsv(data) {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                script.onload = () => {
                    try {
                        const workbook = XLSX.utils.book_new();
                        const { urls = [], scope, contentClusters, resultsByUrl = {}, clusterLabels = [], clusters = [] } = data || {};

                        // Sheet 1: Summary
                        const summary = [
                            ['Scope', scope || 'N/A'],
                            ['Total URLs', urls.length],
                            ['Clusters Found', clusters.length],
                            ['User-Defined Clusters', contentClusters && contentClusters.length > 0 ? contentClusters.join(', ') : 'Auto-generated'],
                            ['Successfully Analyzed', urls.filter(url => !resultsByUrl[url]?.errors?.length || resultsByUrl[url]?.errors?.length === 0).length],
                            ['With Errors', urls.filter(url => resultsByUrl[url]?.errors?.length > 0).length]
                        ];
                        XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(summary), 'Summary');

                        // Sheet 2: Page Analysis Results
                        const pageRows = [['URL', 'LLM-Defined Topic', 'Content Cluster', 'Primary Intent', 'Audience', 'Expertise Level', 'Topic Tags']];
                        urls.forEach(url => {
                            const result = resultsByUrl[url];
                            if (result) {
                                pageRows.push([
                                    url,
                                    result.llmDefinedTopic || 'N/A',
                                    result.contentCluster || 'Unassigned',
                                    result.primaryIntent || 'N/A',
                                    result.audience || 'N/A',
                                    result.expertiseLevel || 'N/A',
                                    result.topicTags && result.topicTags.length > 0 ? result.topicTags.join(', ') : 'N/A'
                                ]);
                            }
                        });
                        XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(pageRows), 'Page Analysis');

                        // Sheet 3: Clusters
                        const clusterRows = [['Cluster Name', 'Description', 'URLs Count', 'Dominant Intent', 'Topic Tags', 'Funnel Stages']];
                        clusters.forEach((cluster, idx) => {
                            const label = clusterLabels.find(cl => cl.clusterIndex === idx);
                            clusterRows.push([
                                label?.clusterName || `Cluster ${idx + 1}`,
                                label?.description || 'N/A',
                                cluster.urls.length,
                                label?.dominantIntent || 'N/A',
                                label?.topicTags && label.topicTags.length > 0 ? label.topicTags.join(', ') : 'N/A',
                                label?.funnelStages && label.funnelStages.length > 0 ? label.funnelStages.join(', ') : 'N/A'
                            ]);
                        });
                        XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(clusterRows), 'Clusters');

                        // Sheet 4: Cluster URLs Mapping
                        const clusterUrlRows = [['Cluster Name', 'URL']];
                        clusters.forEach((cluster, idx) => {
                            const label = clusterLabels.find(cl => cl.clusterIndex === idx);
                            const clusterName = label?.clusterName || `Cluster ${idx + 1}`;
                            cluster.urls.forEach(url => {
                                clusterUrlRows.push([clusterName, url]);
                            });
                        });
                        XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(clusterUrlRows), 'Cluster URLs');

                        // Sheet 5: Errors (if any)
                        const urlsWithErrors = urls.filter(url => resultsByUrl[url]?.errors?.length > 0);
                        if (urlsWithErrors.length > 0) {
                            const errorRows = [['URL', 'Errors']];
                            urlsWithErrors.forEach(url => {
                                errorRows.push([
                                    url,
                                    resultsByUrl[url].errors.join('; ')
                                ]);
                            });
                            XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(errorRows), 'Errors');
                        }

                        const dateStr = new Date().toISOString().split('T')[0];
                        XLSX.writeFile(workbook, `content-clusters-identification-${dateStr}.xlsx`);
                    } catch (error) {
                        console.error('Export error:', error);
                        displayError('Failed to export to Excel. Please try again.');
                    }
                };
                script.onerror = () => {
                    displayError('Failed to load Excel export library. Please try again.');
                };
                document.head.appendChild(script);
            }

            function toggleDataView() {
                // Handle multi-endpoint dashboards specially
                if (currentMethod === 'competitiveAnalysis' || currentMethod === 'keywordTargetingAnalysis' || currentMethod === 'contentClusterAnalysis' || currentMethod === 'contentClustersIdentification') {
                    const dashboard = document.getElementById('competitive-dashboard');
                    const altDashboard = document.getElementById('keyword-targeting-dashboard');
                    const ccaDashboard = document.getElementById('content-cluster-dashboard');
                    const cciDashboard = document.getElementById('content-clusters-identification-dashboard');
                    const activeDash = dashboard || altDashboard || ccaDashboard || cciDashboard;
                    const isDashboardVisible = activeDash && !activeDash.closest('.hidden');
                    
                    if (isDashboardVisible) {
                        // Switch to JSON view
                        activeDash.parentElement.innerHTML = '<pre class="whitespace-pre-wrap break-all text-sm bg-[var(--bg-code)] text-[var(--text-primary)] p-4 rounded-lg" role="region" aria-label="Raw JSON data"><code></code></pre>';
                        const codeEl = allDOMElements.rawWrapper.querySelector('code');
                        if (codeEl) codeEl.textContent = JSON.stringify(currentResultsData, null, 2);
                        allDOMElements.viewDataBtn.textContent = 'View Dashboard';
                        allDOMElements.rawWrapper.classList.remove('hidden');
                        allDOMElements.exportPdfBtn.classList.add('hidden');
                    } else {
                        // Switch back to dashboard
                        if (currentMethod === 'competitiveAnalysis') {
                            showCompetitiveDashboard(currentResultsData);
                        } else if (currentMethod === 'keywordTargetingAnalysis') {
                            showKeywordTargetingDashboard(currentResultsData);
                        } else if (currentMethod === 'contentClusterAnalysis') {
                            showContentClusterDashboard(currentResultsData);
                        } else if (currentMethod === 'contentClustersIdentification') {
                            showContentClustersIdentificationDashboard(currentResultsData);
                        }
                        allDOMElements.viewDataBtn.textContent = 'View JSON';
                        allDOMElements.exportPdfBtn.classList.add('hidden');
                    }
                    return;
                }
                
                // Regular view toggle
                const isTableVisible = !allDOMElements.tableWrapper.classList.contains('hidden');
                if (isTableVisible) {
                    allDOMElements.tableWrapper.classList.add('hidden');
                    allDOMElements.rawWrapper.classList.remove('hidden');
                    allDOMElements.viewDataBtn.textContent = 'View Table';
                    allDOMElements.filterBtn.classList.add('hidden');
                    allDOMElements.exportPdfBtn.classList.add('hidden');
                } else {
                    allDOMElements.rawWrapper.classList.add('hidden');
                    allDOMElements.tableWrapper.classList.remove('hidden');
                    allDOMElements.viewDataBtn.textContent = 'View JSON';
                    allDOMElements.filterBtn.classList.remove('hidden');
                    allDOMElements.exportPdfBtn.classList.add('hidden');
                    renderTable(currentResultsData, currentMethod, currentOriginalParams);
                }
            }
            
            function showRawJsonResults(data) {
                // Don't override dashboards for multi-endpoint views
                if (currentMethod === 'competitiveAnalysis' || currentMethod === 'keywordTargetingAnalysis' || currentMethod === 'contentClusterAnalysis' || currentMethod === 'contentClustersIdentification') {
                    return;
                }
                
                // Clear any existing dashboard
                const dashboard = document.getElementById('competitive-dashboard');
                const ktaDashboard = document.getElementById('keyword-targeting-dashboard');
                const ccaDashboard = document.getElementById('content-cluster-dashboard');
                if (dashboard) dashboard.remove();
                if (ktaDashboard) ktaDashboard.remove();
                if (ccaDashboard) ccaDashboard.remove();
                
                // Reset "Reset" button back to "Clear Data" if it was changed
                if (allDOMElements.clearDataBtn && allDOMElements.clearDataBtn.dataset.originalText) {
                    allDOMElements.clearDataBtn.textContent = allDOMElements.clearDataBtn.dataset.originalText;
                    delete allDOMElements.clearDataBtn.dataset.originalText;
                }
                
                // Set up JSON view (hidden by default) - defer stringification
                allDOMElements.rawWrapper.innerHTML = '<pre class="whitespace-pre-wrap break-all text-sm bg-[var(--bg-code)] text-[var(--text-primary)] p-4 rounded-lg" role="region" aria-label="Raw JSON data"><code></code></pre>';
                allDOMElements.rawCode = document.querySelector('#raw-wrapper code');
                // Defer JSON stringification (non-critical, only needed when viewing JSON)
                if (allDOMElements.rawCode) {
                    const stringifyJson = () => {
                        if (allDOMElements.rawCode) {
                            allDOMElements.rawCode.textContent = JSON.stringify(data, null, 2);
                        }
                    };
                    if (window.requestIdleCallback) {
                        requestIdleCallback(stringifyJson, { timeout: 2000 });
                    } else {
                        setTimeout(stringifyJson, 0);
                    }
                }
                
                // Show table container immediately for better perceived performance
                allDOMElements.resultsContainer.classList.remove('hidden');
                allDOMElements.rawWrapper.classList.add('hidden');
                allDOMElements.tableWrapper.classList.remove('hidden');
                allDOMElements.viewDataBtn.textContent = 'View JSON';
                allDOMElements.exportPdfBtn.classList.add('hidden');
                
                // Render table (now optimized with deferred processing)
                renderTable(data, currentMethod, currentOriginalParams);
            }

            function clearResultsData() {
                currentResultsData = null;
                currentOriginalParams = null;
                currentMethod = null;
                currentFilters = [];
                if (table) {
                    table.destroy();
                    table = null;
                }
                
                // Clear any dashboards
                const compDash = document.getElementById('competitive-dashboard');
                if (compDash) compDash.remove();
                const ktaDash = document.getElementById('keyword-targeting-dashboard');
                if (ktaDash) ktaDash.remove();
                
                // Reset "Reset" button back to "Clear Data" if it was changed
                if (allDOMElements.clearDataBtn && allDOMElements.clearDataBtn.dataset.originalText) {
                    allDOMElements.clearDataBtn.textContent = allDOMElements.clearDataBtn.dataset.originalText;
                    delete allDOMElements.clearDataBtn.dataset.originalText;
                }
                
                // Reset rawWrapper to default structure
                allDOMElements.rawWrapper.innerHTML = '<pre class="whitespace-pre-wrap break-all text-sm bg-[var(--bg-code)] text-[var(--text-primary)] p-4 rounded-lg" role="region" aria-label="Raw JSON data"><code></code></pre>';
                allDOMElements.rawCode = document.querySelector('#raw-wrapper code');
                allDOMElements.rawCode.textContent = '';
                
                allDOMElements.resultsContainer.classList.add('hidden');
                allDOMElements.tableWrapper.classList.add('hidden');
                allDOMElements.rawWrapper.classList.add('hidden');
                allDOMElements.filterBtn.classList.add('hidden');
                allDOMElements.exportPdfBtn.classList.add('hidden');
                allDOMElements.activeFiltersContainer.classList.add('hidden');
                allDOMElements.activeFiltersContainer.innerHTML = '';
            }

            // History Management Functions

            function autoSaveToHistory() {
                if (currentMethod && currentOriginalParams && currentResultsData) {
                    // Calculate result count based on data type
                    let resultCount = 0;
                    if (Array.isArray(currentResultsData)) {
                        resultCount = currentResultsData.length;
                    } else if (currentMethod === 'contentClusterAnalysis' && currentResultsData.urls) {
                        resultCount = currentResultsData.urls.length;
                    } else if (currentMethod === 'contentClustersIdentification' && currentResultsData.urls) {
                        resultCount = currentResultsData.urls.length;
                    } else if (currentMethod === 'competitiveAnalysis' && typeof currentResultsData === 'object') {
                        resultCount = Object.keys(currentResultsData).length;
                    } else if (currentMethod === 'keywordTargetingAnalysis' && currentResultsData.urls) {
                        resultCount = currentResultsData.urls.length;
                    } else if (typeof currentResultsData === 'object') {
                        resultCount = Object.keys(currentResultsData).length;
                    }

                    const historyEntry = {
                        id: Date.now(),
                        timestamp: new Date().toISOString(),
                        method: currentMethod,
                        params: { ...currentOriginalParams },
                        resultCount: resultCount,
                        success: true
                    };

                    const history = getSearchHistory();
                    history.unshift(historyEntry);
                    
                    // Keep only last 50 auto-saved entries
                    if (history.length > 50) {
                        history.splice(50);
                    }

                    saveSearchHistory(history);
                }
            }

            function getSearchHistory() {
                try {
                    const history = localStorage.getItem('mozSearchHistory');
                    return history ? JSON.parse(history) : [];
                } catch (e) {
                    console.warn('Could not load search history:', e);
                    return [];
                }
            }

            function saveSearchHistory(history) {
                try {
                    localStorage.setItem('mozSearchHistory', JSON.stringify(history));
                } catch (e) {
                    console.warn('Could not save search history:', e);
                    displayError('Could not save search history. Storage may be full.');
                }
            }

            function renderHistoryList(history = null) {
                const searchHistory = history || getSearchHistory();
                const searchTerm = allDOMElements.historySearch.value.toLowerCase();
                
                const filteredHistory = searchTerm 
                    ? searchHistory.filter(entry => 
                        entry.method.toLowerCase().includes(searchTerm) ||
                        JSON.stringify(entry.params).toLowerCase().includes(searchTerm) ||
                        new Date(entry.timestamp).toLocaleDateString().includes(searchTerm)
                      )
                    : searchHistory;

                if (filteredHistory.length === 0) {
                    allDOMElements.historyEmpty.classList.remove('hidden');
                    allDOMElements.historyList.innerHTML = '';
                    allDOMElements.historyList.appendChild(allDOMElements.historyEmpty);
                    return;
                }

                allDOMElements.historyEmpty.classList.add('hidden');
                allDOMElements.historyList.innerHTML = '';

                filteredHistory.forEach(entry => {
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'border border-[var(--border-primary)] rounded-lg p-4 mb-3 hover:bg-[var(--bg-input)] transition-colors';
                    
                    const methodName = entry.method.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                    const date = new Date(entry.timestamp).toLocaleString();
                    const paramsSummary = Object.entries(entry.params)
                        .filter(([key, value]) => {
                            if (value === null || value === undefined) return false;
                            if (Array.isArray(value)) return value.length > 0;
                            if (typeof value === 'string') return value.length > 0;
                            if (typeof value === 'number') return true;
                            return true;
                        })
                        .map(([key, value]) => {
                            if (Array.isArray(value)) {
                                // For URLs arrays, show count and first few
                                if (key === 'urls' && value.length > 3) {
                                    return `${key}: ${value.length} URLs (${value.slice(0, 2).join(', ')}...)`;
                                }
                                return `${key}: ${value.join(', ')}`;
                            }
                            return `${key}: ${value}`;
                        })
                        .join(' | ');

                    entryDiv.innerHTML = `
                        <div class="flex justify-between items-start mb-2">
                            <h3 class="font-semibold text-[var(--text-primary)]">${methodName}</h3>
                            <div class="flex items-center gap-2">
                                <span class="text-sm text-[var(--text-secondary)]">${date}</span>
                                <button class="text-[var(--text-accent)] hover:text-[var(--text-accent-hover)] text-sm" data-replay="${entry.id}">Replay</button>
                                <button class="text-[var(--text-accent)] hover:text-[var(--text-accent-hover)] text-sm" data-edit="${entry.id}">Edit</button>
                                <button class="text-[var(--text-error)] hover:text-red-600 text-sm" data-delete="${entry.id}">Delete</button>
                            </div>
                        </div>
                        <p class="text-sm text-[var(--text-secondary)] mb-2">${paramsSummary}</p>
                        <div class="flex items-center gap-4 text-xs text-[var(--text-secondary)]">
                            <span>Results: ${entry.resultCount}</span>
                            <span>Status: ${entry.success ? 'Success' : 'Failed'}</span>
                        </div>
                    `;

                    allDOMElements.historyList.appendChild(entryDiv);
                });
            }

            function filterHistory() {
                renderHistoryList();
            }

            function replaySearch(entryId) {
                const history = getSearchHistory();
                const entry = history.find(h => h.id.toString() === entryId);
                
                if (!entry) {
                    displayError('Search entry not found.');
                    return;
                }

                // Set the method
                allDOMElements.methodSelector.value = entry.method;
                allDOMElements.methodSelector.dispatchEvent(new Event('change'));

                // Populate form fields
                setTimeout(() => {
                    Object.entries(entry.params).forEach(([key, value]) => {
                        // Map parameter names to field IDs
                        const fieldId = getFieldIdForParam(entry.method, key);
                        const element = document.getElementById(fieldId);
                        
                        if (element) {
                            if (element.type === 'checkbox') {
                                element.checked = value;
                            } else if (Array.isArray(value)) {
                                // For competitive analysis competitors array, content cluster URLs, or any array value
                                if (entry.method === 'contentClusterAnalysis' && key === 'urls') {
                                    element.value = value.join('\n');
                                } else {
                                    element.value = value.join('\n');
                                }
                            } else if (element.type === 'select-one' || element.type === 'select-multiple') {
                                if (Array.isArray(value)) {
                                    // For multi-select
                                    Array.from(element.options).forEach(option => {
                                        option.selected = value.includes(option.value);
                                    });
                                } else {
                                    element.value = value;
                                }
                            } else {
                                element.value = value;
                            }
                        }
                    });
                    
                    // Auto-submit for dashboard methods
                    if (entry.method === 'contentClusterAnalysis' || entry.method === 'competitiveAnalysis' || entry.method === 'keywordTargetingAnalysis') {
                        setTimeout(() => {
                            allDOMElements.form.dispatchEvent(new Event('submit'));
                        }, 200);
                    }
                }, 100);

                allDOMElements.historyModal.classList.add('hidden');
            }

            function editSearch(entryId) {
                const history = getSearchHistory();
                const entry = history.find(h => h.id.toString() === entryId);
                
                if (!entry) {
                    displayError('Search entry not found.');
                    return;
                }

                // Set the method
                allDOMElements.methodSelector.value = entry.method;
                allDOMElements.methodSelector.dispatchEvent(new Event('change'));

                // Populate form fields (same as replay, but don't auto-submit)
                setTimeout(() => {
                    Object.entries(entry.params).forEach(([key, value]) => {
                        // Map parameter names to field IDs
                        const fieldId = getFieldIdForParam(entry.method, key);
                        const element = document.getElementById(fieldId);
                        
                        if (element) {
                            if (element.type === 'checkbox') {
                                element.checked = value;
                            } else if (Array.isArray(value)) {
                                // For competitive analysis competitors array, content cluster URLs, or any array value
                                if (entry.method === 'contentClusterAnalysis' && key === 'urls') {
                                    element.value = value.join('\n');
                                } else {
                                    element.value = value.join('\n');
                                }
                            } else if (element.type === 'select-one' || element.type === 'select-multiple') {
                                if (Array.isArray(value)) {
                                    // For multi-select
                                    Array.from(element.options).forEach(option => {
                                        option.selected = value.includes(option.value);
                                    });
                                } else {
                                    element.value = value;
                                }
                            } else {
                                element.value = value;
                            }
                        }
                    });
                    // Don't auto-submit - let user edit and submit manually
                }, 100);

                allDOMElements.historyModal.classList.add('hidden');
            }

            // Map parameter names to field IDs
            function getFieldIdForParam(method, paramName) {
                const mappings = {
                    'siteMetrics': {
                        'scope': 'smScopeSelect',
                        'urls': 'smUrlsInput'
                    },
                    'keywordMetrics': {
                        'metricType': 'kmMetricTypeSelect',
                        'device': 'kmDeviceSelect',
                        'engine': 'kmEngineSelect',
                        'locale': 'kmLocaleSelect',
                        'keywords': 'kmKeywordsInput'
                    },
                    'brandAuthority': {
                        'urls': 'baUrlsInput'
                    },
                    'searchIntent': {
                        'locale': 'siLocaleSelect',
                        'keywords': 'siKeywordsInput'
                    },
                    'rankingKeywords': {
                        'scope': 'rkScopeSelect',
                        'locale': 'rkLocaleSelect',
                        'limit': 'rkLimit',
                        'urls': 'rkUrlsInput'
                    },
                    'relatedKeywords': {
                        'locale': 'rlLocaleSelect',
                        'keywords': 'rlKeywordsInput'
                    },
                    'keywordCount': {
                        'scope': 'kcScopeSelect',
                        'locale': 'kcLocaleSelect',
                        'urls': 'kcUrlsInput'
                    },
                    'anchorText': {
                        'scope': 'atScopeSelect',
                        'limit': 'atLimit',
                        'urls': 'atUrlsInput'
                    },
                    'recentlyGainedLinks': {
                        'scope': 'rglScopeSelect',
                        'limit': 'rglLimit',
                        'beginDate': 'rglBeginDate',
                        'endDate': 'rglEndDate',
                        'urls': 'rglUrlsInput'
                    },
                    'recentlyLostLinks': {
                        'scope': 'rllScopeSelect',
                        'limit': 'rllLimit',
                        'beginDate': 'rllBeginDate',
                        'endDate': 'rllEndDate',
                        'urls': 'rllUrlsInput'
                    },
                    'linkingDomains': {
                        'scope': 'ldScopeSelect',
                        'sort': 'ldSortSelect',
                        'filters': 'ldFilterSelect',
                        'limit': 'ldLimit',
                        'urls': 'ldUrlsInput'
                    },
                    'finalRedirect': {
                        'scope': 'frScopeSelect',
                        'urls': 'frUrlsInput'
                    },
                    'topPages': {
                        'scope': 'tpScopeSelect',
                        'filter': 'tpFilterSelect',
                        'sort': 'tpSortSelect',
                        'limit': 'tpLimit',
                        'urls': 'tpUrlsInput'
                    },
                    'linkIntersect': {
                        'scope': 'liScopeSelect',
                        'sort': 'liSortSelect',
                        'minMatch': 'liMinMatch',
                        'limit': 'liLimit',
                        'isLinkingTo': 'liIsLinkingTo',
                        'notLinkingTo': 'liNotLinkingTo'
                    },
                    'listLinks': {
                        'scope': 'llScopeSelect',
                        'sort': 'llSortSelect',
                        'filters': 'llFilterSelect',
                        'limit': 'llLimit',
                        'urls': 'llUrlsInput'
                    },
                    'linkStatus': {
                        'targetScope': 'lsTargetScopeSelect',
                        'targetUrl': 'lsTargetUrl',
                        'sourceScope': 'lsSourceScopeSelect',
                        'sourceUrl': 'lsSourceUrl'
                    },
                    'filterLinksByAnchor': {
                        'scope': 'flaScopeSelect',
                        'anchor': 'flaAnchor',
                        'limit': 'flaLimit',
                        'urls': 'flaUrlsInput'
                    },
                    'filterLinksByDomain': {
                        'scope': 'fldScopeSelect',
                        'domain': 'fldDomain',
                        'limit': 'fldLimit',
                        'urls': 'fldUrlsInput'
                    },
                    'competitiveAnalysis': {
                        'yourDomain': 'caYourDomain',
                        'competitors': 'caCompetitors',
                        'locale': 'caLocaleSelect',
                        'limit': 'caLimit'
                    },
                    'keywordTargetingAnalysis': {
                        'urls': 'ktaUrl',
                        'locale': 'ktaLocaleSelect',
                        'limit': 'ktaLimit'
                    },
                    'contentClusterAnalysis': {
                        'seedTopic': 'ccaSeedTopic',
                        'urls': 'ccaUrls',
                        'locale': 'ccaLocaleSelect',
                        'similarityThreshold': 'ccaSimilarityThreshold',
                        'limit': 'ccaLimit'
                    },
                    'contentClustersIdentification': {
                        'urls': 'cciUrls',
                        'scope': 'cciScopeSelect',
                        'model': 'cciModelSelect',
                        'contentClusters': 'cciContentClusters'
                    }
                };

                return mappings[method]?.[paramName] || paramName;
            }

            function deleteHistoryEntry(entryId) {
                if (confirm('Are you sure you want to delete this search from history?')) {
                    const history = getSearchHistory();
                    const filteredHistory = history.filter(h => h.id.toString() !== entryId);
                    saveSearchHistory(filteredHistory);
                    renderHistoryList();
                }
            }

            function exportHistory() {
                const history = getSearchHistory();
                if (history.length === 0) {
                    displayError('No history to export.');
                    return;
                }

                const dataStr = JSON.stringify(history, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `moz-search-history-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);
            }

            function clearAllHistory() {
                if (confirm('Are you sure you want to clear all search history? This cannot be undone.')) {
                    saveSearchHistory([]);
                    renderHistoryList();
                }
            }

            // ========== SAVED RESULTS FUNCTIONS ==========
            
            function getSavedResults() {
                try {
                    const saved = localStorage.getItem('mozSavedResults');
                    return saved ? JSON.parse(saved) : [];
                } catch (e) {
                    console.warn('Could not load saved results:', e);
                    return [];
                }
            }
            
            function saveSavedResults(savedResults) {
                try {
                    localStorage.setItem('mozSavedResults', JSON.stringify(savedResults));
                } catch (e) {
                    console.warn('Could not save results:', e);
                    if (e.name === 'QuotaExceededError') {
                        displayError('Storage is full. Please delete some saved results or clear browser data.');
                    } else {
                        displayError('Could not save results. Storage may be full.');
                    }
                    return false;
                }
                return true;
            }
            
            function saveCurrentResults() {
                if (!currentMethod || !currentResultsData || !currentOriginalParams) {
                    displayError('No results to save.');
                    return;
                }
                
                // Generate a unique ID and save
                const savedEntry = {
                    id: Date.now(),
                    timestamp: new Date().toISOString(),
                    method: currentMethod,
                    params: { ...currentOriginalParams },
                    results: JSON.parse(JSON.stringify(currentResultsData)), // Deep copy
                    resultCount: Array.isArray(currentResultsData) ? currentResultsData.length : 
                                (currentResultsData.urls ? currentResultsData.urls.length : 
                                (typeof currentResultsData === 'object' ? Object.keys(currentResultsData).length : 0))
                };
                
                const saved = getSavedResults();
                saved.unshift(savedEntry);
                
                // Keep only last 100 saved entries
                if (saved.length > 100) {
                    saved.splice(100);
                }
                
                if (saveSavedResults(saved)) {
                    displaySuccess(`Results saved! You can reload them anytime from the "Saved Results" button.`);
                    renderSavedResultsList();
                }
            }
            
            function renderSavedResultsList(savedResults = null) {
                const saved = savedResults || getSavedResults();
                const searchTerm = allDOMElements.savedResultsSearch.value.toLowerCase();
                
                const filteredSaved = searchTerm 
                    ? saved.filter(entry => 
                        entry.method.toLowerCase().includes(searchTerm) ||
                        JSON.stringify(entry.params).toLowerCase().includes(searchTerm) ||
                        new Date(entry.timestamp).toLocaleDateString().includes(searchTerm)
                      )
                    : saved;
                
                if (filteredSaved.length === 0) {
                    allDOMElements.savedResultsEmpty.classList.remove('hidden');
                    allDOMElements.savedResultsList.innerHTML = '';
                    return;
                }
                
                allDOMElements.savedResultsEmpty.classList.add('hidden');
                allDOMElements.savedResultsList.innerHTML = '';
                
                filteredSaved.forEach(entry => {
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'border border-[var(--border-primary)] rounded-lg p-4 mb-3 hover:bg-[var(--bg-input)] transition-colors';
                    
                    const methodName = entry.method.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                    const date = new Date(entry.timestamp).toLocaleString();
                    const paramsSummary = Object.entries(entry.params)
                        .filter(([key, value]) => {
                            if (value === null || value === undefined) return false;
                            if (Array.isArray(value)) return value.length > 0;
                            if (typeof value === 'string') return value.length > 0;
                            if (typeof value === 'number') return true;
                            return true;
                        })
                        .map(([key, value]) => {
                            if (Array.isArray(value)) {
                                if (key === 'urls' && value.length > 3) {
                                    return `${key}: ${value.length} URLs (${value.slice(0, 2).join(', ')}...)`;
                                }
                                return `${key}: ${value.join(', ')}`;
                            }
                            return `${key}: ${value}`;
                        })
                        .join(' | ');
                    
                    entryDiv.innerHTML = `
                        <div class="flex justify-between items-start mb-2">
                            <h3 class="font-semibold text-[var(--text-primary)]">${methodName}</h3>
                            <div class="flex items-center gap-2">
                                <span class="text-sm text-[var(--text-secondary)]">${date}</span>
                                <button class="text-[var(--btn-export-bg)] hover:text-[var(--btn-export-hover)] text-sm font-semibold" data-load="${entry.id}">Load</button>
                                <button class="text-[var(--text-error)] hover:text-red-600 text-sm" data-delete-saved="${entry.id}">Delete</button>
                            </div>
                        </div>
                        <p class="text-sm text-[var(--text-secondary)] mb-2">${paramsSummary}</p>
                        <div class="flex items-center gap-4 text-xs text-[var(--text-secondary)]">
                            <span>Results: ${entry.resultCount}</span>
                            <span class="text-[var(--btn-export-bg)]">üíæ Saved</span>
                        </div>
                    `;
                    
                    // Add event listeners
                    entryDiv.querySelector(`[data-load="${entry.id}"]`).addEventListener('click', () => loadSavedResults(entry.id));
                    entryDiv.querySelector(`[data-delete-saved="${entry.id}"]`).addEventListener('click', () => deleteSavedResult(entry.id));
                    
                    allDOMElements.savedResultsList.appendChild(entryDiv);
                });
            }
            
            function filterSavedResults() {
                renderSavedResultsList();
            }
            
            function loadSavedResults(entryId) {
                const saved = getSavedResults();
                const entry = saved.find(s => s.id.toString() === entryId.toString());
                
                if (!entry) {
                    displayError('Saved result not found.');
                    return;
                }
                
                // Set current data
                currentMethod = entry.method;
                currentOriginalParams = entry.params;
                currentResultsData = entry.results;
                
                // Display results - handle special dashboard endpoints, otherwise use standard display
                if (currentMethod === 'contentClusterAnalysis') {
                    showContentClusterDashboard(currentResultsData);
                } else if (currentMethod === 'contentClustersIdentification') {
                    showContentClustersIdentificationDashboard(currentResultsData);
                } else if (currentMethod === 'competitiveAnalysis') {
                    showCompetitiveDashboard(currentResultsData);
                } else if (currentMethod === 'keywordTargetingAnalysis') {
                    showKeywordTargetingDashboard(currentResultsData);
                } else {
                    // For all other endpoints, use standard JSON/table view
                    showRawJsonResults(currentResultsData);
                }
                
                // Update save button visibility
                updateSaveButtonVisibility();
                
                // Close modal
                allDOMElements.savedResultsModal.classList.add('hidden');
                
                displaySuccess(`Loaded saved results from ${new Date(entry.timestamp).toLocaleString()}`);
            }
            
            function deleteSavedResult(entryId) {
                if (confirm('Are you sure you want to delete this saved result?')) {
                    const saved = getSavedResults();
                    const filtered = saved.filter(s => s.id.toString() !== entryId.toString());
                    saveSavedResults(filtered);
                    renderSavedResultsList();
                }
            }
            
            function exportSavedResults() {
                const saved = getSavedResults();
                if (saved.length === 0) {
                    displayError('No saved results to export.');
                    return;
                }
                
                const dataStr = JSON.stringify(saved, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `saved-results-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
            
            function clearAllSavedResults() {
                if (confirm('Are you sure you want to delete ALL saved results? This cannot be undone.')) {
                    saveSavedResults([]);
                    renderSavedResultsList();
                    displaySuccess('All saved results cleared.');
                }
            }
            
            function displaySuccess(message) {
                // Create a temporary success message
                const successDiv = document.createElement('div');
                successDiv.className = 'bg-[var(--btn-export-bg)] border-l-4 border-[var(--btn-export-hover)] text-white px-5 py-4 rounded-lg shadow-md flex items-start gap-3 mb-4';
                successDiv.innerHTML = `
                    <span class="text-2xl flex-shrink-0">‚úì</span>
                    <div class="flex-1 font-medium">${message}</div>
                `;
                allDOMElements.errorMessage.parentElement.insertBefore(successDiv, allDOMElements.errorMessage);
                setTimeout(() => successDiv.remove(), 5000);
            }
            
            // Show/hide save button based on method - show for all endpoints when results exist
            function updateSaveButtonVisibility() {
                if (currentMethod && currentResultsData) {
                    allDOMElements.saveResultsBtn.classList.remove('hidden');
                } else {
                    allDOMElements.saveResultsBtn.classList.add('hidden');
                }
            }

            function displayError(message) {
                 const hints = /quota|limit/i.test(message) ? 'You may be out of rows. Check your API Dashboard.' :
                              /unauthorized|401|403/i.test(message) ? 'Invalid API key. Recheck or regenerate in your dashboard.' :
                              /network|abort/i.test(message) ? 'Network hiccup or request was canceled. Try again.' : '';
                const errorContent = allDOMElements.errorMessage.querySelector('.flex-1');
                if (errorContent) {
                    errorContent.innerHTML = `<div class="font-semibold">${message}</div>${hints ? `<div class="text-sm mt-1 opacity-90">${hints}</div>` : ''}`;
                } else {
                    // Fallback - ensure structure exists
                    if (!allDOMElements.errorMessage.querySelector('.flex-1')) {
                        allDOMElements.errorMessage.innerHTML = `<span class="text-2xl flex-shrink-0">‚ö†Ô∏è</span><div class="flex-1 font-medium">${message}${hints ? `<br><span class="text-sm mt-1 opacity-90">${hints}</span>` : ''}</div>`;
                    } else {
                        allDOMElements.errorMessage.innerHTML = `${message}${hints ? `<br><span class="text-[var(--text-secondary)]">${hints}</span>` : ''}`;
                    }
                }
                allDOMElements.errorMessage.classList.remove('hidden');
            }
            
            function resetSubmitButton() {
                allDOMElements.submitBtn.disabled = allDOMElements.methodSelector.value === "";
                allDOMElements.submitBtn.innerHTML = 'Run Request';
                allDOMElements.submitBtn.removeAttribute('aria-busy');
            }

            function buildPayload(apiKey, selectedMethod) {
                let payload = { apiKey, method: selectedMethod, params: {} };
                const getInputValue = (id) => document.getElementById(id)?.value;
                const getCleanedList = (id) => getInputValue(id)?.split(/[\n,]/).map(item => item.trim()).filter(Boolean);
                const getSelectedOptions = (id) => Array.from(document.getElementById(id).selectedOptions).map(({ value }) => value);

                switch (selectedMethod) {
                    case 'siteMetrics': payload.params = { scope: getInputValue('smScopeSelect'), targets: getCleanedList('smUrlsInput') }; break;
                    case 'keywordMetrics': payload.params = { metricType: getInputValue('kmMetricTypeSelect'), device: getInputValue('kmDeviceSelect'), engine: getInputValue('kmEngineSelect'), locale: getInputValue('kmLocaleSelect'), keywords: getCleanedList('kmKeywordsInput') }; break;
                    case 'brandAuthority': payload.params = { targets: getCleanedList('baUrlsInput') }; break;
                    case 'searchIntent': payload.params = { locale: getInputValue('siLocaleSelect'), keywords: getCleanedList('siKeywordsInput') }; break;
                    case 'rankingKeywords': payload.params = { scope: getInputValue('rkScopeSelect'), locale: getInputValue('rkLocaleSelect'), targets: getCleanedList('rkUrlsInput'), limit: parseInt(getInputValue('rkLimit'), 10) || 25 }; break;
                    case 'relatedKeywords': payload.params = { locale: getInputValue('rlLocaleSelect'), keywords: getCleanedList('rlKeywordsInput') }; break;
                    case 'keywordCount': payload.params = { scope: getInputValue('kcScopeSelect'), locale: getInputValue('kcLocaleSelect'), targets: getCleanedList('kcUrlsInput') }; break;
                    case 'anchorText': payload.params = { scope: getInputValue('atScopeSelect'), targets: getCleanedList('atUrlsInput'), limit: parseInt(getInputValue('atLimit'), 10) || 25 }; break;
                    case 'recentlyGainedLinks': payload.params = { scope: getInputValue('rglScopeSelect'), targets: getCleanedList('rglUrlsInput'), limit: parseInt(getInputValue('rglLimit'), 10) || 25, beginDate: getInputValue('rglBeginDate'), endDate: getInputValue('rglEndDate') }; break;
                    case 'recentlyLostLinks': payload.params = { scope: getInputValue('rllScopeSelect'), targets: getCleanedList('rllUrlsInput'), limit: parseInt(getInputValue('rllLimit'), 10) || 25, beginDate: getInputValue('rllBeginDate'), endDate: getInputValue('rllEndDate') }; break;
                    case 'linkingDomains': payload.params = { scope: getInputValue('ldScopeSelect'), targets: getCleanedList('ldUrlsInput'), limit: parseInt(getInputValue('ldLimit'), 10) || 25, sort: getInputValue('ldSortSelect'), filters: getSelectedOptions('ldFilterSelect')}; break;
                    case 'finalRedirect': payload.params = { scope: getInputValue('frScopeSelect'), targets: getCleanedList('frUrlsInput') }; break;
                    case 'topPages': payload.params = { scope: getInputValue('tpScopeSelect'), targets: getCleanedList('tpUrlsInput'), limit: parseInt(getInputValue('tpLimit'), 10) || 25, filter: getInputValue('tpFilterSelect'), sort: getInputValue('tpSortSelect') }; break;
                    case 'linkIntersect': {
                        const intersectScope = getInputValue('liScopeSelect');
                        payload.params = { 
                            scope: intersectScope, 
                            limit: parseInt(getInputValue('liLimit'), 10) || 25, 
                            is_linking_to: getCleanedList('liIsLinkingTo').map(q => ({query: q, scope: intersectScope})), 
                            not_linking_to: getCleanedList('liNotLinkingTo').map(q => ({query: q, scope: intersectScope})), 
                            sort: getInputValue('liSortSelect'), 
                            minimum_matching_targets: parseInt(getInputValue('liMinMatch'), 10) || 1 
                        }; 
                        break;
                    }
                    case 'listLinks': payload.params = { scope: getInputValue('llScopeSelect'), targets: getCleanedList('llUrlsInput'), limit: parseInt(getInputValue('llLimit'), 10) || 25, filters: getSelectedOptions('llFilterSelect'), sort: getInputValue('llSortSelect') }; break;
                    case 'linkStatus': payload.params = { targetScope: getInputValue('lsTargetScopeSelect'), targetQuery: getInputValue('lsTargetUrl'), sourceScope: getInputValue('lsSourceScopeSelect'), sourceQuery: getInputValue('lsSourceUrl') }; break;
                    case 'filterLinksByAnchor': payload.params = { scope: getInputValue('flaScopeSelect'), targets: getCleanedList('flaUrlsInput'), anchorText: getInputValue('flaAnchorText'), limit: parseInt(getInputValue('flaLimit'), 10) || 25, filters: getSelectedOptions('flaFilterSelect'), sort: getInputValue('flaSortSelect') }; break;
                    case 'filterLinksByDomain': payload.params = { targetScope: getInputValue('fldTargetScopeSelect'), targetQueries: getCleanedList('fldTargetUrls'), sourceScope: getInputValue('fldSourceScopeSelect'), sourceQueries: getCleanedList('fldSourceUrls'), limit: parseInt(getInputValue('fldLimit'), 10) || 25, filters: getSelectedOptions('fldFilterSelect')}; break;
                    case 'competitiveAnalysis': {
                        const yourDomain = getInputValue('caYourDomain')?.trim();
                        const competitors = getInputValue('caCompetitors')?.split(/[\n,]/).map(item => item.trim()).filter(Boolean).slice(0, 3);
                        if (!yourDomain) throw new Error('Please enter your domain.');
                        if (!competitors || competitors.length === 0) throw new Error('Please enter at least one competitor domain.');
                        payload.params = { 
                            yourDomain, 
                            competitors, 
                            locale: getInputValue('caLocaleSelect') || 'en-US',
                            limit: parseInt(getInputValue('caLimit'), 10) || 25
                        };
                        break;
                    }
                    case 'keywordTargetingAnalysis': {
                        const urls = getInputValue('ktaUrl')
                            ?.split(/[\n,]/)
                            .map(s => s.trim())
                            .filter(Boolean) || [];
                        if (urls.length === 0) throw new Error('Please enter at least one URL.');
                        payload.params = {
                            urls,
                            locale: getInputValue('ktaLocaleSelect') || 'en-US',
                            limit: parseInt(getInputValue('ktaLimit'), 10) || 25
                        };
                        break;
                    }
                    case 'contentClusterAnalysis': {
                        const seedTopic = getInputValue('ccaSeedTopic')?.trim();
                        const urls = getCleanedList('ccaUrls');
                        const model = getInputValue('ccaModelSelect') || 'gpt-3.5-turbo';
                        if (!seedTopic) throw new Error('Please enter a seed topic.');
                        if (!urls || urls.length === 0) throw new Error('Please enter at least one URL.');
                        payload.params = { 
                            seedTopic,
                            urls,
                            locale: getInputValue('ccaLocaleSelect') || 'en-US',
                            similarityThreshold: parseFloat(getInputValue('ccaSimilarityThreshold')) || 0.85,
                            limit: parseInt(getInputValue('ccaLimit'), 10) || 25,
                            model
                        };
                        break;
                    }
                    case 'contentClustersIdentification': {
                        const urls = getCleanedList('cciUrls');
                        const contentClusters = getCleanedList('cciContentClusters');
                        const scope = getInputValue('cciScopeSelect') || 'url';
                        const model = getInputValue('cciModelSelect') || 'gpt-3.5-turbo';
                        console.log('[Content Clusters Identification] Selected model from dropdown:', model);
                        if (!urls || urls.length < 10) throw new Error('Please enter at least 10 URLs.');
                        if (urls.length > 1000) throw new Error('Maximum 1000 URLs allowed.');
                        payload.params = { 
                            urls,
                            scope,
                            model,
                            contentClusters: contentClusters && contentClusters.length > 0 ? contentClusters : null
                        };
                        console.log('[Content Clusters Identification] Payload params.model:', payload.params.model);
                        break;
                    }
                    default: throw new Error('Invalid method selected.');
                }
                
                if (['siteMetrics', 'keywordMetrics', 'brandAuthority', 'searchIntent', 'rankingKeywords', 'relatedKeywords', 'keywordCount', 'anchorText', 'recentlyGainedLinks', 'recentlyLostLinks', 'linkingDomains', 'finalRedirect', 'topPages', 'listLinks', 'filterLinksByAnchor'].includes(selectedMethod)) {
                    if ((payload.params.targets?.length === 0) && (payload.params.keywords?.length === 0)) {
                        throw new Error('Please enter at least one URL or Keyword.');
                    }
                }
                 if (selectedMethod === 'linkIntersect' && payload.params.is_linking_to.length === 0) {
                     throw new Error('Please enter at least one URL for "Linking To".');
                 }
                 if (selectedMethod === 'linkStatus' && (!payload.params.targetQuery || !payload.params.sourceQuery)) {
                    throw new Error('Please enter both a Target and Source URL for Link Status.');
                 }
                return payload;
            }
             
            function exportDataToCsv(results, method, originalParams) {
                const rows = DataProcessor.processResults(results, method, originalParams);
                if (rows.length === 0) { displayError("No valid data to export."); return; }
                
                const allKeys = [...new Set(rows.flatMap(row => Object.keys(row)))];
                const header = allKeys.join(',');
                const csvRows = rows.map(row => allKeys.map(key => {
                    const value = row[key] === undefined || row[key] === null ? '' : row[key];
                    const stringValue = String(value);
                    if (stringValue.includes(',') || stringValue.includes('"')) {
                        return `"${stringValue.replace(/"/g, '""')}"`;
                    }
                    return stringValue;
                }).join(','));
                const csvString = '\uFEFF' + [header, ...csvRows].join('\n');
                const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `moz-api-results-${method}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            function renderTable(results, method, originalParams) {
                // Destroy old table immediately (lightweight operation)
                if (table) {
                    table.destroy();
                    table = null;
                }
                
                // Show loading state immediately for better perceived performance
                const tableElement = document.getElementById('results-table');
                if (tableElement) {
                    tableElement.innerHTML = '<div class="p-8 text-center text-[var(--text-secondary)]">Loading table...</div>';
                }
                
                // Defer heavy processing to next frame to allow initial paint
                requestAnimationFrame(() => {
                    // Process data in next frame
                    const rows = DataProcessor.processResults(results, method, originalParams);
                    
                    if (rows.length > 0) {
                        // Use requestIdleCallback if available, otherwise setTimeout for non-critical work
                        const deferHeavyWork = (callback) => {
                            if (window.requestIdleCallback) {
                                requestIdleCallback(callback, { timeout: 100 });
                            } else {
                                setTimeout(callback, 0);
                            }
                        };
                        
                        // Extract column keys efficiently (use Set for O(1) lookups)
                        const keySet = new Set();
                        for (let i = 0; i < rows.length; i++) {
                            const keys = Object.keys(rows[i]);
                            for (let j = 0; j < keys.length; j++) {
                                keySet.add(keys[j]);
                            }
                        }
                        const allKeys = Array.from(keySet);
                        const columns = allKeys.map(key => ({ title: key, field: key }));
                        
                        // Create table immediately (Tabulator handles rendering efficiently)
                        requestAnimationFrame(() => {
                            table = new Tabulator("#results-table", {
                                data: rows,
                                columns: columns,
                                layout: "fitDataFill",
                                pagination: "local",
                                paginationSize: 100,
                                movableColumns: true,
                                resizableRows: false,
                                virtualDom: true, // Enable virtual DOM for better performance
                                virtualDomBuffer: 300, // Render buffer for smooth scrolling
                            });

                            // Defer filter field creation (non-critical UI)
                            deferHeavyWork(() => {
                                allDOMElements.filterFieldsContainer.innerHTML = '';
                                columns.forEach(col => {
                                    if (col.field) {
                                        const div = document.createElement('div');
                                        const label = document.createElement('label');
                                        label.textContent = col.title;
                                        label.className = 'block text-sm font-medium text-[var(--text-secondary)]';
                                        const input = document.createElement('input');
                                        input.type = 'text';
                                        input.dataset.field = col.field;
                                        input.className = 'w-full bg-[var(--bg-input-secondary)] border-[var(--border-secondary)] rounded-md p-2 mt-1 text-[var(--text-primary)]';
                                        div.appendChild(label);
                                        div.appendChild(input);
                                        allDOMElements.filterFieldsContainer.appendChild(div);
                                    }
                                });
                            });
                        });
                    } else {
                        if (tableElement) {
                            tableElement.innerHTML = '<div class="p-8 text-center text-[var(--text-secondary)]">No data to display</div>';
                        }
                    }
                });
            }

            function applyTableFilters() {
                const filterInputs = allDOMElements.filterFieldsContainer.querySelectorAll('input');
                currentFilters = [];
                filterInputs.forEach(input => {
                    if (input.value) {
                        currentFilters.push({
                            field: input.dataset.field,
                            type: 'like',
                            value: input.value
                        });
                    }
                });
                table.setFilter(currentFilters);
                updateActiveFilterChips();
                allDOMElements.filterModal.classList.add('hidden');
            }

            function updateActiveFilterChips() {
                allDOMElements.activeFiltersContainer.innerHTML = '';
                if (currentFilters.length > 0) {
                    const title = document.createElement('span');
                    title.className = 'text-sm font-bold text-[var(--text-secondary)]';
                    title.textContent = 'Active Filters:';
                    allDOMElements.activeFiltersContainer.appendChild(title);

                    currentFilters.forEach((filter, index) => {
                        const chip = document.createElement('span');
                        chip.className = 'inline-flex items-center px-2 py-1 bg-[var(--bg-input-secondary)] text-sm rounded-full';
                        chip.textContent = `${filter.field}: "${filter.value}"`;
                        const closeBtn = document.createElement('button');
                        closeBtn.className = 'ml-2 text-[var(--text-accent)]';
                        closeBtn.innerHTML = '&times;';
                        closeBtn.onclick = () => {
                            currentFilters.splice(index, 1);
                            table.setFilter(currentFilters);
                            updateActiveFilterChips();
                        };
                        chip.appendChild(closeBtn);
                        allDOMElements.activeFiltersContainer.appendChild(chip);
                    });
                    allDOMElements.activeFiltersContainer.classList.remove('hidden');
                } else {
                    allDOMElements.activeFiltersContainer.classList.add('hidden');
                }
            }

            // Initial calls
            allDOMElements.readmeModalContent.innerHTML = readmeContent;
            populateInputs();
            setupEventListeners();
            loadApiKey();
            loadOpenaiApiKey();
            allDOMElements.submitBtn.disabled = true;
            
            // Performance monitoring
            performanceMonitor.mark('init-complete');
            performanceMonitor.measure('initialization', 'dom-ready', 'init-complete');
            
            // Log performance metrics after a short delay
            setTimeout(() => {
                performanceMonitor.logMetrics();
            }, 100);

        });
    </script>
</body>
</html>